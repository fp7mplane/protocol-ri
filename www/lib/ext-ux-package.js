/**
 * @author Be?ta Pletscher
 * @docauthor Be?ta Pletscher
 */

/*
 * This file is the Entry Point for the implementation of this ExtJS package.
 * 
 * NOTE: Please DO NOT edit this file unless you know what you are exactly
 * doing.
 */

// BEGIN: Package definition
(function(){
	{
		var pkg =
		{
		  name : 'ext-ux',
		  namespace : 'NV.ext.ux',
		  path : 'ext-ux',
		  date : new Date('2014','10','27','16','15','39'), // 2014/10/27 16:15:39
		  version : new Ext.Version('1.0.0.28'),
		  description : 'Sencha extjs extensions'
		};
	
		// Register Package
	
		Ext.namespace( 'NV' );
		var packages = NV.$Packages || (NV.$Packages = {});
		packages[pkg.name] = pkg;
	
		Ext.Loader.setPath( pkg.namespace, 'lib/' + pkg.path );
	}
})();
// END: Package definition
// @tag ext-ux
/**
 * @class NV.ext.ux.DataTip
 * @extends Ext.ToolTip.
 * This plugin implements automatic tooltip generation for an arbitrary number of child nodes *within* a Component.
 *
 * This plugin is applied to a high level Component, which contains repeating elements, and depending on the host Component type,
 * it automatically selects a {@link Ext.ToolTip#delegate delegate} so that it appears when the mouse enters a sub-element.
 *
 * When applied to a GridPanel, this ToolTip appears when over a row, and the Record's data is applied
 * using this object's {@link #tpl} template.
 *
 * When applied to a DataView, this ToolTip appears when over a view node, and the Record's data is applied
 * using this object's {@link #tpl} template.
 *
 * When applied to a TreePanel, this ToolTip appears when over a tree node, and the Node's {@link Ext.data.Model} record data is applied
 * using this object's {@link #tpl} template.
 *
 * When applied to a FormPanel, this ToolTip appears when over a Field, and the Field's `tooltip` property is used is applied
 * using this object's {@link #tpl} template, or if it is a string, used as HTML content. If there is no `tooltip` property,
 * the field itself is used as the template's data object.
 *
 * If more complex logic is needed to determine content, then the {@link #beforeshow} event may be used.
 * This class also publishes a **`beforeshowtip`** event through its host Component. The *host Component* fires the
 * **`beforeshowtip`** event.
 */
Ext.define('NV.ext.ux.DataTip', function(DataTip) {

//  Target the body (if the host is a Panel), or, if there is no body, the main Element.
    function onHostRender() {
        var e = this.isXType('panel') ? this.body : this.el;
        if (this.dataTip.renderToTarget) {
            this.dataTip.render(e);
        }
        this.dataTip.setTarget(e);
    }

    function updateTip(tip, data) {
        if (tip.rendered) {
            if (tip.host.fireEvent('beforeshowtip', tip.eventHost, tip, data) === false) {
                return false;
            }
            tip.update(data);
        } else {
            if (Ext.isString(data)) {
                tip.html = data;
            } else {
                tip.data = data;
            }
        }
    }

    function beforeViewTipShow(tip) {
        var rec = this.view.getRecord(tip.triggerElement),
            data;

        if (rec) {
            data = tip.initialConfig.data ? Ext.apply(tip.initialConfig.data, rec.data) : rec.data;
            return updateTip(tip, data);
        } else {
            return false;
        }
    }

    function beforeFormTipShow(tip) {
        var field = Ext.getCmp(tip.triggerElement.id);
        if (field && (field.tooltip || tip.tpl)) {
            return updateTip(tip, field.tooltip || field);
        } else {
            return false;
        }
    }

    return {
        extend: 'Ext.tip.ToolTip',

        mixins: {
            plugin: 'Ext.AbstractPlugin'
        },

        alias: 'plugin.datatip',

        lockableScope: 'both',

        constructor: function(config) {
            var me = this;
            me.callParent([config]);
            me.mixins.plugin.constructor.call(me, config);
        },

        init: function(host) {
            var me = this;

            me.mixins.plugin.init.call(me, host);
            host.dataTip = me;
            me.host = host;

            if (host.isXType('tablepanel')) {
                me.view = host.getView();
                if (host.ownerLockable) {
                    me.host = host.ownerLockable;
                }
                me.delegate = me.delegate || me.view.getDataRowSelector();
                me.on('beforeshow', beforeViewTipShow);
            } else if (host.isXType('dataview')) {
                me.view = me.host;
                me.delegate = me.delegate || host.itemSelector;
                me.on('beforeshow', beforeViewTipShow);
            } else if (host.isXType('form')) {
                me.delegate = '.' + Ext.form.Labelable.prototype.formItemCls;
                me.on('beforeshow', beforeFormTipShow);
            } else if (host.isXType('combobox')) {
                me.view = host.getPicker();
                me.delegate = me.delegate || me.view.getItemSelector();
                me.on('beforeshow', beforeViewTipShow);
            }
            if (host.rendered) {
                onHostRender.call(host);
            } else {
                host.onRender = Ext.Function.createSequence(host.onRender, onHostRender);
            }
        }
    };
});

// @tag ext-ux
/*!
 * Ext JS Library 4.0
 * Copyright(c) 2006-2011 Sencha Inc.
 * licensing@sencha.com
 * http://www.sencha.com/license
 */

/**
 * Barebones iframe implementation. For serious iframe work, see the
 * ManagedIFrame extension
 * (http://www.sencha.com/forum/showthread.php?71961).
 */
Ext.define('NV.ext.ux.IFrame', {
    extend: 'Ext.Component',

    alias: 'widget.uxiframe',

    loadMask: 'Loading...',

    src: 'about:blank',

    renderTpl: [
        '<iframe src="{src}" name="{frameName}" width="100%" height="100%" frameborder="0"></iframe>'
    ],

    initComponent: function () {
        this.callParent();

        this.frameName = this.frameName || this.id + '-frame';

        this.addEvents(
            'beforeload',
            'load'
        );

        Ext.apply(this.renderSelectors, {
            iframeEl: 'iframe'
        });
    },

    initEvents : function() {
        var me = this;
        me.callParent();
        me.iframeEl.on('load', me.onLoad, me);
    },

    initRenderData: function() {
        return Ext.apply(this.callParent(), {
            src: this.src,
            frameName: this.frameName
        });
    },

    getBody: function() {
        var doc = this.getDoc();
        return doc.body || doc.documentElement;
    },

    getDoc: function() {
        try {
            return this.getWin().document;
        } catch (ex) {
            return null;
        }
    },

    getWin: function() {
        var me = this,
            name = me.frameName,
            win = Ext.isIE
                ? me.iframeEl.dom.contentWindow
                : window.frames[name];
        return win;
    },

    getFrame: function() {
        var me = this;
        return me.iframeEl.dom;
    },

    beforeDestroy: function () {
        var me = this,
            doc, prop;

        if (me.rendered) {
            try {
                doc = me.getDoc();
                if (doc) {
                    Ext.EventManager.removeAll(doc);
                    for (prop in doc) {
                        if (doc.hasOwnProperty && doc.hasOwnProperty(prop)) {
                            delete doc[prop];
                        }
                    }
                }
            } catch(e) { }
        }

        me.callParent();
    },

    onLoad: function() {
        var me = this,
            doc = me.getDoc(),
            fn = me.onRelayedEvent;

        if (doc) {
            try {
                Ext.EventManager.removeAll(doc);

                // These events need to be relayed from the inner document (where they stop
                // bubbling) up to the outer document. This has to be done at the DOM level so
                // the event reaches listeners on elements like the document body. The effected
                // mechanisms that depend on this bubbling behavior are listed to the right
                // of the event.
                Ext.EventManager.on(doc, {
                    mousedown: fn, // menu dismisal (MenuManager) and Window onMouseDown (toFront)
                    mousemove: fn, // window resize drag detection
                    mouseup: fn,   // window resize termination
                    click: fn,     // not sure, but just to be safe
                    dblclick: fn,  // not sure again
                    scope: me
                });
            } catch(e) {
                // cannot do this xss
            }

            // We need to be sure we remove all our events from the iframe on unload or we're going to LEAK!
            Ext.EventManager.on(window, 'unload', me.beforeDestroy, me);

            this.el.unmask();
            this.fireEvent('load', this);

        } else if(me.src && me.src != '') {

            this.el.unmask();
            this.fireEvent('error', this);
        }


    },

    onRelayedEvent: function (event) {
        // relay event from the iframe's document to the document that owns the iframe...

        var iframeEl = this.iframeEl,

            // Get the left-based iframe position
            iframeXY = Ext.Element.getTrueXY(iframeEl),
            originalEventXY = event.getXY(),

            // Get the left-based XY position.
            // This is because the consumer of the injected event (Ext.EventManager) will
            // perform its own RTL normalization.
            eventXY = Ext.EventManager.getPageXY(event.browserEvent);

        // the event from the inner document has XY relative to that document's origin,
        // so adjust it to use the origin of the iframe in the outer document:
        event.xy = [iframeXY[0] + eventXY[0], iframeXY[1] + eventXY[1]];

        event.injectEvent(iframeEl); // blame the iframe for the event...

        event.xy = originalEventXY; // restore the original XY (just for safety)
    },

    load: function (src) {
        var me = this,
            text = me.loadMask,
            frame = me.getFrame();

        if (me.fireEvent('beforeload', me, src) !== false) {
            if (text && me.el) {
                me.el.mask(text);
            }

            frame.src = me.src = (src || me.src);
        }
    }
});

// @tag ext-ux
/**
 * Paging Memory Proxy, allows to use paging grid with in memory dataset
 */
Ext.define('NV.ext.ux.data.PagingMemoryProxy', {
    extend: 'Ext.data.proxy.Memory',
    alias: ['proxy.pagingmemory'],
    alternateClassName: ['Ext.data.PagingMemoryProxy'],

    read : function(operation, callback, scope){
        var reader = this.getReader(),
            result = reader.read(this.data),
            sorters, filters, sorterFn, records;

        scope = scope || this;
        // filtering
        filters = operation.filters;
        if (filters && filters.length > 0) {
            //at this point we have an array of  Ext.util.Filter objects to filter with,
            //so here we construct a function that combines these filters by ANDing them together
            records = [];

            Ext.each(result.records, function(record) {
                var isMatch = true,
                    length = filters.length,
                    i;

                for (i = 0; i < length; i++) {
                    var filter = filters[i],
                        fn     = filter.filterFn,
                        scope  = filter.scope;

                    isMatch = isMatch && fn.call(scope, record);
                }
                if (isMatch) {
                    records.push(record);
                }
            }, this);

            result.records = records;
            result.totalRecords = result.total = records.length;
        }
        
        // sorting
        sorters = operation.sorters;
        if (sorters && sorters.length > 0) {
            //construct an amalgamated sorter function which combines all of the Sorters passed
            sorterFn = function(r1, r2) {
                var result = sorters[0].sort(r1, r2),
                    length = sorters.length,
                    i;
                
                    //if we have more than one sorter, OR any additional sorter functions together
                    for (i = 1; i < length; i++) {
                        result = result || sorters[i].sort.call(this, r1, r2);
                    }                
               
                return result;
            };
    
            result.records.sort(sorterFn);
        }
        
        // paging (use undefined cause start can also be 0 (thus false))
        if (operation.start !== undefined && operation.limit !== undefined) {
            result.records = result.records.slice(operation.start, operation.start + operation.limit);
            result.count = result.records.length;
        }

        Ext.apply(operation, {
            resultSet: result
        });
        
        operation.setCompleted();
        operation.setSuccessful();

        Ext.Function.defer(function () {
            Ext.callback(callback, scope, [operation]);
        }, 10);
    }
});

// @tag ext-ux
/**
 * @class NV.ext.ux.data.DynamicReader
 * @extends Ext.data.reader.Json
 * <p>Dynamic reader, allow to get working grid with auto generated columns and without setting a model in store</p>
 */

/**
 * floatOrString data type provide proper sorting in grid for string and float
 * if you don't now what data type of that two whould be in column
 */
Ext.apply(Ext.data.Types, {
    FLOATORSTRING: {
        convert: function(v, n) {
            v = Ext.isNumeric(v) ? Number(v) : v;
            return v;
        },
        sortType: function(v) {
            v = Ext.isNumeric(v) ? Number(v) : v;
            return v;
        },
        type: 'floatOrString'
    }
});

Ext.define('NV.ext.ux.data.reader.DynamicReader', {
    extend: 'Ext.data.reader.Json',
    alias: 'reader.dynamicReader',
    alternateClassName: 'Ext.data.reader.DynamicReader',

    readRecords: function(data) {
        if (data.length > 0) {
            var item = data[0];
            var fields = new Array();
            var columns = new Array();
            var p;

            for (p in item) {
                if (p && p != undefined) {
                    // floatOrString type is only an option
                    // You can make your own data type for more complex situations
                    // or set it just to 'string'
                    fields.push({name: p, type: 'floatOrString'});
                    columns.push({text: p, dataIndex: p});
                }
            }

            data.metaData = { fields: fields, columns: columns };
        }

        return this.callParent([data]);
    }
});

// @tag ext-ux
/**
 * A control that allows selection of multiple items in a list.
 */
Ext.define('NV.ext.ux.form.MultiSelect', {
    
    extend: 'Ext.form.FieldContainer',
    
    mixins: {
        bindable: 'Ext.util.Bindable',
        field: 'Ext.form.field.Field'    
    },
    
    alternateClassName: 'NV.ext.ux.Multiselect',
    alias: ['widget.multiselectfield', 'widget.multiselect'],
    
    requires: ['Ext.panel.Panel', 'Ext.view.BoundList', 'Ext.layout.container.Fit'],
    
    uses: ['Ext.view.DragZone', 'Ext.view.DropZone'],
    
    layout: 'anchor',
    
    /**
     * @cfg {String} [dragGroup=""] The ddgroup name for the MultiSelect DragZone.
     */

    /**
     * @cfg {String} [dropGroup=""] The ddgroup name for the MultiSelect DropZone.
     */
    
    /**
     * @cfg {String} [title=""] A title for the underlying panel.
     */
    
    /**
     * @cfg {Boolean} [ddReorder=false] Whether the items in the MultiSelect list are drag/drop reorderable.
     */
    ddReorder: false,

    /**
     * @cfg {Object/Array} tbar An optional toolbar to be inserted at the top of the control's selection list.
     * This can be a {@link Ext.toolbar.Toolbar} object, a toolbar config, or an array of buttons/button configs
     * to be added to the toolbar. See {@link Ext.panel.Panel#tbar}.
     */

    /**
     * @cfg {String} [appendOnly=false] `true` if the list should only allow append drops when drag/drop is enabled.
     * This is useful for lists which are sorted.
     */
    appendOnly: false,

    /**
     * @cfg {String} [displayField="text"] Name of the desired display field in the dataset.
     */
    displayField: 'text',

    /**
     * @cfg {String} [valueField="text"] Name of the desired value field in the dataset.
     */

    /**
     * @cfg {Boolean} [allowBlank=true] `false` to require at least one item in the list to be selected, `true` to allow no
     * selection.
     */
    allowBlank: true,

    /**
     * @cfg {Number} [minSelections=0] Minimum number of selections allowed.
     */
    minSelections: 0,

    /**
     * @cfg {Number} [maxSelections=Number.MAX_VALUE] Maximum number of selections allowed.
     */
    maxSelections: Number.MAX_VALUE,

    /**
     * @cfg {String} [blankText="This field is required"] Default text displayed when the control contains no items.
     */
    blankText: 'This field is required',

    /**
     * @cfg {String} [minSelectionsText="Minimum {0}item(s) required"] 
     * Validation message displayed when {@link #minSelections} is not met. 
     * The {0} token will be replaced by the value of {@link #minSelections}.
     */
    minSelectionsText: 'Minimum {0} item(s) required',
    
    /**
     * @cfg {String} [maxSelectionsText="Maximum {0}item(s) allowed"] 
     * Validation message displayed when {@link #maxSelections} is not met
     * The {0} token will be replaced by the value of {@link #maxSelections}.
     */
    maxSelectionsText: 'Maximum {0} item(s) required',

    /**
     * @cfg {String} [delimiter=","] The string used to delimit the selected values when {@link #getSubmitValue submitting}
     * the field as part of a form. If you wish to have the selected values submitted as separate
     * parameters rather than a single delimited parameter, set this to `null`.
     */
    delimiter: ',',
    
    /**
     * @cfg String [dragText="{0} Item{1}"] The text to show while dragging items.
     * {0} will be replaced by the number of items. {1} will be replaced by the plural
     * form if there is more than 1 item.
     */
    dragText: '{0} Item{1}',

    /**
     * @cfg {Ext.data.Store/Array} store The data source to which this MultiSelect is bound (defaults to `undefined`).
     * Acceptable values for this property are:
     * <div class="mdetail-params"><ul>
     * <li><b>any {@link Ext.data.Store Store} subclass</b></li>
     * <li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally.
     * <div class="mdetail-params"><ul>
     * <li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">
     * A 1-dimensional array will automatically be expanded (each array item will be the combo
     * {@link #valueField value} and {@link #displayField text})</div></li>
     * <li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">
     * For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
     * {@link #valueField value}, while the value at index 1 is assumed to be the combo {@link #displayField text}.
     * </div></li></ul></div></li></ul></div>
     */
    
    ignoreSelectChange: 0,

    /**
     * @cfg {Object} listConfig
     * An optional set of configuration properties that will be passed to the {@link Ext.view.BoundList}'s constructor.
     * Any configuration that is valid for BoundList can be included.
     */

    initComponent: function(){
        var me = this;

        me.bindStore(me.store, true);
        if (me.store.autoCreated) {
            me.valueField = me.displayField = 'field1';
            if (!me.store.expanded) {
                me.displayField = 'field2';
            }
        }

        if (!Ext.isDefined(me.valueField)) {
            me.valueField = me.displayField;
        }
        me.items = me.setupItems();
        
        
        me.callParent();
        me.initField();
        me.addEvents('drop');    
    },
    
    setupItems: function() {
        var me = this;

        me.boundList = Ext.create('Ext.view.BoundList', Ext.apply({
            anchor: 'none 100%',
            deferInitialRefresh: false,
            border: 1,
            multiSelect: true,
            store: me.store,
            displayField: me.displayField,
            disabled: me.disabled
        }, me.listConfig));
        me.boundList.getSelectionModel().on('selectionchange', me.onSelectChange, me);
        
        // Only need to wrap the BoundList in a Panel if we have a title.
        if (!me.title) {
            return me.boundList;
        }

        // Wrap to add a title
        me.boundList.border = false;
        return {
            border: true,
            anchor: 'none 100%',
            layout: 'anchor',
            title: me.title,
            tbar: me.tbar,
            items: me.boundList
        };
    },

    onSelectChange: function(selModel, selections){
        if (!this.ignoreSelectChange) {
            this.setValue(selections);
        }    
    },
    
    getSelected: function(){
        return this.boundList.getSelectionModel().getSelection();
    },
    
    // compare array values
    isEqual: function(v1, v2) {
        var fromArray = Ext.Array.from,
            i = 0, 
            len;

        v1 = fromArray(v1);
        v2 = fromArray(v2);
        len = v1.length;

        if (len !== v2.length) {
            return false;
        }

        for(; i < len; i++) {
            if (v2[i] !== v1[i]) {
                return false;
            }
        }

        return true;
    },
    
    afterRender: function(){
        var me = this,
            records;
        
        me.callParent();
        if (me.selectOnRender) {
            records = me.getRecordsForValue(me.value);
            if (records.length) {
                ++me.ignoreSelectChange;
                me.boundList.getSelectionModel().select(records);
                --me.ignoreSelectChange;
            }
            delete me.toSelect;
        }    
        
        if (me.ddReorder && !me.dragGroup && !me.dropGroup){
            me.dragGroup = me.dropGroup = 'MultiselectDD-' + Ext.id();
        }

        if (me.draggable || me.dragGroup){
            me.dragZone = Ext.create('Ext.view.DragZone', {
                view: me.boundList,
                ddGroup: me.dragGroup,
                dragText: me.dragText
            });
        }
        if (me.droppable || me.dropGroup){
            me.dropZone = Ext.create('Ext.view.DropZone', {
                view: me.boundList,
                ddGroup: me.dropGroup,
                handleNodeDrop: function(data, dropRecord, position) {
                    var view = this.view,
                        store = view.getStore(),
                        records = data.records,
                        index;

                    // remove the Models from the source Store
                    data.view.store.remove(records);

                    index = store.indexOf(dropRecord);
                    if (position === 'after') {
                        index++;
                    }
                    store.insert(index, records);
                    view.getSelectionModel().select(records);
                    me.fireEvent('drop', me, records);
                }
            });
        }
    },
    
    isValid : function() {
        var me = this,
            disabled = me.disabled,
            validate = me.forceValidation || !disabled;
            
        
        return validate ? me.validateValue(me.value) : disabled;
    },
    
    validateValue: function(value) {
        var me = this,
            errors = me.getErrors(value),
            isValid = Ext.isEmpty(errors);
            
        if (!me.preventMark) {
            if (isValid) {
                me.clearInvalid();
            } else {
                me.markInvalid(errors);
            }
        }

        return isValid;
    },
    
    markInvalid : function(errors) {
        // Save the message and fire the 'invalid' event
        var me = this,
            oldMsg = me.getActiveError();
        me.setActiveErrors(Ext.Array.from(errors));
        if (oldMsg !== me.getActiveError()) {
            me.updateLayout();
        }
    },

    /**
     * Clear any invalid styles/messages for this field.
     *
     * __Note:__ this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return `true`
     * if the value does not _pass_ validation. So simply clearing a field's errors will not necessarily allow
     * submission of forms submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
     */
    clearInvalid : function() {
        // Clear the message and fire the 'valid' event
        var me = this,
            hadError = me.hasActiveError();
        me.unsetActiveError();
        if (hadError) {
            me.updateLayout();
        }
    },
    
    getSubmitData: function() {
        var me = this,
            data = null,
            val;
        if (!me.disabled && me.submitValue && !me.isFileUpload()) {
            val = me.getSubmitValue();
            if (val !== null) {
                data = {};
                data[me.getName()] = val;
            }
        }
        return data;
    },

    /**
     * Returns the value that would be included in a standard form submit for this field.
     *
     * @return {String} The value to be submitted, or `null`.
     */
    getSubmitValue: function() {
        var me = this,
            delimiter = me.delimiter,
            val = me.getValue();
        
        return Ext.isString(delimiter) ? val.join(delimiter) : val;
    },
    
    getValue: function(){
        return this.value || [];
    },
    
    getRecordsForValue: function(value){
        var me = this,
            records = [],
            all = me.store.getRange(),
            valueField = me.valueField,
            i = 0,
            allLen = all.length,
            rec,
            j,
            valueLen;
            
        for (valueLen = value.length; i < valueLen; ++i) {
            for (j = 0; j < allLen; ++j) {
                rec = all[j];   
                if (rec.get(valueField) == value[i]) {
                    records.push(rec);
                }
            }    
        }
            
        return records;
    },
    
    setupValue: function(value){
        var delimiter = this.delimiter,
            valueField = this.valueField,
            i = 0,
            out,
            len,
            item;
            
        if (Ext.isDefined(value)) {
            if (delimiter && Ext.isString(value)) {
                value = value.split(delimiter);
            } else if (!Ext.isArray(value)) {
                value = [value];
            }
        
            for (len = value.length; i < len; ++i) {
                item = value[i];
                if (item && item.isModel) {
                    value[i] = item.get(valueField);
                }
            }
            out = Ext.Array.unique(value);
        } else {
            out = [];
        }
        return out;
    },
    
    setValue: function(value){
        var me = this,
            selModel = me.boundList.getSelectionModel(),
            store = me.store;

        // Store not loaded yet - we cannot set the value
        if (!store.getCount()) {
            store.on({
                load: Ext.Function.bind(me.setValue, me, [value]),
                single: true
            });
            return;
        }

        value = me.setupValue(value);
        me.mixins.field.setValue.call(me, value);
        
        if (me.rendered) {
            ++me.ignoreSelectChange;
            selModel.deselectAll();
            selModel.select(me.getRecordsForValue(value));
            --me.ignoreSelectChange;
        } else {
            me.selectOnRender = true;
        }
    },
    
    clearValue: function(){
        this.setValue([]);    
    },
    
    onEnable: function(){
        var list = this.boundList;
        this.callParent();
        if (list) {
            list.enable();
        }
    },
    
    onDisable: function(){
        var list = this.boundList;
        this.callParent();
        if (list) {
            list.disable();
        }
    },
    
    getErrors : function(value) {
        var me = this,
            format = Ext.String.format,
            errors = [],
            numSelected;

        value = Ext.Array.from(value || me.getValue());
        numSelected = value.length;

        if (!me.allowBlank && numSelected < 1) {
            errors.push(me.blankText);
        }
        if (numSelected < me.minSelections) {
            errors.push(format(me.minSelectionsText, me.minSelections));
        }
        if (numSelected > me.maxSelections) {
            errors.push(format(me.maxSelectionsText, me.maxSelections));
        }
        return errors;
    },
    
    onDestroy: function(){
        var me = this;
        
        me.bindStore(null);
        Ext.destroy(me.dragZone, me.dropZone);
        me.callParent();
    },
    
    onBindStore: function(store){
        var boundList = this.boundList;
        
        if (boundList) {
            boundList.bindStore(store);
        }
    }
    
});

// @tag ext-ux
/*
 * Note that this control will most likely remain as an example, and not as a core Ext form
 * control.  However, the API will be changing in a future release and so should not yet be
 * treated as a final, stable API at this time.
 */

/**
 * A control that allows selection of between two NV.ext.ux.form.MultiSelect controls.
 */
Ext.define('NV.ext.ux.form.ItemSelector', {
    extend: 'NV.ext.ux.form.MultiSelect',
    alias: ['widget.itemselectorfield', 'widget.itemselector'],
    alternateClassName: ['NV.ext.ux.ItemSelector'],
    requires: [
        'Ext.button.Button',
        'NV.ext.ux.form.MultiSelect'
    ],

    /**
     * @cfg {Boolean} [hideNavIcons=false] True to hide the navigation icons
     */
    hideNavIcons:false,

    /**
     * @cfg {Array} buttons Defines the set of buttons that should be displayed in between the ItemSelector
     * fields. Defaults to <tt>['top', 'up', 'add', 'remove', 'down', 'bottom']</tt>. These names are used
     * to build the button CSS class names, and to look up the button text labels in {@link #buttonsText}.
     * This can be overridden with a custom Array to change which buttons are displayed or their order.
     */
    buttons: ['top', 'up', 'add', 'remove', 'down', 'bottom'],

    /**
     * @cfg {Object} buttonsText The tooltips for the {@link #buttons}.
     * Labels for buttons.
     */
    buttonsText: {
        top: "Move to Top",
        up: "Move Up",
        add: "Add to Selected",
        remove: "Remove from Selected",
        down: "Move Down",
        bottom: "Move to Bottom"
    },

    layout: {
        type: 'hbox',
        align: 'stretch'
    },

    initComponent: function() {
        var me = this;

        me.ddGroup = me.id + '-dd';
        me.callParent();

        // bindStore must be called after the fromField has been created because
        // it copies records from our configured Store into the fromField's Store
        me.bindStore(me.store);
    },

    createList: function(title){
        var me = this;

        return Ext.create('NV.ext.ux.form.MultiSelect', {
            // We don't want the multiselects themselves to act like fields,
            // so override these methods to prevent them from including
            // any of their values
            submitValue: false,
            getSubmitData: function(){
                return null;
            },
            getModelData: function(){
                return null;    
            },
            flex: 1,
            dragGroup: me.ddGroup,
            dropGroup: me.ddGroup,
            title: title,
            store: {
                model: me.store.model,
                data: []
            },
            displayField: me.displayField,
            valueField: me.valueField,
            disabled: me.disabled,
            listeners: {
                boundList: {
                    scope: me,
                    itemdblclick: me.onItemDblClick,
                    drop: me.syncValue
                }
            }
        });
    },

    setupItems: function() {
        var me = this;

        me.fromField = me.createList(me.fromTitle);
        me.toField = me.createList(me.toTitle);

        return [
            me.fromField,
            {
                xtype: 'container',
                margins: '0 4',
                layout: {
                    type: 'vbox',
                    pack: 'center'
                },
                items: me.createButtons()
            },
            me.toField
        ];
    },

    createButtons: function() {
        var me = this,
            buttons = [];

        if (!me.hideNavIcons) {
            Ext.Array.forEach(me.buttons, function(name) {
                buttons.push({
                    xtype: 'button',
                    tooltip: me.buttonsText[name],
                    handler: me['on' + Ext.String.capitalize(name) + 'BtnClick'],
                    cls: Ext.baseCSSPrefix + 'form-itemselector-btn',
                    iconCls: Ext.baseCSSPrefix + 'form-itemselector-' + name,
                    navBtn: true,
                    scope: me,
                    margin: '4 0 0 0'
                });
            });
        }
        return buttons;
    },

    /**
     * Get the selected records from the specified list.
     * 
     * Records will be returned *in store order*, not in order of selection.
     * @param {Ext.view.BoundList} list The list to read selections from.
     * @return {Ext.data.Model[]} The selected records in store order.
     * 
     */
    getSelections: function(list) {
        var store = list.getStore();

        return Ext.Array.sort(list.getSelectionModel().getSelection(), function(a, b) {
            a = store.indexOf(a);
            b = store.indexOf(b);

            if (a < b) {
                return -1;
            } else if (a > b) {
                return 1;
            }
            return 0;
        });
    },

    onTopBtnClick : function() {
        var list = this.toField.boundList,
            store = list.getStore(),
            selected = this.getSelections(list);

        store.suspendEvents();
        store.remove(selected, true);
        store.insert(0, selected);
        store.resumeEvents();
        list.refresh();
        this.syncValue(); 
        list.getSelectionModel().select(selected);
    },

    onBottomBtnClick : function() {
        var list = this.toField.boundList,
            store = list.getStore(),
            selected = this.getSelections(list);

        store.suspendEvents();
        store.remove(selected, true);
        store.add(selected);
        store.resumeEvents();
        list.refresh();
        this.syncValue();
        list.getSelectionModel().select(selected);
    },

    onUpBtnClick : function() {
        var list = this.toField.boundList,
            store = list.getStore(),
            selected = this.getSelections(list),
            rec,
            i = 0,
            len = selected.length,
            index = 0;

        // Move each selection up by one place if possible
        store.suspendEvents();
        for (; i < len; ++i, index++) {
            rec = selected[i];
            index = Math.max(index, store.indexOf(rec) - 1);
            store.remove(rec, true);
            store.insert(index, rec);
        }
        store.resumeEvents();
        list.refresh();
        this.syncValue();
        list.getSelectionModel().select(selected);
    },

    onDownBtnClick : function() {
        var list = this.toField.boundList,
            store = list.getStore(),
            selected = this.getSelections(list),
            rec,
            i = selected.length - 1,
            index = store.getCount() - 1;

        // Move each selection down by one place if possible
        store.suspendEvents();
        for (; i > -1; --i, index--) {
            rec = selected[i];
            index = Math.min(index, store.indexOf(rec) + 1);
            store.remove(rec, true);
            store.insert(index, rec);
        }
        store.resumeEvents();
        list.refresh();
        this.syncValue();
        list.getSelectionModel().select(selected);
    },

    onAddBtnClick : function() {
        var me = this,
            selected = me.getSelections(me.fromField.boundList);

        me.moveRec(true, selected);
        me.toField.boundList.getSelectionModel().select(selected);
    },

    onRemoveBtnClick : function() {
        var me = this,
            selected = me.getSelections(me.toField.boundList);

        me.moveRec(false, selected);
        me.fromField.boundList.getSelectionModel().select(selected);
    },

    moveRec: function(add, recs) {
        var me = this,
            fromField = me.fromField,
            toField   = me.toField,
            fromStore = add ? fromField.store : toField.store,
            toStore   = add ? toField.store   : fromField.store;

        fromStore.suspendEvents();
        toStore.suspendEvents();
        fromStore.remove(recs);
        toStore.add(recs);
        fromStore.resumeEvents();
        toStore.resumeEvents();

        fromField.boundList.refresh();
        toField.boundList.refresh();

        me.syncValue();
    },

    // Synchronizes the submit value with the current state of the toStore
    syncValue: function() {
        var me = this; 
        me.mixins.field.setValue.call(me, me.setupValue(me.toField.store.getRange()));
    },

    onItemDblClick: function(view, rec) {
        this.moveRec(view === this.fromField.boundList, rec);
    },

    setValue: function(value) {
        var me = this,
            fromField = me.fromField,
            toField = me.toField,
            fromStore = fromField.store,
            toStore = toField.store,
            selected;

        // Wait for from store to be loaded
        if (!me.fromStorePopulated) {
            me.fromField.store.on({
                load: Ext.Function.bind(me.setValue, me, [value]),
                single: true
            });
            return;
        }

        value = me.setupValue(value);
        me.mixins.field.setValue.call(me, value);

        selected = me.getRecordsForValue(value);

        // Clear both left and right Stores.
        // Both stores must not fire events during this process.
        fromStore.suspendEvents();
        toStore.suspendEvents();
        fromStore.removeAll();
        toStore.removeAll();

        // Reset fromStore
        me.populateFromStore(me.store);

        // Copy selection across to toStore
        Ext.Array.forEach(selected, function(rec){
            // In the from store, move it over
            if (fromStore.indexOf(rec) > -1) {
                fromStore.remove(rec);
            }
            toStore.add(rec);
        });

        // Stores may now fire events
        fromStore.resumeEvents();
        toStore.resumeEvents();

        // Refresh both sides and then update the app layout
        Ext.suspendLayouts();
        fromField.boundList.refresh();
        toField.boundList.refresh();
        Ext.resumeLayouts(true);        
    },

    onBindStore: function(store, initial) {
        var me = this;

        if (me.fromField) {
            me.fromField.store.removeAll()
            me.toField.store.removeAll();

            // Add everything to the from field as soon as the Store is loaded
            if (store.getCount()) {
                me.populateFromStore(store);
            } else {
                me.store.on('load', me.populateFromStore, me);
            }
        }
    },

    populateFromStore: function(store) {
        var fromStore = this.fromField.store;

        // Flag set when the fromStore has been loaded
        this.fromStorePopulated = true;

        fromStore.add(store.getRange());

        // setValue waits for the from Store to be loaded
        fromStore.fireEvent('load', fromStore);
    },

    onEnable: function(){
        var me = this;

        me.callParent();
        me.fromField.enable();
        me.toField.enable();

        Ext.Array.forEach(me.query('[navBtn]'), function(btn){
            btn.enable();
        });
    },

    onDisable: function(){
        var me = this;

        me.callParent();
        me.fromField.disable();
        me.toField.disable();

        Ext.Array.forEach(me.query('[navBtn]'), function(btn){
            btn.disable();
        });
    },

    onDestroy: function(){
        this.bindStore(null);
        this.callParent();
    }
});

// @tag ext-ux
/**
 * Lukas Sliwinski
 * sliwinski.lukas@gmail.com
 *
 * Dynamic grid, allow to display data setting only URL.
 * Columns and model will be created dynamically.
 */

Ext.define('NV.ext.ux.grid.DynamicGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.dynamicGrid',
    alternateClassName: 'Ext.grid.DynamicGrid',

    requires: [
        'NV.ext.ux.data.reader.DynamicReader'
    ],
    // URL used for request to the server. Required
    url: '',

    initComponent: function() {
        console.log('DynamicGrid initComponent!');
        var me = this;

        if (me.url == '') {
            Ext.Error.raise('url parameter is empty! You have to set proper url to get data form server.');
        }
        else {
            Ext.applyIf(me, {
                columns: [],
                forceFit: true,
                store: Ext.create('Ext.data.Store', {
                    // Fields have to be set as empty array. Without this Ext will not create dynamic model.
                    fields: [],
                    // After loading data grid have to reconfigure columns with dynamic created columns
                    // in NV.ext.ux.data.reader.DynamicReader
                    listeners: {
                        'metachange': function(store, meta) {
                            me.reconfigure(store, meta.columns);
                        }
                    },
                    autoLoad: true,
                    remoteSort: false,
                    remoteFilter: false,
                    remoteGroup: false,
                    proxy: {
                        reader: 'dynamicReader',
                        type: 'rest',
                        url: me.url
                    }
                })
            });
        }

        me.callParent(arguments);
    }
});

// @tag ext-ux
/**
 * FiltersFeature is a grid {@link Ext.grid.feature.Feature feature} that allows for a slightly more
 * robust representation of filtering than what is provided by the default store.
 *
 * Filtering is adjusted by the user using the grid's column header menu (this menu can be
 * disabled through configuration). Through this menu users can configure, enable, and
 * disable filters for each column.
 *
 * #Features#
 *
 * ##Filtering implementations:##
 *
 * Default filtering for Strings, Numeric Ranges, Date Ranges, Lists (which can be backed by a
 * {@link Ext.data.Store}), and Boolean. Additional custom filter types and menus are easily
 * created by extending {@link NV.ext.ux.grid.filter.Filter}.
 *
 * ##Graphical Indicators:##
 *
 * Columns that are filtered have {@link #filterCls a configurable css class} applied to the column headers.
 *
 * ##Automatic Reconfiguration:##
 *
 * Filters automatically reconfigure when the grid 'reconfigure' event fires.
 *
 * ##Stateful:##
 *
 * Filter information will be persisted across page loads by specifying a `stateId`
 * in the Grid configuration.
 *
 * The filter collection binds to the {@link Ext.grid.Panel#beforestaterestore beforestaterestore}
 * and {@link Ext.grid.Panel#beforestatesave beforestatesave} events in order to be stateful.
 *
 * ##GridPanel Changes:##
 *
 * - A `filters` property is added to the GridPanel using this feature.
 * - A `filterupdate` event is added to the GridPanel and is fired upon onStateChange completion.
 *
 * ##Server side code examples:##
 *
 * - [PHP](http://www.vinylfox.com/extjs/grid-filter-php-backend-code.php) - (Thanks VinylFox)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=77326#post77326) - (Thanks Zyclops)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=176596#post176596) - (Thanks Rotomaul)
 *
 * #Example usage:#
 *
 *     var store = Ext.create('Ext.data.Store', {
 *         pageSize: 15
 *         ...
 *     });
 *
 *     var filtersCfg = {
 *         ftype: 'filters',
 *         autoReload: false, //don't reload automatically
 *         local: true, //only filter locally
 *         // filters may be configured through the plugin,
 *         // or in the column definition within the headers configuration
 *         filters: [{
 *             type: 'numeric',
 *             dataIndex: 'id'
 *         }, {
 *             type: 'string',
 *             dataIndex: 'name'
 *         }, {
 *             type: 'numeric',
 *             dataIndex: 'price'
 *         }, {
 *             type: 'date',
 *             dataIndex: 'dateAdded'
 *         }, {
 *             type: 'list',
 *             dataIndex: 'size',
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large'],
 *             phpMode: true
 *         }, {
 *             type: 'boolean',
 *             dataIndex: 'visible'
 *         }]
 *     };
 *
 *     var grid = Ext.create('Ext.grid.Panel', {
 *          store: store,
 *          columns: ...,
 *          features: [filtersCfg],
 *          height: 400,
 *          width: 700,
 *          bbar: Ext.create('Ext.PagingToolbar', {
 *              store: store
 *          })
 *     });
 *
 *     // a filters property is added to the GridPanel
 *     grid.filters
 */
Ext.define('NV.ext.ux.grid.FiltersFeature', {
    extend: 'Ext.grid.feature.Feature',
    alias: 'feature.filters',
    uses: [
        'NV.ext.ux.grid.menu.ListMenu',
        'NV.ext.ux.grid.menu.RangeMenu',
        'NV.ext.ux.grid.filter.BooleanFilter',
        'NV.ext.ux.grid.filter.DateFilter',
        'NV.ext.ux.grid.filter.DateTimeFilter',
        'NV.ext.ux.grid.filter.ListFilter',
        'NV.ext.ux.grid.filter.NumericFilter',
        'NV.ext.ux.grid.filter.StringFilter',
        'NV.ext.ux.nv.grid.filter.ComboFilter',
        'NV.ext.ux.nv.grid.filter.DateTimeFieldFilter',
        'NV.ext.ux.nv.grid.filter.ListFilterOneSelect',
        'NV.ext.ux.nv.grid.filter.TimeStringFilter',
        'NV.ext.ux.nv.grid.filter.TimeStringFieldFilter'
    ],

    /**
     * @cfg {Boolean} autoReload
     * Defaults to true, reloading the datasource when a filter change happens.
     * Set this to false to prevent the datastore from being reloaded if there
     * are changes to the filters.  See <code>{@link #updateBuffer}</code>.
     */
    autoReload : true,
    /**
     * @cfg {Boolean} encode
     * Specify true for {@link #buildQuery} to use Ext.util.JSON.encode to
     * encode the filter query parameter sent with a remote request.
     * Defaults to false.
     */
    /**
     * @cfg {Array} filters
     * An Array of filters config objects. Refer to each filter type class for
     * configuration details specific to each filter type. Filters for Strings,
     * Numeric Ranges, Date Ranges, Lists, and Boolean are the standard filters
     * available.
     */
    /**
     * @cfg {String} filterCls
     * The css class to be applied to column headers with active filters.
     * Defaults to <tt>'ux-filterd-column'</tt>.
     */
    filterCls : 'ux-filtered-column',
    /**
     * @cfg {Boolean} local
     * <tt>true</tt> to use Ext.data.Store filter functions (local filtering)
     * instead of the default (<tt>false</tt>) server side filtering.
     */
    local : false,
    /**
     * @cfg {String} menuFilterText
     * defaults to <tt>'Filters'</tt>.
     */
    menuFilterText : 'Filters',
    /**
     * @cfg {String} paramPrefix
     * The url parameter prefix for the filters.
     * Defaults to <tt>'filter'</tt>.
     */
    paramPrefix : 'filter',
    /**
     * @cfg {Boolean} showMenu
     * Defaults to true, including a filter submenu in the default header menu.
     */
    showMenu : true,
    /**
     * @cfg {String} stateId
     * Name of the value to be used to store state information.
     */
    stateId : undefined,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to defer store updates since the last filter change.
     */
    updateBuffer : 500,

    // doesn't handle grid body events
    hasFeatureEvent: false,


    /** @private */
    constructor : function (config) {
        var me = this;

        config = config || {};
        Ext.apply(me, config);

        me.deferredUpdate = Ext.create('Ext.util.DelayedTask', me.reload, me);

        // Init filters
        me.filters = me.createFiltersCollection();
        me.filterConfigs = config.filters;
    },

    init: function(grid) {
        var me = this,
            view = me.view,
            headerCt = view.headerCt;

        me.bindStore(view.getStore(), true);

        // Listen for header menu being created
        headerCt.on('menucreate', me.onMenuCreate, me);

        view.on('refresh', me.onRefresh, me);
        grid.on({
            scope: me,
            beforestaterestore: me.applyState,
            beforestatesave: me.saveState,
            beforedestroy: me.destroy
        });

        // Add event and filters shortcut on grid panel
        grid.filters = me;
        grid.addEvents('filterupdate');
    },

    createFiltersCollection: function () {
        return Ext.create('Ext.util.MixedCollection', false, function (o) {
            return o ? o.dataIndex : null;
        });
    },

    /**
     * @private Create the Filter objects for the current configuration, destroying any existing ones first.
     */
    createFilters: function() {
        var me = this,
            hadFilters = me.filters.getCount(),
            grid = me.getGridPanel(),
            filters = me.createFiltersCollection(),
            model = grid.store.model,
            fields = model.prototype.fields,
            field,
            filter,
            state;

        if (hadFilters) {
            state = {};
            me.saveState(null, state);
        }

        function add (dataIndex, config, filterable) {
            if (dataIndex && (filterable || config)) {
                field = fields.get(dataIndex);
                filter = {
                    dataIndex: dataIndex,
                    type: (field && field.type && field.type.type) || 'auto'
                };

                if (Ext.isObject(config)) {
                    Ext.apply(filter, config);
                }

                filters.replace(filter);
            }
        }

        // We start with filters from our config
        Ext.Array.each(me.filterConfigs, function (filterConfig) {
            add(filterConfig.dataIndex, filterConfig);
        });

        // Then we merge on filters from the columns in the grid. The columns' filters take precedence.
        Ext.Array.each(grid.columns, function (column) {
            if (column.filterable === false) {
                filters.removeAtKey(column.dataIndex);
            } else {
                add(column.dataIndex, column.filter, column.filterable);
            }
        });
        

        me.removeAll();
        if (filters.items) {
            me.initializeFilters(filters.items);
        }

        if (hadFilters) {
            me.applyState(null, state);
        }
    },

    /**
     * @private
     */
    initializeFilters: function(filters) {
        var me = this,
            filtersLength = filters.length,
            i, filter, FilterClass;

        for (i = 0; i < filtersLength; i++) {
            filter = filters[i];
            if (filter) {
                FilterClass = me.getFilterClass(filter.type);
                filter = filter.menu ? filter : new FilterClass(filter);
                me.filters.add(filter);
                Ext.util.Observable.capture(filter, this.onStateChange, this);
            }
        }
    },

    /**
     * @private Handle creation of the grid's header menu. Initializes the filters and listens
     * for the menu being shown.
     */
    onMenuCreate: function(headerCt, menu) {
        var me = this;
        me.createFilters();
        menu.on('beforeshow', me.onMenuBeforeShow, me);
    },

    /**
     * @private Handle showing of the grid's header menu. Sets up the filter item and menu
     * appropriate for the target column.
     */
    onMenuBeforeShow: function(menu) {
        var me = this,
            menuItem, filter;

        if (me.showMenu) {
            menuItem = me.menuItem;
            if (!menuItem || menuItem.isDestroyed) {
                me.createMenuItem(menu);
                menuItem = me.menuItem;
            }

            filter = me.getMenuFilter();

            if (filter) {
                menuItem.setMenu(filter.menu, false);
                menuItem.setChecked(filter.active);
                // disable the menu if filter.disabled explicitly set to true
                menuItem.setDisabled(filter.disabled === true);
            }
            menuItem.setVisible(!!filter);
            this.sep.setVisible(!!filter);
        }
    },


    createMenuItem: function(menu) {
        var me = this;
        me.sep  = menu.add('-');
        me.menuItem = menu.add({
            checked: false,
            itemId: 'filters',
            text: me.menuFilterText,
            listeners: {
                scope: me,
                checkchange: me.onCheckChange,
                beforecheckchange: me.onBeforeCheck
            }
        });
    },

    getGridPanel: function() {
        return this.view.up('gridpanel');
    },

    /**
     * @private
     * Handler for the grid's beforestaterestore event (fires before the state of the
     * grid is restored).
     * @param {Object} grid The grid object
     * @param {Object} state The hash of state values returned from the StateProvider.
     */
    applyState : function (grid, state) {
        var me = this,
            key, filter;
        me.applyingState = true;
        me.clearFilters();
        if (state.filters) {
            for (key in state.filters) {
                if (state.filters.hasOwnProperty(key)) {
                    filter = me.filters.get(key);
                    if (filter) {
                        filter.setValue(state.filters[key]);
                        filter.setActive(true);
                    }
                }
            }
        }
        me.deferredUpdate.cancel();
        if (me.local) {
            me.reload();
        }
        delete me.applyingState;
        delete state.filters;
    },

    /**
     * Saves the state of all active filters
     * @param {Object} grid
     * @param {Object} state
     * @return {Boolean}
     */
    saveState : function (grid, state) {
        var filters = {};
        this.filters.each(function (filter) {
            if (filter.active) {
                filters[filter.dataIndex] = filter.getValue();
            }
        });
        return (state.filters = filters);
    },

    /**
     * @private
     * Handler called by the grid 'beforedestroy' event
     */
    destroy : function () {
        var me = this;
        Ext.destroyMembers(me, 'menuItem', 'sep');
        me.removeAll();
        me.clearListeners();
    },

    /**
     * Remove all filters, permanently destroying them.
     */
    removeAll : function () {
        if(this.filters){
            Ext.destroy.apply(Ext, this.filters.items);
            // remove all items from the collection
            this.filters.clear();
        }
    },


    /**
     * Changes the data store bound to this view and refreshes it.
     * @param {Ext.data.Store} store The store to bind to this view
     */
    bindStore : function(store) {
        var me = this;

        // Unbind from the old Store
        if (me.store && me.storeListeners) {
            me.store.un(me.storeListeners);
        }

        // Set up correct listeners
        if (store) {
            me.storeListeners = {
                scope: me
            };
            if (me.local) {
                me.storeListeners.load = me.onLoad;
            } else {
                me.storeListeners['before' + (store.buffered ? 'prefetch' : 'load')] = me.onBeforeLoad;
            }
            store.on(me.storeListeners);
        } else {
            delete me.storeListeners;
        }
        me.store = store;
    },

    /**
     * @private
     * Get the filter menu from the filters MixedCollection based on the clicked header
     */
    getMenuFilter : function () {
        var header = this.view.headerCt.getMenu().activeHeader;
        return header ? this.filters.get(header.dataIndex) : null;
    },

    /** @private */
    onCheckChange : function (item, value) {
        this.getMenuFilter().setActive(value);
    },

    /** @private */
    onBeforeCheck : function (check, value) {
        return !value || this.getMenuFilter().isActivatable();
    },

    /**
     * @private
     * Handler for all events on filters.
     * @param {String} event Event name
     * @param {Object} filter Standard signature of the event before the event is fired
     */
    onStateChange : function (event, filter) {
        if (event !== 'serialize') {
            var me = this,
                grid = me.getGridPanel();

            if (filter == me.getMenuFilter()) {
                me.menuItem.setChecked(filter.active, false);
            }

            if ((me.autoReload || me.local) && !me.applyingState) {
                me.deferredUpdate.delay(me.updateBuffer);
            }
            me.updateColumnHeadings();

            if (!me.applyingState) {
                grid.saveState();
            }
            grid.fireEvent('filterupdate', me, filter);
        }
    },

    /**
     * @private
     * Handler for store's beforeload event when configured for remote filtering
     * @param {Object} store
     * @param {Object} options
     */
    onBeforeLoad : function (store, options) {
        options.params = options.params || {};
        this.cleanParams(options.params);
        var params = this.buildQuery(this.getFilterData());
        Ext.apply(options.params, params);
    },

    /**
     * @private
     * Handler for store's load event when configured for local filtering
     * @param {Object} store
     */
    onLoad : function (store) {
        store.filterBy(this.getRecordFilter());
    },

    /**
     * @private
     * Handler called when the grid's view is refreshed
     */
    onRefresh : function () {
        this.updateColumnHeadings();
    },

    /**
     * Update the styles for the header row based on the active filters
     */
    updateColumnHeadings : function () {
        var me = this,
            headerCt = me.view.headerCt;
        if (headerCt) {
            headerCt.items.each(function(header) {
                var filter = me.getFilter(header.dataIndex);
                header[filter && filter.active ? 'addCls' : 'removeCls'](me.filterCls);
            });
        }
    },

    /** @private */
    reload : function () {
        var me = this,
            store = me.view.getStore();

        if (me.local) {
            store.clearFilter(true);
            store.filterBy(me.getRecordFilter());
            store.sort();
        } else {
            me.deferredUpdate.cancel();
            if (store.buffered) {
                store.pageMap.clear();
            }
            store.loadPage(1);
        }
    },

    /**
     * Method factory that generates a record validator for the filters active at the time
     * of invokation.
     * @private
     */
    getRecordFilter : function () {
        var f = [], len, i;
        this.filters.each(function (filter) {
            if (filter.active) {
                f.push(filter);
            }
        });

        len = f.length;
        return function (record) {
            for (i = 0; i < len; i++) {
                if (!f[i].validateRecord(record)) {
                    return false;
                }
            }
            return true;
        };
    },

    /**
     * Adds a filter to the collection and observes it for state change.
     * @param {Object/NV.ext.ux.grid.filter.Filter} config A filter configuration or a filter object.
     * @return {NV.ext.ux.grid.filter.Filter} The existing or newly created filter object.
     */
    addFilter : function (config) {
        var me = this,
            columns = me.getGridPanel().columns,
            i, columnsLength, column, filtersLength, filter;

        
        for (i = 0, columnsLength = columns.length; i < columnsLength; i++) {
            column = columns[i];
            if (column.dataIndex === config.dataIndex) {
                column.filter = config;
            }
        }
        
        if (me.view.headerCt.menu) {
            me.createFilters();
        } else {
            // Call getMenu() to ensure the menu is created, and so, also are the filters. We cannot call
            // createFilters() withouth having a menu because it will cause in a recursion to applyState()
            // that ends up to clear all the filter values. This is likely to happen when we reorder a column
            // and then add a new filter before the menu is recreated.
            me.view.headerCt.getMenu();
        }
        
        for (i = 0, filtersLength = me.filters.items.length; i < filtersLength; i++) {
            filter = me.filters.items[i];
            if (filter.dataIndex === config.dataIndex) {
                return filter;
            }
        }
    },

    /**
     * Adds filters to the collection.
     * @param {Array} filters An Array of filter configuration objects.
     */
    addFilters : function (filters) {
        if (filters) {
            var me = this,
                i, filtersLength;
            for (i = 0, filtersLength = filters.length; i < filtersLength; i++) {
                me.addFilter(filters[i]);
            }
        }
    },

    /**
     * Returns a filter for the given dataIndex, if one exists.
     * @param {String} dataIndex The dataIndex of the desired filter object.
     * @return {NV.ext.ux.grid.filter.Filter}
     */
    getFilter : function (dataIndex) {
        return this.filters.get(dataIndex);
    },

    /**
     * Turns all filters off. This does not clear the configuration information
     * (see {@link #removeAll}).
     */
    clearFilters : function () {
        this.filters.each(function (filter) {
            filter.setActive(false);
        });
    },

    getFilterItems: function () {
        var me = this;

        // If there's a locked grid then we must get the filter items for each grid.
        if (me.lockingPartner) {
            return me.filters.items.concat(me.lockingPartner.filters.items);
        }

        return me.filters.items;
    },

    /**
     * Returns an Array of the currently active filters.
     * @return {Array} filters Array of the currently active filters.
     */
    getFilterData : function () {
        var items = this.getFilterItems(),
            filters = [],
            n, nlen, item, d, i, len;

        for (n = 0, nlen = items.length; n < nlen; n++) {
            item = items[n];
            if (item.active) {
                d = [].concat(item.serialize());
                for (i = 0, len = d.length; i < len; i++) {
                    filters.push({
                        field: item.dataIndex,
                        data: d[i]
                    });
                }
            }
        }
        return filters;
    },

    /**
     * Function to take the active filters data and build it into a query.
     * The format of the query depends on the {@link #encode} configuration:
     *
     *   - `false` (Default) :
     *     Flatten into query string of the form (assuming <code>{@link #paramPrefix}='filters'</code>:
     *
     *         filters[0][field]="someDataIndex"&
     *         filters[0][data][comparison]="someValue1"&
     *         filters[0][data][type]="someValue2"&
     *         filters[0][data][value]="someValue3"&
     *
     *
     *   - `true` :
     *     JSON encode the filter data
     *
     *         {filters:[{"field":"someDataIndex","comparison":"someValue1","type":"someValue2","value":"someValue3"}]}
     *
     * Override this method to customize the format of the filter query for remote requests.
     *
     * @param {Array} filters A collection of objects representing active filters and their configuration.
     * Each element will take the form of {field: dataIndex, data: filterConf}. dataIndex is not assured
     * to be unique as any one filter may be a composite of more basic filters for the same dataIndex.
     *
     * @return {Object} Query keys and values
     */
    buildQuery : function (filters) {
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;

        if (!this.encode){
            for (i = 0; i < len; i++) {
                f = filters[i];
                root = [this.paramPrefix, '[', i, ']'].join('');
                p[root + '[field]'] = f.field;

                dataPrefix = root + '[data]';
                for (key in f.data) {
                    p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
                }
            }
        } else {
            tmp = [];
            for (i = 0; i < len; i++) {
                f = filters[i];
                tmp.push(Ext.apply(
                    {},
                    {field: f.field},
                    f.data
                ));
            }
            // only build if there is active filter
            if (tmp.length > 0){
                p[this.paramPrefix] = Ext.JSON.encode(tmp);
            }
        }
        return p;
    },

    /**
     * Removes filter related query parameters from the provided object.
     * @param {Object} p Query parameters that may contain filter related fields.
     */
    cleanParams : function (p) {
        // if encoding just delete the property
        if (this.encode) {
            delete p[this.paramPrefix];
        // otherwise scrub the object of filter data
        } else {
            var regex, key;
            regex = new RegExp('^' + this.paramPrefix + '\[[0-9]+\]');
            for (key in p) {
                if (regex.test(key)) {
                    delete p[key];
                }
            }
        }
    },

    /**
     * Function for locating filter classes, overwrite this with your favorite
     * loader to provide dynamic filter loading.
     * @param {String} type The type of filter to load ('Filter' is automatically
     * appended to the passed type; eg, 'string' becomes 'StringFilter').
     * @return {Function} The NV.ext.ux.grid.filter.Class
     */
    getFilterClass : function (type) {
        // map the supported Ext.data.Field type values into a supported filter
        switch(type) {
            case 'auto':
              type = 'string';
              break;
            case 'int':
            case 'float':
              type = 'numeric';
              break;
            case 'bool':
              type = 'boolean';
              break;
        }
        return Ext.ClassManager.getByAlias('gridfilter.' + type);
    }
});

// @tag ext-ux
/**
 * Abstract base class for filter implementations.
 */
Ext.define('NV.ext.ux.grid.filter.Filter', {
    extend: 'Ext.util.Observable',

    /**
     * @cfg {Boolean} active
     * Indicates the initial status of the filter (defaults to false).
     */
    active : false,
    /**
     * True if this filter is active.  Use setActive() to alter after configuration.
     * @type Boolean
     * @property active
     */
    /**
     * @cfg {String} dataIndex
     * The {@link Ext.data.Store} dataIndex of the field this filter represents.
     * The dataIndex does not actually have to exist in the store.
     */
    dataIndex : null,
    /**
     * The filter configuration menu that will be installed into the filter submenu of a column menu.
     * @type Ext.menu.Menu
     * @property
     */
    menu : null,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to wait after user interaction to fire an update. Only supported
     * by filters: 'list', 'numeric', and 'string'. Defaults to 500.
     */
    updateBuffer : 500,

    constructor : function (config) {
        Ext.apply(this, config);

        this.addEvents(
            /**
             * @event activate
             * Fires when an inactive filter becomes active
             * @param {NV.ext.ux.grid.filter.Filter} this
             */
            'activate',
            /**
             * @event deactivate
             * Fires when an active filter becomes inactive
             * @param {NV.ext.ux.grid.filter.Filter} this
             */
            'deactivate',
            /**
             * @event serialize
             * Fires after the serialization process. Use this to attach additional parameters to serialization
             * data before it is encoded and sent to the server.
             * @param {Array/Object} data A map or collection of maps representing the current filter configuration.
             * @param {NV.ext.ux.grid.filter.Filter} filter The filter being serialized.
             */
            'serialize',
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {NV.ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
        NV.ext.ux.grid.filter.Filter.superclass.constructor.call(this);

        this.menu = this.createMenu(config);
        this.init(config);
        if(config && config.value){
            this.setValue(config.value);
            this.setActive(config.active !== false, true);
            delete config.value;
        }
    },

    /**
     * Destroys this filter by purging any event listeners, and removing any menus.
     */
    destroy : function(){
        if (this.menu){
            this.menu.destroy();
        }
        this.clearListeners();
    },

    /**
     * Template method to be implemented by all subclasses that is to
     * initialize the filter and install required menu items.
     * Defaults to Ext.emptyFn.
     */
    init : Ext.emptyFn,

    /**
     * @private @override
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        config.plain = true;
        return Ext.create('Ext.menu.Menu', config);
    },

    /**
     * Template method to be implemented by all subclasses that is to
     * get and return the value of the filter.
     * Defaults to Ext.emptyFn.
     * @return {Object} The 'serialized' form of this filter
     * @template
     */
    getValue : Ext.emptyFn,

    /**
     * Template method to be implemented by all subclasses that is to
     * set the value of the filter and fire the 'update' event.
     * Defaults to Ext.emptyFn.
     * @param {Object} data The value to set the filter
     * @template
     */
    setValue : Ext.emptyFn,

    /**
     * Template method to be implemented by all subclasses that is to
     * return <tt>true</tt> if the filter has enough configuration information to be activated.
     * Defaults to <tt>return true</tt>.
     * @return {Boolean}
     */
    isActivatable : function(){
        return true;
    },

    /**
     * Template method to be implemented by all subclasses that is to
     * get and return serialized filter data for transmission to the server.
     * Defaults to Ext.emptyFn.
     */
    getSerialArgs : Ext.emptyFn,

    /**
     * Template method to be implemented by all subclasses that is to
     * validates the provided Ext.data.Record against the filters configuration.
     * Defaults to <tt>return true</tt>.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function(){
        return true;
    },

    /**
     * Returns the serialized filter data for transmission to the server
     * and fires the 'serialize' event.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    serialize : function(){
        var args = this.getSerialArgs();
        this.fireEvent('serialize', args, this);
        return args;
    },

    /** @private */
    fireUpdate : function(){
        if (this.active) {
            this.fireEvent('update', this);
        }
        this.setActive(this.isActivatable());
    },

    /**
     * Sets the status of the filter and fires the appropriate events.
     * @param {Boolean} active        The new filter state.
     * @param {Boolean} suppressEvent True to prevent events from being fired.
     */
    setActive : function(active, suppressEvent){
        if(this.active != active){
            this.active = active;
            if (suppressEvent !== true) {
                this.fireEvent(active ? 'activate' : 'deactivate', this);
            }
        }
    }
});

// @tag ext-ux
/**
 * Boolean filters use unique radio group IDs (so you can have more than one!)
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
    ...
    filters: [{
        // required configs
        type: 'boolean',
        dataIndex: 'visible'

        // optional configs
        defaultValue: null, // leave unselected (false selected by default)
        yesText: 'Yes',     // default
        noText: 'No'        // default
    }]
});
 * </code></pre>
 */
Ext.define('NV.ext.ux.grid.filter.BooleanFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.boolean',

	/**
	 * @cfg {Boolean} defaultValue
	 * Set this to null if you do not want either option to be checked by default. Defaults to false.
	 */
	defaultValue : false,
	/**
	 * @cfg {String} yesText
	 * Defaults to 'Yes'.
	 */
	yesText : 'Yes',
	/**
	 * @cfg {String} noText
	 * Defaults to 'No'.
	 */
	noText : 'No',

    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        var gId = Ext.id();
		this.options = [
			Ext.create('Ext.menu.CheckItem', {text: this.yesText, group: gId, checked: this.defaultValue === true}),
			Ext.create('Ext.menu.CheckItem', {text: this.noText, group: gId, checked: this.defaultValue === false})];

		this.menu.add(this.options[0], this.options[1]);

		for(var i=0; i<this.options.length; i++){
			this.options[i].on('click', this.fireUpdate, this);
			this.options[i].on('checkchange', this.fireUpdate, this);
		}
	},

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
		return this.options[0].checked;
	},

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
	setValue : function (value) {
		this.options[value ? 0 : 1].setChecked(true);
	},

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
		var args = {type: 'boolean', value: this.getValue()};
		return args;
	},

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
		return record.get(this.dataIndex) == this.getValue();
	}
});

// @tag ext-ux
/**
 * Filter by a configurable Ext.picker.DatePicker menu
 *
 * Example Usage:
 *
 *     var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             // required configs
 *             type: 'date',
 *             dataIndex: 'dateAdded',
 *      
 *             // optional configs
 *             dateFormat: 'm/d/Y',  // default
 *             beforeText: 'Before', // default
 *             afterText: 'After',   // default
 *             onText: 'On',         // default
 *             pickerOpts: {
 *                 // any DatePicker configs
 *             },
 *      
 *             active: true // default is false
 *         }]
 *     });
 */
Ext.define('NV.ext.ux.grid.filter.DateFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.date',
    uses: ['Ext.picker.Date', 'Ext.menu.Menu'],

    /**
     * @cfg {String} afterText
     * Defaults to 'After'.
     */
    afterText : 'After',
    /**
     * @cfg {String} beforeText
     * Defaults to 'Before'.
     */
    beforeText : 'Before',
    /**
     * @cfg {Object} compareMap
     * Map for assigning the comparison values used in serialization.
     */
    compareMap : {
        before: 'lt',
        after:  'gt',
        on:     'eq'
    },
    /**
     * @cfg {String} dateFormat
     * The date format to return when using getValue.
     * Defaults to 'm/d/Y'.
     */
    dateFormat : 'm/d/Y',

    /**
     * @cfg {Date} maxDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Date} minDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu
     * Defaults to:<pre>
     * menuItems : ['before', 'after', '-', 'on'],
     * </pre>
     */
    menuItems : ['before', 'after', '-', 'on'],

    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     */
    menuItemCfgs : {
        selectOnFocus: true,
        width: 125
    },

    /**
     * @cfg {String} onText
     * Defaults to 'On'.
     */
    onText : 'On',

    /**
     * @cfg {Object} pickerOpts
     * Configuration options for the date picker associated with each field.
     */
    pickerOpts : {},

    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        var me = this,
            pickerCfg, i, len, item, cfg;

        pickerCfg = Ext.apply(me.pickerOpts, {
            xtype: 'datepicker',
            minDate: me.minDate,
            maxDate: me.maxDate,
            format:  me.dateFormat,
            listeners: {
                scope: me,
                select: me.onMenuSelect
            }
        });

        me.fields = {};
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                cfg = {
                    itemId: 'range-' + item,
                    text: me[item + 'Text'],
                    menu: Ext.create('Ext.menu.Menu', {
                        plain: true,
                        items: [
                            Ext.apply(pickerCfg, {
                                itemId: item,
                                listeners: {
                                    select: me.onPickerSelect,
                                    scope: me
                                }
                            })
                        ]
                    }),
                    listeners: {
                        scope: me,
                        checkchange: me.onCheckChange
                    }
                };
                item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
            }
            //me.add(item);
            me.menu.add(item);
        }
        me.values = {};
    },

    onCheckChange : function (item, checked) {
        var me = this,
            picker = item.menu.items.first(),
            itemId = picker.itemId,
            values = me.values;

        if (checked) {
            values[itemId] = picker.getValue();
        } else {
            delete values[itemId]
        }
        me.setActive(me.isActivatable());
        me.fireEvent('update', me);
    },

    /**
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide();
        }
    },

    /**
     * Handler for when the DatePicker for a field fires the 'select' event
     * @param {Ext.picker.Date} picker
     * @param {Object} date
     */
    onMenuSelect : function (picker, date) {
        var fields = this.fields,
            field = this.fields[picker.itemId];

        field.setChecked(true);

        if (field == fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field == fields.after && this.getFieldValue('before') < date) {
                fields.before.setChecked(false, true);
            } else if (field == fields.before && this.getFieldValue('after') > date) {
                fields.after.setChecked(false, true);
            }
        }
        this.fireEvent('update', this);

        picker.up('menu').hide();
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var key, result = {};
        for (key in this.fields) {
            if (this.fields[key].checked) {
                result[key] = this.getFieldValue(key);
            }
        }
        return result;
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     * @param {Boolean} preserve true to preserve the checked status
     * of the other fields.  Defaults to false, unchecking the
     * other fields
     */
    setValue : function (value, preserve) {
        var key;
        for (key in this.fields) {
            if(value[key]){
                this.getPicker(key).setValue(value[key]);
                this.fields[key].setChecked(true);
            } else if (!preserve) {
                this.fields[key].setChecked(false);
            }
        }
        this.fireEvent('update', this);
    },

    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var key;
        for (key in this.fields) {
            if (this.fields[key].checked) {
                return true;
            }
        }
        return false;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var args = [];
        for (var key in this.fields) {
            if(this.fields[key].checked){
                args.push({
                    type: 'date',
                    comparison: this.compareMap[key],
                    value: Ext.Date.format(this.getFieldValue(key), this.dateFormat)
                });
            }
        }
        return args;
    },

    /**
     * Get and return the date menu picker value
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Date} Gets the current selected value of the date field
     */
    getFieldValue : function(item){
        return this.values[item];
    },

    /**
     * Gets the menu picker associated with the passed field
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Object} The menu picker
     */
    getPicker : function(item){
        return this.fields[item].menu.items.first();
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var key,
            pickerValue,
            val = record.get(this.dataIndex),
            clearTime = Ext.Date.clearTime;

        if(!Ext.isDate(val)){
            return false;
        }
        val = clearTime(val, true).getTime();

        for (key in this.fields) {
            if (this.fields[key].checked) {
                pickerValue = clearTime(this.getFieldValue(key), true).getTime();
                if (key == 'before' && pickerValue <= val) {
                    return false;
                }
                if (key == 'after' && pickerValue >= val) {
                    return false;
                }
                if (key == 'on' && pickerValue != val) {
                    return false;
                }
            }
        }
        return true;
    },

    onPickerSelect: function(picker, date) {
        // keep track of the picker value separately because the menu gets destroyed
        // when columns order changes.  We return this value from getValue() instead
        // of picker.getValue()
        this.values[picker.itemId] = date;
        this.fireEvent('update', this);
    }
});

// @tag ext-ux
/**
 * Filter by a configurable Ext.picker.DatePicker menu
 *
 * This filter allows for the following configurations:
 *
 * - Any of the normal configs will be passed through to either component.
 * - There can be a docked config.
 * - The timepicker can be on the right or left (datepicker, too, of course).
 * - Choose which component will initiate the filtering, i.e., the event can be
 *   configured to be bound to either the datepicker or the timepicker, or if
 *   there is a docked config it be automatically have the handler bound to it.
 *
 * Although not shown here, this class accepts all configuration options
 * for {@link Ext.picker.Date} and {@link Ext.picker.Time}.
 *
 * In the case that a custom dockedItems config is passed in, the
 * class will handle binding the default listener to it so the
 * developer need not worry about having to do it.
 *
 * The default dockedItems position and the toolbar's
 * button text can be passed a config for convenience, i.e.,:
 *
 *     dock: {
 *        buttonText: 'Click to Filter',
 *        dock: 'left'
 *     }
 *
 * Or, pass in a full dockedItems config:
 *
 *     dock: {
 *        dockedItems: {
 *            xtype: 'toolbar',
 *            dock: 'bottom',
 *            ...
 *        }
 *     }
 *
 * Or, give a value of `true` to accept dock defaults:
 *
 *     dock: true
 *
 * But, it must be one or the other.
 *
 * Example Usage:
 *
 *     var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             // required configs
 *             type: 'datetime',
 *             dataIndex: 'date',
 *
 *             // optional configs
 *             positionDatepickerFirst: false,
 *             //selectDateToFilter: false, // this is overridden b/c of the presence of the dock cfg object
 *
 *             date: {
 *                 format: 'm/d/Y',
 *             },
 *
 *             time: {
 *                 format: 'H:i:s A',
 *                 increment: 1
 *             },
 *
 *             dock: {
 *                 buttonText: 'Click to Filter',
 *                 dock: 'left'
 *
 *                 // allows for custom dockedItems cfg
 *                 //dockedItems: {}
 *             }
 *         }]
 *     });
 *
 * In the above example, note that the filter is being passed a {@link #date} config object,
 * a {@link #time} config object and a {@link #dock} config. These are all optional.
 *
 * As for positioning, the datepicker will be on the right, the timepicker on the left
 * and the docked items will be docked on the left. In addition, since there's a {@link #dock}
 * config, clicking the button in the dock will trigger the filtering.
 */
Ext.define('NV.ext.ux.grid.filter.DateTimeFilter', {
    extend: 'NV.ext.ux.grid.filter.DateFilter',
    alias: 'gridfilter.datetime',

    /**
     * @private
     */
    dateDefaults: {
        xtype: 'datepicker',
        format: 'm/d/Y'
    },

    /**
     * @private
     */
    timeDefaults: {
        xtype: 'timepicker',
        width: 100,
        height: 200,
        format: 'g:i A'
    },

    /**
     * @private
     */
    dockDefaults: {
        dock: 'top',
        buttonText: 'Filter'
    },

    /**
     * @cfg {Object} date
     * A {@link Ext.picker.Date} can be configured here.
     * Uses {@link #dateDefaults} by default.
     */

    /**
     * @cfg {Object} time
     * A {@link Ext.picker.Time} can be configured here.
     * Uses {@link #timeDefaults} by default.
     */

    /**
     * @cfg {Boolean/Object} dock
     * A {@link Ext.panel.AbstractPanel#cfg-dockedItems} can be configured here.
     * A `true` value will use the {@link #dockDefaults} default configuration.
     * If present, the button in the docked items will initiate the filtering.
     */

    /**
     * @cfg {Boolean} [selectDateToFilter=true]
     * By default, the datepicker has the default event listener bound to it.
     * Setting to `false` will bind it to the timepicker.
     *
     * The config will be ignored if there is a `dock` config.
     */
    selectDateToFilter: true,

    /**
     * @cfg {Boolean} [positionDatepickerFirst=true]
     * Positions the datepicker within its container.
     * A `true` value will place it on the left in the container.
     * Set to `false` if the timepicker should be placed on the left.
     * Defaults to `true`.
     */
    positionDatepickerFirst: true,

    reTime: /\s(am|pm)/i,
    reItemId: /\w*-(\w*)$/,

    /**
     * Replaces the selected value of the timepicker with the default 00:00:00.
     * @private
     * @param {Object} date
     * @param {Ext.picker.Time} timepicker
     * @return Date object
     */
    addTimeSelection: function (date, timepicker) {
        var me = this,
            selection = timepicker.getSelectionModel().getSelection(),
            time, len, fn, val,
            i = 0,
            arr = [],
            timeFns = ['setHours', 'setMinutes', 'setSeconds', 'setMilliseconds'];


        if (selection.length) {
            time = selection[0].get('disp');

            // Loop through all of the splits and add the time values.
            arr = time.replace(me.reTime, '').split(':');

            for (len = arr.length; i < len; i++) {
                fn = timeFns[i];
                val = arr[i];

                if (val) {
                    date[fn](parseInt(val, 10));
                }
            }
        }

        return date;
    },

    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init: function (config) {
        var me = this,
            dateCfg = Ext.applyIf(me.date || {}, me.dateDefaults),
            timeCfg = Ext.applyIf(me.time || {}, me.timeDefaults),
            dockCfg = me.dock, // should not default to empty object
            defaultListeners = {
                click: {
                    scope: me,
                    click: me.onMenuSelect
                },
                select: {
                    scope: me,
                    select: me.onMenuSelect
                }
            },
            pickerCtnCfg, i, len, item, cfg,
            items = [dateCfg, timeCfg],

            // we need to know the datepicker's position in the items array
            // for when the itemId name is bound to it before adding to the menu
            datepickerPosition = 0;

        if (!me.positionDatepickerFirst) {
            items = items.reverse();
            datepickerPosition = 1;
        }

        pickerCtnCfg = Ext.apply(me.pickerOpts, {
            xtype: !dockCfg ? 'container' : 'panel',
            layout: 'hbox',
            items: items
        });

        // If there's no dock config then bind the default listener to the desired picker.
        if (!dockCfg) {
            if (me.selectDateToFilter) {
                dateCfg.listeners = defaultListeners.select;
            } else {
                timeCfg.listeners = defaultListeners.select;
            }
        } else if (dockCfg) {
            me.selectDateToFilter = null;

            if (dockCfg.dockedItems) {
                pickerCtnCfg.dockedItems = dockCfg.dockedItems;
                // TODO: allow config that will tell which item to bind the listener to
                // right now, it's using the first item
                pickerCtnCfg.dockedItems.items[dockCfg.bindToItem || 0].listeners = defaultListeners.click;
            } else {
                // dockCfg can be `true` if button text and dock position defaults are wanted
                if (Ext.isBoolean(dockCfg)) {
                    dockCfg = {};
                }
                dockCfg = Ext.applyIf(dockCfg, me.dockDefaults);
                pickerCtnCfg.dockedItems = {
                    xtype: 'toolbar',
                    dock: dockCfg.dock,
                    items: [
                        {
                            xtype: 'button',
                            text: dockCfg.buttonText,
                            flex: 1,
                            listeners: defaultListeners.click
                        }
                    ]   
                };
            }
        }

        me.fields = {};
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                pickerCtnCfg.items[datepickerPosition].itemId = item;

                cfg = {
                    itemId: 'range-' + item,
                    text: me[item + 'Text'],
                    menu: Ext.create('Ext.menu.Menu', {
                        items: pickerCtnCfg
                    }),
                    listeners: {
                        scope: me,
                        checkchange: me.onCheckChange
                    }
                };
                item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
            }
            me.menu.add(item);
        }
        me.values = {};
    },

    /**
     * @private
     */
    onCheckChange: function (item, checked) {
        var me = this,
            menu = item.menu,
            timepicker = menu.down('timepicker'),
            datepicker = menu.down('datepicker'),
            itemId = datepicker.itemId,
            values = me.values;

        if (checked) {
            values[itemId] = me.addTimeSelection(datepicker.value, timepicker);
        } else {
            delete values[itemId];
        }
        me.setActive(me.isActivatable());
        me.fireEvent('update', me);
    },

    /** 
     * Handler for when the DatePicker for a field fires the 'select' event
     * @param {Ext.picker.Date} picker
     * @param {Object} date
     */
    onMenuSelect: function (picker, date) {
        // NOTE: we need to redefine the picker.
        var me = this,
            menu = me.menu,
            checkItemId = menu.getFocusEl().itemId.replace(me.reItemId, '$1'),
            fields = me.fields,
            field;

        picker = menu.queryById(checkItemId);
        field = me.fields[picker.itemId];
        field.setChecked(true);

        if (field == fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field == fields.after && me.getFieldValue('before') < date) {
                fields.before.setChecked(false, true);
            } else if (field == fields.before && me.getFieldValue('after') > date) {
                fields.after.setChecked(false, true);
            }   
        }   
        me.fireEvent('update', me);

        // The timepicker's getBubbleTarget() returns the boundlist's implementation,
        // so it doesn't look up ownerCt chain (it looks up this.pickerField).
        // This is a problem :)
        // This can be fixed by just walking up the ownerCt chain
        // (same thing, but confusing without comment).
        picker.ownerCt.ownerCt.hide();
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs: function () {
        var me = this,
            key,
            fields = me.fields,
            args = [];

        for (key in fields) {
            if (fields[key].checked) {
                args.push({
                    type: 'datetime',
                    comparison: me.compareMap[key],
                    value: Ext.Date.format(me.getFieldValue(key), (me.date.format || me.dateDefaults.format) + ' ' + (me.time.format || me.timeDefaults.format))
                });
            }
        }
        return args;
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     * @param {Boolean} preserve true to preserve the checked status
     * of the other fields.  Defaults to false, unchecking the
     * other fields
     */
    setValue: function (value, preserve) {
        var me = this,
            fields = me.fields,
            key,
            val,
            datepicker;

        for (key in fields) {
            val = value[key];
            if (val) {
                datepicker = me.menu.down('datepicker[itemId="' + key + '"]');
                // Note that calling the Ext.picker.Date:setValue() calls Ext.Date.clearTime(),
                // which we don't want, so just call update() instead and set the value on the component.
                datepicker.update(val);
                datepicker.value = val;

                fields[key].setChecked(true);
            } else if (!preserve) {
                fields[key].setChecked(false);
            }
        }
        me.fireEvent('update', me);
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord: function (record) {
        // remove calls to Ext.Date.clearTime
        var me = this,
            key,
            pickerValue,
            val = record.get(me.dataIndex);

        if(!Ext.isDate(val)){
            return false;
        }

        val = val.getTime();

        for (key in me.fields) {
            if (me.fields[key].checked) {
                pickerValue = me.getFieldValue(key).getTime();
                if (key == 'before' && pickerValue <= val) {
                    return false;
                }
                if (key == 'after' && pickerValue >= val) {
                    return false;
                }
                if (key == 'on' && pickerValue != val) {
                    return false;
                }
            }
        }
        return true;
    }
});

// @tag ext-ux
/**
 * List filters are able to be preloaded/backed by an Ext.data.Store to load
 * their options the first time they are shown. ListFilter utilizes the
 * {@link NV.ext.ux.grid.menu.ListMenu} component.
 *
 * Although not shown here, this class accepts all configuration options
 * for {@link NV.ext.ux.grid.menu.ListMenu}.
 *
 * Example Usage:
 *
 *     var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             type: 'list',
 *             dataIndex: 'size',
 *             phpMode: true,
 *             // options will be used as data to implicitly creates an ArrayStore
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large']
 *         }]
 *     });
 *
 */
Ext.define('NV.ext.ux.grid.filter.ListFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.list',

    /**
     * @cfg {Array} options
     * `data` to be used to implicitly create a data store
     * to back this list when the data source is **local**. If the
     * data for the list is remote, use the {@link #store}
     * config instead.
     *
     * Each item within the provided array may be in one of the
     * following formats:
     *
     *   - **Array** :
     *
     *         options: [
     *             [11, 'extra small'],
     *             [18, 'small'],
     *             [22, 'medium'],
     *             [35, 'large'],
     *             [44, 'extra large']
     *         ]
     *
     *   - **Object** :
     *
     *         labelField: 'name', // override default of 'text'
     *         options: [
     *             {id: 11, name:'extra small'},
     *             {id: 18, name:'small'},
     *             {id: 22, name:'medium'},
     *             {id: 35, name:'large'},
     *             {id: 44, name:'extra large'}
     *         ]
     * 
     *   - **String** :
     *
     *         options: ['extra small', 'small', 'medium', 'large', 'extra large']
     *
     */
    /**
     * @cfg {Boolean} phpMode
     * Adjust the format of this filter. Defaults to false.
     *
     * When GridFilters `@cfg encode = false` (default):
     *
     *     // phpMode == false (default):
     *     filter[0][data][type] list
     *     filter[0][data][value] value1
     *     filter[0][data][value] value2
     *     filter[0][field] prod
     *
     *     // phpMode == true:
     *     filter[0][data][type] list
     *     filter[0][data][value] value1, value2
     *     filter[0][field] prod
     *
     * When GridFilters `@cfg encode = true`:
     *
     *     // phpMode == false (default):
     *     filter : [{"type":"list","value":["small","medium"],"field":"size"}]
     *
     *     // phpMode == true:
     *     filter : [{"type":"list","value":"small,medium","field":"size"}]
     *
     */
    phpMode : false,
    /**
     * @cfg {Ext.data.Store} store
     * The {@link Ext.data.Store} this list should use as its data source
     * when the data source is **remote**. If the data for the list
     * is local, use the {@link #options} config instead.
     */

    /**
     * @private
     * Template method that is to initialize the filter.
     * @param {Object} config
     */
    init : function (config) {
        this.dt = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },

    /**
     * @private @override
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        var menu = Ext.create('NV.ext.ux.grid.menu.ListMenu', config);
        menu.on('checkchange', this.onCheckChange, this);
        return menu;
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getSelected();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.menu.setSelected(value);
        this.fireEvent('update', this);
    },

    /**
     * Template method that is to return true if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.getValue().length > 0;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'list', value: this.phpMode ? this.getValue().join(',') : this.getValue()};
    },

    /** @private */
    onCheckChange : function(){
        this.dt.delay(this.updateBuffer);
    },


    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var valuesArray = this.getValue();
        return Ext.Array.indexOf(valuesArray, record.get(this.dataIndex)) > -1;
    }
});

// @tag ext-ux
/**
 * Filters using an NV.ext.ux.grid.menu.RangeMenu.
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
    ...
    filters: [{
        type: 'numeric',
        dataIndex: 'price'
    }]
});
 * </code></pre>
 * <p>Any of the configuration options for {@link NV.ext.ux.grid.menu.RangeMenu} can also be specified as
 * configurations to NumericFilter, and will be copied over to the internal menu instance automatically.</p>
 */
Ext.define('NV.ext.ux.grid.filter.NumericFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.numeric',
    uses: ['Ext.form.field.Number'],

    /**
     * @private @override
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        var me = this,
            menu;
        menu = Ext.create('NV.ext.ux.grid.menu.RangeMenu', config);
        menu.on('update', me.fireUpdate, me);
        return menu;
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getValue();
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.menu.setValue(value);
    },

    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var values = this.getValue(),
            key;
        for (key in values) {
            if (values[key] !== undefined) {
                return true;
            }
        }
        return false;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var key,
            args = [],
            values = this.menu.getValue();
        for (key in values) {
            args.push({
                type: 'numeric',
                comparison: key,
                value: values[key]
            });
        }
        return args;
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex),
            values = this.getValue(),
            isNumber = Ext.isNumber;
        if (isNumber(values.eq) && val != values.eq) {
            return false;
        }
        if (isNumber(values.lt) && val >= values.lt) {
            return false;
        }
        if (isNumber(values.gt) && val <= values.gt) {
            return false;
        }
        return true;
    }
});

// @tag ext-ux
/**
 * Filter by a configurable Ext.form.field.Text
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
    ...
    filters: [{
        // required configs
        type: 'string',
        dataIndex: 'name',

        // optional configs
        value: 'foo',
        active: true, // default is false
        iconCls: 'ux-gridfilter-text-icon' // default
        // any Ext.form.field.Text configs accepted
    }]
});
 * </code></pre>
 */
Ext.define('NV.ext.ux.grid.filter.StringFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.string',

    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125,

    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        Ext.applyIf(config, {
            enableKeyEvents: true,
            labelCls: 'ux-rangemenu-icon ' + this.iconCls,
            hideEmptyLabel: false,
            labelSeparator: '',
            labelWidth: 29,
            listeners: {
                scope: this,
                keyup: this.onInputKeyUp,
                el: {
                    click: function(e) {
                        e.stopPropagation();
                    }
                }
            }
        });

        this.inputItem = Ext.create('Ext.form.field.Text', config);
        this.menu.add(this.inputItem);
        this.menu.showSeparator = false;
        this.updateTask = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.inputItem.getValue();
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.inputItem.setValue(value);
        this.fireEvent('update', this);
    },

    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.inputItem.getValue().length > 0;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'string', value: this.getValue()};
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex);

        if(typeof val != 'string') {
            return (this.getValue().length === 0);
        }

        return val.toLowerCase().indexOf(this.getValue().toLowerCase()) > -1;
    },

    /**
     * @private
     * Handler method called when there is a keyup event on this.inputItem
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide();
            return;
        }
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

// @tag ext-ux
/**
 * This is a supporting class for {@link NV.ext.ux.grid.filter.ListFilter}.
 * Although not listed as configuration options for this class, this class
 * also accepts all configuration options from {@link NV.ext.ux.grid.filter.ListFilter}.
 */
Ext.define('NV.ext.ux.grid.menu.ListMenu', {
    extend: 'Ext.menu.Menu',
    
    /**
     * @cfg {String} idField
     * Defaults to 'id'.
     */
    idField :  'id',

    /**
     * @cfg {String} labelField
     * Defaults to 'text'.
     */
    labelField :  'text',
    /**
     * @cfg {String} paramPrefix
     * Defaults to 'Loading...'.
     */
    loadingText : 'Loading...',
    /**
     * @cfg {Boolean} loadOnShow
     * Defaults to true.
     */
    loadOnShow : true,
    /**
     * @cfg {Boolean} single
     * Specify true to group all items in this list into a single-select
     * radio button group. Defaults to false.
     */
    single : false,

    plain: true,

    constructor : function (cfg) {
        var me = this,
            options,
            i,
            len,
            value;
            
        me.selected = [];
        me.addEvents(
            /**
             * @event checkchange
             * Fires when there is a change in checked items from this list
             * @param {Object} item Ext.menu.CheckItem
             * @param {Object} checked The checked value that was set
             */
            'checkchange'
        );

        me.callParent([cfg = cfg || {}]);

        if(!cfg.store && cfg.options) {
            options = [];
            for(i = 0, len = cfg.options.length; i < len; i++){
                value = cfg.options[i];
                switch(Ext.type(value)){
                    case 'array':  options.push(value); break;
                    case 'object': options.push([value[me.idField], value[me.labelField]]); break;
                    case 'string': options.push([value, value]); break;
                }
            }

            me.store = Ext.create('Ext.data.ArrayStore', {
                fields: [me.idField, me.labelField],
                data:   options,
                listeners: {
                    load: me.onLoad,
                    scope:  me
                }
            });
            me.loaded = true;
            me.autoStore = true;
        } else {
            me.add({
                text: me.loadingText,
                iconCls: 'loading-indicator'
            });
            me.store.on('load', me.onLoad, me);
        }
    },

    destroy : function () {
        var me = this,
            store = me.store;
            
        if (store) {
            if (me.autoStore) {
                store.destroyStore();
            } else {
                store.un('unload', me.onLoad, me);
            }
        }
        me.callParent();
    },

    /**
     * Lists will initially show a 'loading' item while the data is retrieved from the store.
     * In some cases the loaded data will result in a list that goes off the screen to the
     * right (as placement calculations were done with the loading item). This adapter will
     * allow show to be called with no arguments to show with the previous arguments and
     * thus recalculate the width and potentially hang the menu from the left.
     */
    show : function () {
        var me = this;
        if (me.loadOnShow && !me.loaded && !me.store.loading) {
            me.store.load();
        }
        me.callParent();
    },

    /** @private */
    onLoad : function (store, records) {
        var me = this,
            gid, itemValue, i, len,
            listeners = {
                checkchange: me.checkChange,
                scope: me
            };

        Ext.suspendLayouts();
        me.removeAll(true);
        gid = me.single ? Ext.id() : null;
        for (i = 0, len = records.length; i < len; i++) {
            itemValue = records[i].get(me.idField);
            me.add(Ext.create('Ext.menu.CheckItem', {
                text: records[i].get(me.labelField),
                group: gid,
                checked: Ext.Array.contains(me.selected, itemValue),
                hideOnClick: false,
                value: itemValue,
                listeners: listeners
            }));
        }

        me.loaded = true;
        Ext.resumeLayouts(true);
        me.fireEvent('load', me, records);
    },

    /**
     * Get the selected items.
     * @return {Array} selected
     */
    getSelected : function () {
        return this.selected;
    },

    /** @private */
    setSelected : function (value) {
        value = this.selected = [].concat(value);

        if (this.loaded) {
            this.items.each(function(item){
                item.setChecked(false, true);
                for (var i = 0, len = value.length; i < len; i++) {
                    if (item.value == value[i]) {
                        item.setChecked(true, true);
                    }
                }
            });
        }
    },

    /**
     * Handler for the 'checkchange' event from an check item in this menu
     * @param {Object} item Ext.menu.CheckItem
     * @param {Object} checked The checked value that was set
     */
    checkChange : function (item, checked) {
        var value = [];
        this.items.each(function(item){
            if (item.checked) {
                value.push(item.value);
            }
        });
        this.selected = value;

        this.fireEvent('checkchange', item, checked);
    }
});

// @tag ext-ux
/**
 * Custom implementation of {@link Ext.menu.Menu} that has preconfigured items for entering numeric
 * range comparison values: less-than, greater-than, and equal-to. This is used internally
 * by {@link NV.ext.ux.grid.filter.NumericFilter} to create its menu.
 */
Ext.define('NV.ext.ux.grid.menu.RangeMenu', {
    extend: 'Ext.menu.Menu',

    /**
     * @cfg {String} fieldCls
     * The Class to use to construct each field item within this menu
     * Defaults to:<pre>
     * fieldCls : Ext.form.field.Number
     * </pre>
     */
    fieldCls : 'Ext.form.field.Number',

    /**
     * @cfg {Object} fieldCfg
     * The default configuration options for any field item unless superseded
     * by the <code>{@link #fields}</code> configuration.
     * Defaults to:<pre>
     * fieldCfg : {}
     * </pre>
     * Example usage:
     * <pre><code>
fieldCfg : {
    width: 150
},
     * </code></pre>
     */

    /**
     * @cfg {Object} fields
     * The field items may be configured individually
     * Defaults to <tt>undefined</tt>.
     * Example usage:
     * <pre><code>
fields : {
    gt: { // override fieldCfg options
        width: 200,
        fieldCls: NV.ext.ux.form.CustomNumberField // to override default {@link #fieldCls}
    }
},
     * </code></pre>
     */

    /**
     * @cfg {Object} itemIconCls
     * The itemIconCls to be applied to each comparator field item.
     * Defaults to:<pre>
itemIconCls : {
    gt : 'ux-rangemenu-gt',
    lt : 'ux-rangemenu-lt',
    eq : 'ux-rangemenu-eq'
}
     * </pre>
     */
    itemIconCls : {
        gt : 'ux-rangemenu-gt',
        lt : 'ux-rangemenu-lt',
        eq : 'ux-rangemenu-eq'
    },

    /**
     * @cfg {Object} fieldLabels
     * Accessible label text for each comparator field item. Can be overridden by localization
     * files. Defaults to:<pre>
fieldLabels : {
     gt: 'Greater Than',
     lt: 'Less Than',
     eq: 'Equal To'
}</pre>
     */
    fieldLabels: {
        gt: 'Greater Than',
        lt: 'Less Than',
        eq: 'Equal To'
    },

    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     * Defaults to:<pre>
menuItemCfgs : {
    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125
}
     * </pre>
     */
    menuItemCfgs : {
        emptyText: 'Enter Number...',
        selectOnFocus: false,
        width: 155
    },

    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu.  Items are added to the menu
     * according to their position within this array. Defaults to:<pre>
     * menuItems : ['lt','gt','-','eq']
     * </pre>
     */
    menuItems : ['lt', 'gt', '-', 'eq'],

    plain: true,

    constructor : function (config) {
        var me = this,
            fields, fieldCfg, i, len, item, cfg, Cls;

        me.callParent(arguments);

        fields = me.fields = me.fields || {};
        fieldCfg = me.fieldCfg = me.fieldCfg || {};
        
        me.addEvents(
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {NV.ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
      
        me.updateTask = Ext.create('Ext.util.DelayedTask', me.fireUpdate, me);
    
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                // defaults
                cfg = {
                    itemId: 'range-' + item,
                    enableKeyEvents: true,
                    hideEmptyLabel: false,
                    labelCls: 'ux-rangemenu-icon ' + me.itemIconCls[item],
                    labelSeparator: '',
                    labelWidth: 29,
                    listeners: {
                        scope: me,
                        change: me.onInputChange,
                        keyup: me.onInputKeyUp,
                        el: {
                            click: this.stopFn
                        }
                    },
                    activate: Ext.emptyFn,
                    deactivate: Ext.emptyFn
                };
                Ext.apply(
                    cfg,
                    // custom configs
                    Ext.applyIf(fields[item] || {}, fieldCfg[item]),
                    // configurable defaults
                    me.menuItemCfgs
                );
                Cls = cfg.fieldCls || me.fieldCls;
                item = fields[item] = Ext.create(Cls, cfg);
            }
            me.add(item);
        }
    },
    
    stopFn: function(e) {
        e.stopPropagation();
    },

    /**
     * @private
     * called by this.updateTask
     */
    fireUpdate : function () {
        this.fireEvent('update', this);
    },
    
    /**
     * Get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var result = {},
            fields = this.fields, 
            key, field;
            
        for (key in fields) {
            if (fields.hasOwnProperty(key)) {
                field = fields[key];
                if (field.isValid() && field.getValue() !== null) {
                    result[key] = field.getValue();
                }
            }
        }
        return result;
    },
  
    /**
     * Set the value of this menu and fires the 'update' event.
     * @param {Object} data The data to assign to this menu
     */	
    setValue : function (data) {
        var me = this,
            fields = me.fields,
            key,
            field;

        for (key in fields) {
            if (fields.hasOwnProperty(key)) {
                // Prevent field's change event from tiggering a Store filter. The final upate event will do that
                field =fields[key];
                field.suspendEvents();
                field.setValue(key in data ? data[key] : '');
                field.resumeEvents();
            }
        }

        // Trigger the filering of the Store
        me.fireEvent('update', me);
    },

    /**  
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp: function(field, e) {
        if (e.getKey() === e.RETURN && field.isValid()) {
            e.stopEvent();
            this.hide();
        }
    },

    /**
     * @private
     * Handler method called when the user changes the value of one of the input
     * items in this menu.
     */
    onInputChange: function(field) {
        var me = this,
            fields = me.fields,
            eq = fields.eq,
            gt = fields.gt,
            lt = fields.lt;

        if (field == eq) {
            if (gt) {
                gt.setValue(null);
            }
            if (lt) {
                lt.setValue(null);
            }
        }
        else {
            eq.setValue(null);
        }

        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

// @tag ext-ux
/**
 * This layout manager is used to center contents within a container. As a subclass of
 * {@link Ext.layout.container.Fit fit layout}, CenterLayout expects to have one child
 * item; multiple items will be placed overlapping. The layout does not require any config
 * options. Items in the container can use percentage width or height rather than be fit
 * to the full size of the container.
 *
 * Example usage:
 *
 *      // The content panel is centered in the container
 *
 *      var p = Ext.create('Ext.Panel', {
 *          title: 'Center Layout',
 *          layout: 'ux.center',
 *          items: [{
 *              title: 'Centered Content',
 *              width: '75%',  // assign 75% of the container width to the item
 *              html: 'Some content'
 *          }]
 *      });
 *
 * If you leave the title blank and specify no border you can create a non-visual, structural
 * container just for centering the contents.
 *
 *      var p = Ext.create('Ext.Container', {
 *          layout: 'ux.center',
 *          items: [{
 *              title: 'Centered Content',
 *              width: 300,
 *              height: '90%', // assign 90% of the container height to the item
 *              html: 'Some content'
 *          }]
 *      });
 */
Ext.define('NV.ext.ux.layout.Center', {
    extend: 'Ext.layout.container.Fit',
    alias: 'layout.ux.center',

    percentRe: /^\d+(?:\.\d+)?\%$/,

    itemCls: 'ux-layout-center-item',

    initLayout: function () {
        this.callParent(arguments);

        this.owner.addCls('ux-layout-center');
    },

    getItemSizePolicy: function (item) {
        var policy = this.callParent(arguments);
        if (typeof item.width == 'number') {
            policy = this.sizePolicies[policy.setsHeight ? 2 : 0];
        }
        return policy;
    },

    getPos: function (itemContext, info, dimension) {
        var size = itemContext.props[dimension] + info.margins[dimension],
            pos = Math.round((info.targetSize[dimension] - size) / 2);

        return Math.max(pos, 0);
    },

    getSize: function (item, info, dimension) {
        var ratio = item[dimension];

        if (typeof ratio == 'string' && this.percentRe.test(ratio)) {
            ratio = parseFloat(ratio) / 100;
        } else {
            ratio = item[dimension + 'Ratio']; // backwards compat
        }

        return info.targetSize[dimension] * (ratio || 1) - info.margins[dimension];
    },

    positionItemX: function (itemContext, info) {
        var left = this.getPos(itemContext, info, 'width');

        itemContext.setProp('x', left);
    },

    positionItemY: function (itemContext, info) {
        var top = this.getPos(itemContext, info, 'height');

        itemContext.setProp('y', top);
    },

    setItemHeight: function (itemContext, info) {
        var height = this.getSize(itemContext.target, info, 'height');

        itemContext.setHeight(height);
    },

    setItemWidth: function (itemContext, info) {
        var width = this.getSize(itemContext.target, info, 'width');

        itemContext.setWidth(width);
    }
});

// @tag ext-ux
Ext.define('NV.ext.ux.nv.GlobalErrorHandler', {
	alias:'globalErrorHandler',
	singleton:true,
	jsonResponseErrorHandler : function(response){
		var json = {};
		try{
			json = Ext.decode(response.responseText);
		}catch(e){
			
			if(response.responseText.toLowerCase().match("<html>") && response.responseText.toLowerCase().match("</html>")){	//302 eror, moved permanently -> reload a html page
				location.reload();
				return;
			}
			
			Ext.Msg.show({
			    title: 'Error',
			    msg: "Json parser error! Source url: "+response.request.options.url,
			    width: 300,
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
			return;
		}
		var errorMessage;
		if(json.error){
			errorMessage = json.error;
		}else if(json.ERROR){
			errorMessage = json.ERROR;
		}else if(json.Error){
			errorMessage = json.Error;
		}
		
		if(errorMessage){
			Ext.Msg.show({
			    title: 'Error',
			    msg: errorMessage,
			    width: 300,
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
			return;
		}
		
		return json;
	},

	requestFailedErrorHandler : function(response){
		Ext.Msg.show({
		    title: 'Error',
		    msg: "Request failed "+response.request.options.url,
		    width: 300,
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.ERROR
		});
		return;
	}
});

// @tag ext-ux

// TODO extjs kompatibilisen működésre bírni

// ezeket illeszti a calendar magába (lokalizáció)
day_name='Day';
week_name='Week';
month_name='Month';
year_name='Year';
MONTHS='Months';
YEARS='Years';
monthL=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
dayL=['M','T','W','T','F','S','S'];
allowed_future_years=0; // jövőbeli évek a mosthoz képest

Ext.define('NV.ext.ux.nv.calendar.CalendarField',{
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.calendar',
    
    type: undefined,
    
    initComponent: function()
    {
        this.calendar = undefined;
        
        Ext.apply(this, {
            
            html: '<div id='+this.id+'_from_to_calendar_div_static></div>' +
                  '<input type=hidden id='+this.id+'_from_to_date_type>' +
                  '<input type=hidden id='+this.id+'_from_to_FROM>' +
                  '<input type=hidden id='+this.id+'_from_to_TO>',
            listeners: {
                render: function () {
                    this.show();
                },
                scope: this
            }
        });
        
        this.callParent();
    },
    
    // get/set /////////////////////////////////////////////////////////////////////////////
    
    setType: function (t) { // D W M Y
        this.calendar.setType(t);
        this.type = t;
    },
    
    // a date || object.from + object.to
    setValue: function (v, t) { // set value - set value by date (interval contains that date, type (D, W, M, Y, false))
        
        console.log("v")
        console.log(v)  
            
        if (t) {
            this.setType(t);
        }
        
        if(v.from !== undefined) {
            this.calendar.setDay(v.from.getFullYear(), v.from.getMonth()+1, v.from.getDate(), true);
        }
        if(v.to !== undefined) {
            var key = {};
            key.altKey = true;
            this.calendar.setDay(v.to.getFullYear(), v.to.getMonth()+1, v.to.getDate(), true, key);
        }
        if(v.from === undefined) {
            this.calendar.setDay(v.getFullYear(), v.getMonth()+1, v.getDate(), true);
        }
        
    },
    
    getValue: function () { // retuns object of dates
        var strings = this.getValueStrings();
        
        var value = {};
        
        value.from = this.stringValueToDate(strings.from);
        value.to = this.stringValueToDate(strings.to);
        
        console.log(this.calendar)
        
        return value;
    },
    
    getValueTime: function () { // returns object of timestamp dates
        var dates = this.getValue();
        
        var value = {};
        
        value.from = dates.from.getTime();
        value.to = dates.to.getTime();
        
        return value;
    },
    
    getValueStrings: function () { // returns object of hidden imputs' string values
        var value = {};
        
        value.type = _getElementById(this.id+'_from_to_date_type').value;
        value.from = _getElementById(this.id+'_from_to_FROM').value;
        value.to = _getElementById(this.id+'_from_to_TO').value;
        
        return value;
    },
    
    // other /////////////////////////////////////////////////////////////////////////////
    
    show: function () {
        var today = new Date();
        
        // TODO nap/hét/hónap/év váltáskor látszólag bejelöli a pl. hetet, de a value nem változik
        
        show_from_to_calendar(''+this.id+'_from_to_');
        
        this.calendar = all_calendars[this.id+'_from_to_static'];
        this.calendar.setDay(today.getFullYear(),today.getMonth()+1,today.getDate(), true);
        if (this.type === undefined) {
            this.setType('D');
        }else{
            this.setType(this.type);
        }
    },
    
    stringValueToDate: function (str) { // returns date
        
        var datetimearray = str.split('. ');
        var d = datetimearray[0];
        var t = datetimearray[1];
        
        var datearray = d.split(".");
        var timearray = t.split(":");
        
        return new Date(datearray[0], (datearray[1]-1), datearray[2], timearray[0], timearray[1], timearray[2]);
    }
    

});

// @tag ext-ux
var day_name='';
var week_name='';
var month_name='';
var year_name='';
var monthL=new Array(12);
var dayL=new Array(7);
var MONTHS='';
var YEARS='';
var allowed_future_years=0;

var all_calendars={}; // tárolja a létrehozott calendarokat, id alapján lehet tőle elkérni

function _getElementById (id) {
	var obj=document.getElementById(id);
	if (obj==null) {
		obj=window.parent.document.getElementById(id);
	}
	return obj;
}

function get_value (obj) {
	if (obj!=null && obj!=undefined) {
		if (obj.type =='text' || obj.type=='textarea' || obj.type=='hidden' || obj.type == 'select-one' ) {
			return obj.value;
		} else if (obj.type == 'checkbox') {
			return obj.checked;
		} else {
			return obj.innerHTML;
		}
	}
	return undefined;
}

function parseInt2 (in_val) {
	var in_val2=in_val;
	//if (in_val==undefined) {
	//	('parseInt2');
	//}
	while (in_val2.length) {
		if (in_val2.charAt(0)!='0') {
			break;
		}
		in_val2=in_val2.substr(1);
	}
	if (in_val2=='') {
		return parseInt(in_val);
	}
	return parseInt(in_val2);
}

function set_value (obj,value) {
	var ret;
	if (obj!=null && obj!=undefined) {
		if (obj.type =='text' || obj.type=='textarea' || obj.type=='hidden' ) {
			obj.value=value;
			if (obj.type == 'hidden') {
				for (var choise=0;;choise++) {
					var tmp=_getElementById(obj.id+'_choise'+choise);
					if (tmp==null) break;
					if (tmp.value==value) {
						tmp.checked=true;
					} else {
						tmp.checked=false;
					}
				}
			}
		} else if (obj.type == 'select-one') {
			for (var s=0;s<obj.options.length;s++) {
				if (obj.options[s].value==value) {
					obj.selectedIndex=s;
					break;
				}
			}
		} else if (obj.type == 'checkbox') {
			if (value=='false') {
				obj.checked=false;
			} else if (value=='true') {
				obj.checked=true;
			} else if (value) {
				obj.checked=true;
			} else {
				obj.checked=false;
			}
		} else if (obj.type == 'radio') {
        } else {
			obj.innerHTML=value;
		}
	}
	return ret;
}

function day2str(date,day_diff) {
	var year=date.getFullYear();
	var month=date.getMonth()+1;
	var day=date.getDate();

	if (day_diff!=0 && day_diff!=undefined) {
		day+=day_diff;
		var tmpDate = new Date(year,month, 0);
		if (day>tmpDate.getDate()) {
			month++;
			if (month>12) {
				month=1;
				year++;
			}
			day=day-tmpDate.getDate();
		}
	}

	var datestr=year+'.';

	if (month<10) {
		datestr+='0';
	}
	datestr+=month+'.';

	if (day<10) {
		datestr+='0';
	}
	datestr+=day+'.';

	return datestr;
}

function Calendar (id_pre,div_id,onclick_func,date_type,year,month,day,show_set_type) { // calendar létrehozása
	var now=new Date();
	
	if (year==undefined || month==undefined || day==undefined || year=='' || month=='' || day=='') {
		day=now.getDate();
		year=now.getFullYear();
		month=now.getMonth()+1;
	}

	var max_date=now;
	if (allowed_future_years>0) {
		max_date.setFullYear(max_date.getFullYear()+1);
		max_date.setMonth(11);
		max_date.setDate(31);
	}
	this.maxDay=max_date.valueOf();
	this.maxYear=max_date.getFullYear();
	this.maxMonth=max_date.getMonth()+1;
	
	year=parseInt2(year);
	month=parseInt2(month);
	day=parseInt2(day);
	var year_str=''+year;
	var month_str=''+month;
	var day_str=''+day;

	var input_ok=1;
	
	if (date_type=='' || date_type==undefined) {
		input_ok=0;
	}
	if (isNaN(year) || isNaN(month) || isNaN(day)) {
		input_ok=0;
	} else if (year_str.indexOf('.')>=0 || month_str.indexOf('.')>=0 || day_str.indexOf('.')>=0) {
		input_ok=0;
	} else if (year<2000) {
		input_ok=0;
	} else if (month<1) {
		input_ok=0;
	} else if (day<1) {
		input_ok=0;
	} else if (year > this.maxYear) {
		input_ok=0;
	} else if (year==this.maxYear && month > this.maxMonth) {
		input_ok=0;
	} else if (year==this.maxYear && month == this.maxMonth && day>this.maxDay) {
		input_ok=0;
	} else {
		var tmpDate = new Date(year,month, 0);
		if (day>tmpDate.getDate()) {
			input_ok=0;
		}
	}
	
	if (!input_ok) {
		date_type='D';
		var tmp=new Date();
		year=tmp.getFullYear();
		month=tmp.getMonth()+1;
		day=tmp.getDate();
	}
	
	this.id_pre=id_pre; // adatok
	this.div_id=div_id;
	this.onclick_func=onclick_func;
	this.show_set_type=show_set_type;
	
	this.sel_date_type=date_type;
	this.sel_year=year;
	this.sel_month=month;
	this.sel_day=day;
	
	this.disp_date_type=date_type;
	this.disp_year=year;
	this.disp_month=month;
	
	all_calendars[id_pre]=this; // calendar gyűjtőbe
}

function Calendar_setDay(YEAR,MONTH,DAY,do_onclick, key) { // dárum átállítása
	var year=parseInt2(YEAR);
	var month=parseInt2(MONTH);
	var day=parseInt2(DAY);
	if (do_onclick==undefined) {
		do_onclick=1;
	}

	if (this.onclick_func!=undefined && this.onclick_func!='' && do_onclick==1) {
		if ((this.onclick_func.indexOf('threshold_page_area')>=0) || (this.onclick_func.indexOf('measurement_page_area')>=0)) {
			if (realtime_flash_leave_warning(1)) {
				return;
			}
		}
	}

	this.sel_date_type=this.disp_date_type;

	var tmp=new Date(year,month-1,day);
	if (this.sel_date_type=='W') {
		var day_diff=0;
		if (tmp.getDay()==0) {
			day_diff=6;
		} else if (tmp.getDay()==1) {
		} else {
			day_diff=tmp.getDay()-1;
		}
		if (day_diff!=0) {
			//('1 '+year+' '+month+' '+day);
			day-=day_diff;
			if (day<1) {
				month--;
				if (month<1) {
					month=12;
					year--;
				}
				var dPrevDate = new Date(year,month, 0);
				day=dPrevDate.getDate()+day;
				//('2 '+year+' '+month+' '+day);
			}
		}
	} else if (this.sel_date_type=='M') {
		day=1;
	} else if (this.sel_date_type=='Y') {
		day=1;
		month=1;
	}

	//('Sel '+year+' '+month+' '+day);

	this.sel_year=year;
	this.sel_month=month;
	this.sel_day=day;
	
	if (this.sel_date_type=='M' || this.sel_date_type=='Y') {
		var year_select=_getElementById(this.id_pre+'year_select');
		var month_select=_getElementById(this.id_pre+'month_select');
		this.disp_month=this.sel_month;
		if (this.sel_date_type=='Y') {
			this.disp_year=this.sel_year;
		}
		set_value(year_select,this.sel_year);
		set_value(month_select,this.sel_month);
	}
	
	this.show(key);

	if (this.onclick_func!=undefined && this.onclick_func!='' && do_onclick==1) {
		eval(this.onclick_func);
	}
}
function Cal_setDay(id_pre,year,month,day,e) {
    console.log(e) // TODO select day (maybe month etc) by custom by ctrl/shift/alt | bools: e.altKey e.shiftKey  e.ctrlKey
    
    if (e.altKey || e.shiftKey || e.ctrlKey) {
        all_calendars[id_pre].setDay(year,month,day, false, true);
    } else {
	    all_calendars[id_pre].setDay(year,month,day);
    }
}

function Calendar_setType(date_type) {
    //set type (day/week/month/year) + from-to date in hidden inputs
    var day = this.sel_day;
    var month = this.sel_month;
    var year = this.sel_year;
	this.disp_date_type=date_type;
	this.show();
	this.setDay(year, month, day, true);
}
function Cal_setType(id_pre,date_type) {
	all_calendars[id_pre].setType(date_type);
}

function Calendar_addMonth (diff) {
	var orig_year=this.disp_year;
	var orig_month=this.disp_month;
	
	//('orig_year='+orig_year+' orig_month='+orig_month);
	
	this.disp_month+=diff;
	if (this.disp_month<1) {
		this.disp_month=12;
		this.disp_year-=1;
	} else if (this.disp_month>12) {
		this.disp_month=1;
		this.disp_year+=1;
	}

	//('disp_year='+this.disp_year+' disp_month='+this.disp_month);
	
	if (this.disp_year>this.maxYear || (this.disp_year==this.maxYear && this.disp_month>this.maxMonth)) {
		//too big
		this.disp_year=orig_year;
		this.disp_month=orig_month;
		return;
	} else if (this.disp_year<2000) {
		//too small
		this.disp_year=orig_year;
		this.disp_month=orig_month;
		return;
	}
	
	var year_select=_getElementById(this.id_pre+'year_select');
	var month_select=_getElementById(this.id_pre+'month_select');
	set_value(year_select,this.disp_year);
	set_value(month_select,this.disp_month);
	
	//('year_select='+get_value(year_select)+' month_select='+get_value(month_select));
	
	this.show();
}
function Cal_addMonth(id_pre,diff) {
	all_calendars[id_pre].addMonth(diff);
}

function Calendar_setMonthYear () {
	var year_select=_getElementById(this.id_pre+'year_select');
	var month_select=_getElementById(this.id_pre+'month_select');
	
	this.disp_year=parseInt2(get_value(year_select));
	this.disp_month=parseInt2(get_value(month_select));
	
	this.show();
}
function Cal_setMonthYear(id_pre) {
	all_calendars[id_pre].setMonthYear();
}

function Calendar_printDay (year,month,i,d) {
	var tmp=new Date(year,month-1,i);
	var tmp2=tmp.valueOf();
	//('printDay: '+year+','+month+','+i+','+d+': tmp2='+tmp2+' preDay='+this.preDay+' postDay='+this.postDay);
	var txt='<td class=';
	if (tmp2>this.maxDay) {
		if (d<=5) {
			txt+='calendar_days>';
		} else {
			txt+='calendar_weekend>';
		}
	} else if (tmp2>=this.preDay && tmp2<=this.postDay) {
		if (d<=5) txt+='calendar_curr_day style="cursor:pointer;" onclick="Cal_setDay(\''+this.id_pre+'\','+year+','+month+','+i+', event)">';
		else txt+='calendar_curr_weekend style="cursor:pointer;" onclick="Cal_setDay(\''+this.id_pre+'\','+year+','+month+','+i+', event)">';
	} else if (d<=5) {
		txt+='calendar_days style="cursor:pointer;" onclick="Cal_setDay(\''+this.id_pre+'\','+year+','+month+','+i+', event)">';
	} else {
		txt+='calendar_weekend style="cursor:pointer;" onclick="Cal_setDay(\''+this.id_pre+'\','+year+','+month+','+i+', event)">';
	}
	txt+=i+'</td>';
	return txt;
}

function Calendar_printDay2 (year,month,i,d) {
	var tmp=new Date(year,month-1,i);
	var tmp2=tmp.valueOf();
	var txt='<td class=';
	if (tmp2>=this.preDay && tmp2<=this.postDay) {
		if (d<=5) txt+='calendar_curr_day_om>';
		else txt+='calendar_curr_weekend_om>';
	} else {
		if (d<=5) {
			txt+='calendar_days_om>';
		} else {
			txt+='calendar_weekend_om>';
		}
	}
	txt+=i+'</td>';
	return txt;
}

function Calendar_show (key) { // felépíti a calendar látható részét
	var tmp=new Date(this.sel_year,this.sel_month-1,this.sel_day);
	var tmp2=tmp.getDay();
	if (tmp2==0) tmp2=7;
	if (this.disp_date_type=='D' || this.disp_date_type=='M') {
	    if (key) {
	        if (tmp.valueOf() < this.preDay){
	            this.postDay = this.preDay;
	            this.preDay = tmp.valueOf();
	        } else {
	            this.postDay = tmp.valueOf();
	        }
	    } else {
    		this.preDay = tmp.valueOf();
    		this.postDay = tmp.valueOf();
	    }
	} else if (this.disp_date_type=='W') {
		var now=new Date();
		this.maxDay=now.valueOf();
		this.preDay=tmp.valueOf()-(tmp2-1)*86400*1000;
		this.postDay=tmp.valueOf()+(7-tmp2)*86400*1000;
		this.maxDay+=(7-tmp2)*86400*1000;
	}

	var txt='';

	//txt+='<center>';
	txt+='<table border=0 cellspacing=0 cellpadding=0 class=calendar_pre_table><tr>';
	txt+='<td class=calendar_prev onclick="Cal_addMonth(\''+this.id_pre+'\',-1)"></td>';
	txt+='<td class=calendar_select_year><select id='+this.id_pre+'year_select onchange="Cal_setMonthYear(\''+this.id_pre+'\')">';
	for (var i=2000;i<=this.maxYear;i++) {
		txt+='<option value='+i+' ';
		if (i==this.disp_year) {
			txt+='selected';
		}
		txt+='>'+i+'</option>';
	}
	txt+='</select></td>';
	txt+='<td class=calendar_select_month>';
	txt+='<select id='+this.id_pre+'month_select onchange="Cal_setMonthYear(\''+this.id_pre+'\')">';
	for (var i=1;i<=12;i++) {
		if (this.disp_year==this.maxYear && i>this.maxMonth) {
			break;
		}
		txt+='<option value='+i+' ';
		if (i==this.disp_month) {
			txt+='selected';
		}
		txt+='>'+monthL[i-1]+'</option>';
	}
	txt+='</select>'
	txt+='</td>';
	txt+='<td class=calendar_next onclick="Cal_addMonth(\''+this.id_pre+'\',1)"></td>';
	txt+='</tr></table>';
	
	txt+='<table class=calendar_table cellpadding=0 cellspacing=0>';
	
	if (this.disp_date_type=='D' || this.disp_date_type=='W')
	
	{
		txt+='<tr>';
		for (var i=0;i<7;i++) {
			txt+='<td class=calendar_daynames>'+dayL[i]+'</td>';
		}
		txt+='</tr>';
		
		var dCalDate = new Date(this.disp_year,this.disp_month-1, 1);
		var iDayOfFirst = dCalDate.getDay();
		var dPrevDate = new Date(this.disp_year,this.disp_month, 0);
		var iDaysInMonth=dPrevDate.getDate();
		var i = 1;
		var date2=new Date(this.disp_year,this.disp_month-1,0);
		var lastPrevDate=date2.getDate();

		var curDate=new Date();
		var curYear=curDate.getFullYear();

		var d;
		txt+='<tr>';
		var w=1;
		if (iDayOfFirst==0) iDayOfFirst=7;
		lastPrevDate-=iDayOfFirst-2;
		for (d=1;d<iDayOfFirst;d++) {
			txt+=this.printDay2(this.disp_year,this.disp_month-1,lastPrevDate,d)
			lastPrevDate++;
		}
		for (d = iDayOfFirst; d <= 7; d++) {
			txt+=this.printDay(this.disp_year,this.disp_month,i,d)
			i++;
		}
		while (i<=iDaysInMonth) {
			if (d==8) d=1;
			if (d==1) {
				txt+='</tr><tr>';
				w++;
			}
			txt+=this.printDay(this.disp_year,this.disp_month,i,d);
			i++;
			d++;
		}
		for (i=1;d<8;d++) {
			txt+=this.printDay2(this.disp_year,this.disp_month+1,i,d);
			i++;
		}
		txt+='</tr>';
		while (w<6) {
			txt+='<tr>';
			for (d=1;d<8;d++) {
				txt+=this.printDay2(this.disp_year,this.disp_month+1,i,d);
				i++;
			}
			txt+='</tr>';
			w++;
		}
	}
	
	else if (this.disp_date_type=='M')
	
	{
	    if (key) {
	       var firstMonth = (new Date(this.preDay)).getMonth() + 1;
	       var lastMonth = (new Date(this.postDay)).getMonth() + 1;
	    }
	    
		txt+='<tr>';
		txt+='<td class=calendar_year_month_head colspan=2>'+MONTHS+':</td>';
		txt+='</tr>';
		for (var i=1;i<=6;i++) {
			txt+='<tr>';
			txt+='<td class=';
			
			if (!key && this.sel_month == i && this.sel_year==this.disp_year) txt+='calendar_curr_month';
			else if (key && this.sel_year==this.disp_year) {
			    if (firstMonth <= i && lastMonth >= i)  txt+='calendar_curr_month'; 
			    else if (firstMonth <= i){
			        if (lastMonth < i){
			             txt+='calendar_month';
			         } else {
			             txt+='calendar_curr_month';
			         }
			    }
			    else txt+='calendar_month';
			}
			else txt+='calendar_month';
			
			txt+='><span';
			if (this.disp_year<this.maxYear || (this.disp_year==this.maxYear && i<=this.maxMonth)) {
				txt+=' onclick="Cal_setDay(\''+this.id_pre+'\','+this.disp_year+','+i+','+1+', event)" style="cursor: pointer;"';
			}
			txt+='>'+monthL[i-1]+'</span></td>';

			var j=i+6;

			txt+='<td class=';
			
			if (!key && this.sel_month == j && this.sel_year==this.disp_year) txt+='calendar_curr_month';
			else if (key &&  this.sel_year==this.disp_year){
                if (firstMonth <= j && lastMonth >= j) txt+='calendar_curr_month';
                else if (lastMonth >= j){
                    if (firstMonth > j){
                         txt+='calendar_month';
                     } else {
                         txt+='calendar_curr_month';
                     }
                }
                else txt+='calendar_month';
			}
    		else txt+='calendar_month';
			
			txt+='><span';
			if (this.disp_year<this.maxYear || (this.disp_year==this.maxYear && j<=this.maxMonth)) {
				txt+=' onclick="Cal_setDay(\''+this.id_pre+'\','+this.disp_year+','+j+','+1+', event)" style="cursor: pointer;"';
			}
			txt+='>'+monthL[j-1]+'</span></td>';

			txt+='</tr>';
		}
	}
	
	else if (this.disp_date_type=='Y')
	
	{
		txt+='<tr>';
		txt+='<td class=calendar_year_month_head colspan=2>'+YEARS+':</td>';
		txt+='</tr>';
		var tol=this.disp_year-5;
		if (tol<2000) tol=2000;
		var i;
		for (i=tol;i<tol+6;i++) {
			txt+='<tr>';

			txt+='<td class=';
			if (this.sel_year==i) txt+='calendar_curr_month';
			else txt+='calendar_month';
			txt+='><span'
			if (i<=this.maxYear) txt+=' onclick="Cal_setDay(\''+this.id_pre+'\','+i+','+1+','+1+', event)" style="cursor: pointer;"';
			txt+='>'+i+'</span></td>';

			var j=i+6;

			txt+='<td class=';
			if (this.sel_year==j) txt+='calendar_curr_month';
			else txt+='calendar_month';
			txt+='><span'
			if (j<=this.maxYear) txt+=' onclick="Cal_setDay(\''+this.id_pre+'\','+j+','+1+','+1+', event)" style="cursor: pointer;"';
			txt+='>'+j+'</span></td>';

			txt+='</tr>';
		}
	}

	txt+='<tr></table>';
	
	if (this.show_set_type==1) {
		txt+='<table border=0 cellspacing=0 cellpadding=0 class=calendar_post_table><tr>';
		txt+='<td class=calendar_type><span onclick="Cal_setType(\''+this.id_pre+'\',\'D\')">'+day_name+'</span></td>'
		txt+='<td class=calendar_type><span onclick="Cal_setType(\''+this.id_pre+'\',\'W\')">'+week_name+'</span></td>'
		txt+='<td class=calendar_type><span onclick="Cal_setType(\''+this.id_pre+'\',\'M\')">'+month_name+'</span></td>'
		txt+='<td class=calendar_type><span onclick="Cal_setType(\''+this.id_pre+'\',\'Y\')">'+year_name+'</span></td>'
		txt+='</tr></table>';
	}

	set_value(_getElementById(this.div_id),txt);
	
	_getElementById(this.div_id).style.visibility='visible';
	
	if (key) {
	   
	   var pre = this.id_pre.replace("static",""); 
	   var pst = new Date(this.postDay);
	   if (this.disp_date_type=='M') {
	       var pst = new Date(this.disp_year,new Date(this.postDay).getMonth()+1,0);
	   }
	   set_value(_getElementById(pre+'FROM'),day2str(new Date(this.preDay))+' 00:00:00');
	   set_value(_getElementById(pre+'TO'),day2str(pst,1)+' 00:00:00');
	}
}

Calendar.prototype.setDay=Calendar_setDay; // calendar függvényei
Calendar.prototype.setType=Calendar_setType;
Calendar.prototype.printDay=Calendar_printDay;
Calendar.prototype.printDay2=Calendar_printDay2;
Calendar.prototype.show=Calendar_show;
Calendar.prototype.addMonth=Calendar_addMonth;
Calendar.prototype.setMonthYear=Calendar_setMonthYear;


function show_from_to_calendar_cb (pre) {
	var cal=all_calendars[pre+'static'];
	set_value(_getElementById(pre+'FROM'),day2str(new Date(cal.sel_year,cal.sel_month-1,cal.sel_day))+' 00:00:00');
	if (cal.sel_date_type=='D') {
		set_value(_getElementById(pre+'TO'),day2str(new Date(cal.sel_year,cal.sel_month-1,cal.sel_day),1)+' 00:00:00');
	} else if (cal.sel_date_type=='W') {
		set_value(_getElementById(pre+'TO'),day2str(new Date(cal.sel_year,cal.sel_month-1,cal.sel_day),7)+' 00:00:00');
	} else if (cal.sel_date_type=='M') {
		var year=cal.sel_year;
		var month=cal.sel_month;
		month++;
		if (month>12) {
			month=1;
			year++;
		}
		set_value(_getElementById(pre+'TO'),day2str(new Date(year,month-1,1))+' 00:00:00');
	} else if (cal.sel_date_type=='Y') {
		set_value(_getElementById(pre+'TO'),day2str(new Date(cal.sel_year+1,0,1))+' 00:00:00');
	}
	set_value(_getElementById(pre+'date_type'),cal.sel_date_type);
}
function show_from_to_calendar (pre,call_back) { // from-to típusú calendar létrehozása (div id elejének megadása, egyéb esemény)
	var date=get_value(_getElementById(pre+'FROM'));
	var year,month,day;
	if (date.length>=11) {
		year=date.substr(0,4);
		month=date.substr(5,2);
		day=date.substr(8,2);
	}
	var cal;
	if (pre in all_calendars) {
		cal=all_calendars[pre+'static'];
		cal.setDay(year,month,day,0);
	} else {
		var date_type=get_value(_getElementById(pre+'date_type'));
		//(pre+'date_type: '+date_type);
		if (date_type==undefined || date_type=='') {
			date_type='D';
		}
		cal=new Calendar(pre+'static',pre+'calendar_div_static',"show_from_to_calendar_cb('"+pre+"');"+call_back,date_type,year,month,day,1);
		cal.show();
	}
}
function show_report_calendar_cb (pre) {
	var cal=all_calendars[pre];
	set_value(_getElementById(pre+'date_type'),cal.sel_date_type);
	set_value(_getElementById(pre+'year'),cal.sel_year);
	set_value(_getElementById(pre+'month'),cal.sel_month);
	set_value(_getElementById(pre+'day'),cal.sel_day);
}
function show_report_calendar (pre,call_back) {
	var date_type=get_value(_getElementById(pre+'date_type'));
	var year=get_value(_getElementById(pre+'year'));
	var month=get_value(_getElementById(pre+'month'));
	var day=get_value(_getElementById(pre+'day'));

	var cal;
	if (pre in all_calendars) {
		cal=all_calendars[pre];
		cal.setDay(year,month,day,0);
	} else {
		cal=new Calendar(pre,pre+'calendar_div_static',"show_report_calendar_cb('"+pre+"');"+call_back,date_type,year,month,day,1);
		cal.show();
	}
}

function popup_calendar_cb (pre,calendar_div_id) {
	_getElementById(calendar_div_id).style.visibility='hidden';
	delete(all_calendars[pre]);
}

function popup_calendar_icon_onclick (e,obj,call_back) {
	var X=0,Y=0;
	var tmp_obj = obj;
	var calendar_div_id=obj.id+'_calendar_div_static';
	while (tmp_obj!=null) {
		X += tmp_obj.offsetLeft-tmp_obj.scrollLeft;
		Y += tmp_obj.offsetTop-tmp_obj.scrollTop;
		tmp_obj = tmp_obj.offsetParent;
	}
	//(X+','+Y);
	_getElementById(calendar_div_id).style.top=Y+'px';
	_getElementById(calendar_div_id).style.left=X+'px';
	
	show_from_to_calendar(obj.id+'_',"popup_calendar_cb('"+obj.id+"_','"+calendar_div_id+"');"+call_back);

	X=X+18-parseInt(_getElementById(calendar_div_id).offsetWidth);
	_getElementById(calendar_div_id).style.left=X+'px';
}

var calendar_div_st=undefined;
function popup_calendar_div_out (e,obj) {
	var X,Y;
	if (navigator.appName == 'Netscape') {
		X=e.pageX;
		Y=e.pageY;
	} else {
		X=window.event.clientX+document.body.scrollLeft;
		Y=window.event.clientY+document.body.scrollTop;
	}
	if ((X<obj.offsetLeft || X>obj.offsetLeft+obj.offsetWidth
	 || Y<obj.offsetTop || Y>obj.offsetTop+obj.offsetHeight)
	&& Y>200) {
		calendar_div_st=setTimeout("_getElementById('"+obj.id+"').style.visibility='hidden'",50);
	}
}

function popup_calendar_div_move (e,obj) {
	if (calendar_div_st!=undefined) {
		clearTimeout(calendar_div_st);
		calendar_div_st=undefined;
	}
}

// @tag ext-ux
Ext.define('NV.ext.ux.nv.form.ColorField', { // path
	extend : 'Ext.form.field.Trigger',
	alias : 'widget.colorfield',

	fieldType : 'color',

	config : {
		enableKeyEvents : true,
		
		saveDelay: 500,
		triggerCls : 'nv-color-trigger',
		enableDynamic:true
	
	},

	constructor : function(config) {
		this.plugins = [];

		this.callParent([Ext.apply(config,{
			listeners : {
				keyup : function(me, e) {
					this.setActiveError();
					if (e.getKey() == 13) {
						me.setValue(Ext.get(me.getInputId()).dom.value);
					}
				},
				blur: function(comp, e, eOpts){
					comp.setValue(Ext.get(comp.getInputId()).dom.value);
				},
				scope : this
			}
		})]);
		
		this.addListener('afterrender', function(panel, evt, eOpts) {
			Ext.get(this.getInputId()).addListener('click', function(elem) {
				elem.currentTarget.selectionStart = 0;
			
			}, this);
		}, this);
	},

	getValue : function() {
		return this.value;
	},
	
	setValue : function(value) {
		if(!value){
			if(Ext.get(this.getInputId())){
				Ext.get(this.getInputId()).dom.style.backgroundColor = "#FFFFFF";
				Ext.get(this.getInputId()).dom.style.backgroundImage = "url()";
				Ext.get(this.getInputId()).dom.style.color = "#000000";
			}
			this.callParent([value]);
			return;
		}
		if(value.match("[A-Fa-f0-9]{6}")){
			if(Ext.get(this.getInputId())){
				if(parseInt(value,16)<parseInt('888888',16)){
					Ext.get(this.getInputId()).dom.style.color = "#FFFFFF";
				}else{
					Ext.get(this.getInputId()).dom.style.color = "#000000";
				}
				Ext.get(this.getInputId()).dom.style.backgroundColor = "#"+value;
				Ext.get(this.getInputId()).dom.style.backgroundImage = "url()";
			}
			
			this.callParent([value]);
		}else{
			this.setActiveError("Wrong value!");
		}
		
	},
	
	onTriggerClick : function(e) {
	//	this.fireEvent('blur', this );
		this.showColorPicker(e);

	},

	showColorPicker : function(event) {
		var picker = Ext.create('NV.ext.ux.nv.picker.ColorPicker', {
			modal:true,
			floating : true,
			hidden : false,
			focusOnShow : true,
			showDynamic:this.enableDynamic,
			keyNavConfig : {
				esc : function() {
					this.hide();
				}
			},
			listeners: {
				hide: function(colorPicker, eOpts){
					this.setValue(colorPicker.getValue());
				},
				scope:this
			},
			value:this.value
			
		});
		
		picker.mon(Ext.getBody(), 'click', function(el, e){
            picker.hide();
        }, picker, { delegate: '.x-mask' });
		
		var x = event.getX();
		var y = event.getY();
		if(210+event.getX()>=Ext.getBody().getWidth()){
			x = event.getX()-210;
		}
		if(300+event.getY()>=Ext.getBody().getHeight()){
			y = event.getY()-300;
		}
		
		x=x<0?0:x;
		y=y<0?0:y;
		
		picker.showAt(x,y);
		this.fireEvent("colorPickerShow",this);
	}
});

// @tag ext-ux
Ext.define('NV.ext.ux.nv.tools.InputTextMask', { // TODO licensz
   constructor: function(mask, clearWhenInvalid) {
      if(clearWhenInvalid === undefined)
         this.clearWhenInvalid = false;
      else
         this.clearWhenInvalid = clearWhenInvalid;
      this.rawMask = mask;
      this.viewMask = '';
      this.maskArray = new Array();
      var mai = 0;
      var regexp = '';
      for(var i=0; i<mask.length; i++){
         if(regexp){
            if(regexp == 'X'){
               regexp = '';
            }
            if(mask.charAt(i) == 'X'){
               this.maskArray[mai] = regexp;
               mai++;
               regexp = '';
            } else {
               regexp += mask.charAt(i);
            }
         } else if(mask.charAt(i) == 'X'){
            regexp += 'X';
            this.viewMask += '_';
            //this.viewMask += String.fromCharCode(160);
         } else if(mask.charAt(i) == '9' || mask.charAt(i) == 'L' || mask.charAt(i) == 'l' || mask.charAt(i) == 'A') {
            this.viewMask += '_';
            //this.viewMask += String.fromCharCode(160);
            this.maskArray[mai] = mask.charAt(i);
            mai++;
         } else {
            this.viewMask += mask.charAt(i);
            this.maskArray[mai] = RegExp.escape(mask.charAt(i));
            mai++;
         }
      }

      this.specialChars = this.viewMask.replace(/(L|l|9|A|_|X)/g,'');
      return this;
   },

   init: function(field) {
      this.field = field;

      if (field.rendered){
         this.assignEl();
      } else {
         field.on('render', this.assignEl, this);
      }

      field.on('blur',this.removeValueWhenInvalid, this);
      field.on('focus',this.processMaskFocus, this);
   },

   assignEl: function() {
      this.inputTextElement = this.field.inputEl.dom;
      this.field.inputEl.on('keypress', this.processKeyPress, this);
      this.field.inputEl.on('keydown', this.processKeyDown, this);
      if(Ext.isSafari || Ext.isIE){
         this.field.inputEl.on('paste',this.startTask,this);
         this.field.inputEl.on('cut',this.startTask,this);
      }
      if(Ext.isGecko || Ext.isOpera){
         this.field.inputEl.on('mousedown',this.setPreviousValue,this);
      }
      if(Ext.isGecko){
        this.field.inputEl.on('input',this.onInput,this);
      }
      if(Ext.isOpera){
        this.field.inputEl.on('input',this.onInputOpera,this);
      }
   },
   onInput: function(){
      this.startTask(false);
   },
   onInputOpera: function(){
      if(!this.prevValueOpera){
         this.startTask(false);
      }else{
         this.manageBackspaceAndDeleteOpera();
      }
   },

   manageBackspaceAndDeleteOpera: function(){
      this.inputTextElement.value=this.prevValueOpera.cursorPos.previousValue;
      this.manageTheText(this.prevValueOpera.keycode,this.prevValueOpera.cursorPos);
      this.prevValueOpera=null;
   },

   setPreviousValue: function(event){
      this.oldCursorPos=this.getCursorPosition();
   },

   getValidatedKey: function(keycode, cursorPosition) {
      var maskKey = this.maskArray[cursorPosition.start];
      if(maskKey == '9'){
         return keycode.pressedKey.match(/[0-9]/);
      } else if(maskKey == 'L'){
         return (keycode.pressedKey.match(/[A-Za-z]/))? keycode.pressedKey.toUpperCase(): null;
      } else if(maskKey == 'l'){
         return (keycode.pressedKey.match(/[A-Za-z]/))? keycode.pressedKey.toLowerCase(): null;
      } else if(maskKey == 'A'){
         return keycode.pressedKey.match(/[A-Za-z0-9]/);
      } else if(maskKey){
         return (keycode.pressedKey.match(new RegExp(maskKey)));
      }
      return(null);
   },

   removeValueWhenInvalid: function() {
      /*if(this.clearWhenInvalid && this.inputTextElement.value.indexOf('_') > -1){
         this.inputTextElement.value = '';
      }*/
   },

   managePaste: function() {
      if(this.oldCursorPos==null){
        return;
      }
      var valuePasted=this.inputTextElement.value.substring(this.oldCursorPos.start,this.inputTextElement.value.length-(this.oldCursorPos.previousValue.length-this.oldCursorPos.end));
      if(this.oldCursorPos.start<this.oldCursorPos.end){
         this.oldCursorPos.previousValue =
            this.oldCursorPos.previousValue.substring(0,this.oldCursorPos.start)+
            this.viewMask.substring(this.oldCursorPos.start,this.oldCursorPos.end)+
            this.oldCursorPos.previousValue.substring(this.oldCursorPos.end,this.oldCursorPos.previousValue.length);
         valuePasted=valuePasted.substr(0,this.oldCursorPos.end-this.oldCursorPos.start);
      }
      this.inputTextElement.value=this.oldCursorPos.previousValue;
      keycode = {
         unicode: '',
         isShiftPressed: false,
         isTab: false,
         isBackspace: false,
         isLeftOrRightArrow: false,
         isDelete: false,
         pressedKey: ''
      }
      var charOk=false;
      for(var i=0;i<valuePasted.length;i++){
         keycode.pressedKey=valuePasted.substr(i,1);
         keycode.unicode=valuePasted.charCodeAt(i);
         this.oldCursorPos=this.skipMaskCharacters(keycode,this.oldCursorPos);
         if(this.oldCursorPos===false){
            break;
         }
         if(this.injectValue(keycode,this.oldCursorPos)){
            charOk=true;
            this.moveCursorToPosition(keycode, this.oldCursorPos);
            this.oldCursorPos.previousValue=this.inputTextElement.value;
            this.oldCursorPos.start=this.oldCursorPos.start+1;
         }
      }
      if(!charOk && this.oldCursorPos!==false){
         this.moveCursorToPosition(null, this.oldCursorPos);
      }
      this.oldCursorPos=null;
   },

   processKeyDown: function(e){
      this.processMaskFormatting(e,'keydown');
   },

   processKeyPress: function(e){
      this.processMaskFormatting(e,'keypress');
   },

   startTask: function(setOldCursor){
      if(this.task==undefined){
         this.task=new Ext.util.DelayedTask(this.managePaste,this);
     }
      if(setOldCursor!== false){
         this.oldCursorPos=this.getCursorPosition();
     }
     this.task.delay(0);
   },

   skipMaskCharacters: function(keycode, cursorPos){
      if(cursorPos.start!=cursorPos.end && (keycode.isDelete || keycode.isBackspace))
         return(cursorPos);
      while(this.specialChars.match(RegExp.escape(this.viewMask.charAt(((keycode.isBackspace)? cursorPos.start-1: cursorPos.start))))){
         if(keycode.isBackspace) {
            cursorPos.dec();
         } else {
            cursorPos.inc();
         }
         if(cursorPos.start >= cursorPos.previousValue.length || cursorPos.start < 0){
            return false;
         }
      }
      return(cursorPos);
   },

   isManagedByKeyDown: function(keycode){
      if(keycode.isDelete || keycode.isBackspace){
         return(true);
      }
      return(false);
   },

   processMaskFormatting: function(e, type) {
      this.oldCursorPos=null;
      var cursorPos = this.getCursorPosition();
      var keycode = this.getKeyCode(e, type);
      if(keycode.unicode==0){//?? sometimes on Safari
         return;
      }
      if((keycode.unicode==67 || keycode.unicode==99) && e.ctrlKey){//Ctrl+c, let's the browser manage it!
         return;
      }
      if((keycode.unicode==88 || keycode.unicode==120) && e.ctrlKey){//Ctrl+x, manage paste
         this.startTask();
         return;
      }
      if((keycode.unicode==86 || keycode.unicode==118) && e.ctrlKey){//Ctrl+v, manage paste....
         this.startTask();
         return;
      }
      if((keycode.isBackspace || keycode.isDelete) && Ext.isOpera){
        this.prevValueOpera={cursorPos: cursorPos, keycode: keycode};
        return;
      }
      if(type=='keydown' && !this.isManagedByKeyDown(keycode)){
         return true;
      }
      if(type=='keypress' && this.isManagedByKeyDown(keycode)){
         return true;
      }
      if(this.handleEventBubble(e, keycode, type)){
         return true;
      }
      return(this.manageTheText(keycode, cursorPos));
   },

   manageTheText: function(keycode, cursorPos){
      if(this.inputTextElement.value.length === 0){
         this.inputTextElement.value = this.viewMask;
      }
      cursorPos=this.skipMaskCharacters(keycode, cursorPos);
      if(cursorPos===false){
         return false;
      }
      if(this.injectValue(keycode, cursorPos)){
         this.moveCursorToPosition(keycode, cursorPos);
      }
      return(false);
   },

   processMaskFocus: function(){
      if(this.inputTextElement.value.length == 0){
         var cursorPos = this.getCursorPosition();
         this.inputTextElement.value = this.viewMask;
         this.moveCursorToPosition(null, cursorPos);
      }
   },

   isManagedByBrowser: function(keyEvent, keycode, type){
      if(((type=='keypress' && keyEvent.charCode===0) ||
         type=='keydown') && (keycode.unicode==Ext.EventObject.TAB ||
         keycode.unicode==Ext.EventObject.RETURN ||
         keycode.unicode==Ext.EventObject.ENTER ||
         keycode.unicode==Ext.EventObject.SHIFT ||
         keycode.unicode==Ext.EventObject.CONTROL ||
         keycode.unicode==Ext.EventObject.ESC ||
         keycode.unicode==Ext.EventObject.PAGEUP ||
         keycode.unicode==Ext.EventObject.PAGEDOWN ||
         keycode.unicode==Ext.EventObject.END ||
         keycode.unicode==Ext.EventObject.HOME ||
         keycode.unicode==Ext.EventObject.LEFT ||
         keycode.unicode==Ext.EventObject.UP ||
         keycode.unicode==Ext.EventObject.RIGHT ||
         keycode.unicode==Ext.EventObject.DOWN)){
            return(true);
      }
      return(false);
   },

   handleEventBubble: function(keyEvent, keycode, type) {
      try {
         if(keycode && this.isManagedByBrowser(keyEvent, keycode, type)){
            return true;
         }
         keyEvent.stopEvent();
         return false;
      } catch(e) {
         alert(e.message);
      }
   },

   getCursorPosition: function() {
      var s, e, r;
      if(this.inputTextElement.createTextRange){
         r = document.selection.createRange().duplicate();
         r.moveEnd('character', this.inputTextElement.value.length);
         if(r.text === ''){
            s = this.inputTextElement.value.length;
         } else {
            s = this.inputTextElement.value.lastIndexOf(r.text);
         }
         r = document.selection.createRange().duplicate();
         r.moveStart('character', -this.inputTextElement.value.length);
         e = r.text.length;
      } else {
         s = this.inputTextElement.selectionStart;
         e = this.inputTextElement.selectionEnd;
      }
      return this.CursorPosition(s, e, r, this.inputTextElement.value);
   },

   moveCursorToPosition: function(keycode, cursorPosition) {
      var p = (!keycode || (keycode && keycode.isBackspace ))? cursorPosition.start: cursorPosition.start + 1;
      if(this.inputTextElement.createTextRange){
         cursorPosition.range.move('character', p);
         cursorPosition.range.select();
      } else {
         this.inputTextElement.selectionStart = p;
         this.inputTextElement.selectionEnd = p;
      }
   },

   injectValue: function(keycode, cursorPosition) {
      if (!keycode.isDelete && keycode.unicode == cursorPosition.previousValue.charCodeAt(cursorPosition.start))
         return true;
      var key;
      if(!keycode.isDelete && !keycode.isBackspace){
         key=this.getValidatedKey(keycode, cursorPosition);
      } else {
         if(cursorPosition.start == cursorPosition.end){
            key='_';
            if(keycode.isBackspace){
               cursorPosition.dec();
            }
         } else {
            key=this.viewMask.substring(cursorPosition.start,cursorPosition.end);
         }
      }
      if(key){
         this.inputTextElement.value = cursorPosition.previousValue.substring(0,cursorPosition.start)
            + key +
            cursorPosition.previousValue.substring(cursorPosition.start + key.length,cursorPosition.previousValue.length);
         return true;
      }
      return false;
   },

   getKeyCode: function(onKeyDownEvent, type) {
      var keycode = {};
      keycode.unicode = onKeyDownEvent.getKey();
      keycode.isShiftPressed = onKeyDownEvent.shiftKey;

      keycode.isDelete = ((onKeyDownEvent.getKey() == Ext.EventObject.DELETE && type=='keydown') || ( type=='keypress' && onKeyDownEvent.charCode===0 && onKeyDownEvent.keyCode == Ext.EventObject.DELETE))? true: false;
      keycode.isTab = (onKeyDownEvent.getKey() == Ext.EventObject.TAB)? true: false;
      keycode.isBackspace = (onKeyDownEvent.getKey() == Ext.EventObject.BACKSPACE)? true: false;
      keycode.isLeftOrRightArrow = (onKeyDownEvent.getKey() == Ext.EventObject.LEFT || onKeyDownEvent.getKey() == Ext.EventObject.RIGHT)? true: false;
      keycode.pressedKey = String.fromCharCode(keycode.unicode);
      return(keycode);
   },

   CursorPosition: function(start, end, range, previousValue) {
      var cursorPosition = {};
      cursorPosition.start = isNaN(start)? 0: start;
      cursorPosition.end = isNaN(end)? 0: end;
      cursorPosition.range = range;
      cursorPosition.previousValue = previousValue;
      cursorPosition.inc = function(){cursorPosition.start++;cursorPosition.end++;};
      cursorPosition.dec = function(){cursorPosition.start--;cursorPosition.end--;};
      return(cursorPosition);
   }
});

Ext.applyIf(RegExp, {
   escape: function(str) {
      return new String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
   }
});

// @tag ext-ux
/**
 * fel le nyilak, input text mask
 */
Ext.require('NV.ext.ux.nv.tools.InputTextMask');

Ext.define('NV.ext.ux.nv.form.DateField' , { // path
    
    extend: 'Ext.form.field.Date',
    alias: 'widget.nvdatefield',
    disabledValue: undefined,
    
    interval: false,
    
    settings: false, // settings button
    
    fieldType: 'date',
    
    doMask: false, // TODO false - ne csináljon maszkolást
    
    maskFormat: undefined,
    
    disablePickerOnDisabled: false,
    
    minMaxDate: {minYear: 1900, maxYear: 9999, minMonth: 1, maxMonth: 12, minDay: 1, maxDay: 31}, 
    monthMaxDays: {1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}, 
        
    format: 'Y-m-d', // !!!
    
    disableSel: false,
    
    specialDateTime: "",
    
    initComponent: function()
    {
    	var plugins = [];
    	if(this.doMask){
        	plugins = [new NV.ext.ux.nv.tools.InputTextMask(this.getMaskFormat(), false)];
    	}
        Ext.apply(this, {
            format: this.format,
            width: this.calcWidth(),
            // maxvalue minvalue sets disable picker
            onDownArrow: Ext.emptyFn, // clear picker
            plugins: plugins,
            enableKeyEvents: true,
            listeners: {
                focus: function (t, e, opts) {
                    this.setSelection(Ext.get(this.id + '-inputEl').dom, 0, 0);
                },
                specialkey: function (t, e, opts) {
                    var key = e.getKey();
                    if (!this.disableSel) {
                        this.keyEvents(t, key, e);
                    }
                },
                render: function () {
                    this.disableSel = this.isDisabled();
                    this.setDisabled(false);
                    /*if (this.isDisabled()) {
                        this.disableSel = this.isDisabled();
                    }
                    if (this.disabled) {
                        this.disableSel = this.disabled;
                    }*/
                    this.disabledValue = this.getValue();
                    if (this.disableSel) {
                        this.setEditable(false);
                        if(this.disablePickerOnDisabled){
                            this.getPicker().setDisabled(true);
                        }
                        this.getPicker().on("select", function (t, d, e) {
                            this.setValue(this.disabledValue);
                        }, this);
                        this.setFieldStyle('background: #f5f5f5');
                        //this.setEditable(false);
                        Ext.get(this.id + '-inputEl').dom.disabled = true;
                    }
                    
                },
                disable: function () {
                    this.setDisabled(false);
                    if(!this.disableSel){ // nem disbled de azzá kell tenni 
                        this.disabledValue = this.getValue();
                        this.disableSel = true;
                        
                        if(this.disablePickerOnDisabled){
                            this.getPicker().setDisabled(true);
                        }
                        this.getPicker().on("select", function (t, d, e) {
                            this.setValue(this.disabledValue);
                        }, this);
                        this.setFieldStyle('background: #f5f5f5');
                        //this.setEditable(false);
                        Ext.get(this.id + '-inputEl').dom.disabled = true;
                        
                        console.log(Ext.get(this.id + '-inputEl'));
                        
                        
                    } else { // disabled de ne legyen az
                    
                        this.disableSel = false;
                        if(this.disablePickerOnDisabled){
                            this.getPicker().setDisabled(false);
                        }
                        this.getPicker().on("select", function (t, d, e) {
                            this.setValue(d);
                        }, this);
                        this.setFieldStyle('background: #ffffff');
                        //this.setEditable(true);
                        Ext.get(this.id + '-inputEl').dom.disabled = false;
                        
                        console.log(Ext.get(this.id + '-inputEl'));
                    }
                }
            }
        });
        this.callParent();
    },
   
    getErrors: function(value) {
        var me = this,
            format = Ext.String.format,
            clearTime = Ext.Date.clearTime,
            errors = me.callParent(arguments),
            disabledDays = me.disabledDays,
            disabledDatesRE = me.disabledDatesRE,
            minValue = me.minValue,
            maxValue = me.maxValue,
            len = disabledDays ? disabledDays.length : 0,
            i = 0,
            svalue,
            fvalue,
            day,
            time;

        if(value=="now" || value=="today" || value=="yesterday"){
        	
        	return;
        }
        value = me.formatDate(value || me.processRawValue(me.getRawValue()));

        if (value === null || value.length < 1) { // if it's blank and textfield didn't flag it then it's valid
             return errors;
        }

        svalue = value;
        value = me.parseDate(value);
        if (!value) {
            errors.push(format(me.invalidText, svalue, Ext.Date.unescapeFormat(me.format)));
            return errors;
        }

        time = value.getTime();
        if (minValue && time < clearTime(minValue).getTime()) {
            errors.push(format(me.minText, me.formatDate(minValue)));
        }

        if (maxValue && time > clearTime(maxValue).getTime()) {
            errors.push(format(me.maxText, me.formatDate(maxValue)));
        }

        if (disabledDays) {
            day = value.getDay();

            for(; i < len; i++) {
                if (day === disabledDays[i]) {
                    errors.push(me.disabledDaysText);
                    break;
                }
            }
        }

        fvalue = me.formatDate(value);
        if (disabledDatesRE && disabledDatesRE.test(fvalue)) {
            errors.push(format(me.disabledDatesText, fvalue));
        }

        return errors;
    },

    
    calcWidth: function() {
        var f = this.getMaskFormat();
        var s = 10;
        if (f.length < 9) s = 12;
        if (f.length < 5) s = 15;
        var w = f.length * s;
        return w;
    },
    
    getMaskFormat: function () {
        
        // build mask format by format if undefined
        if (this.maskFormat === undefined) {
        
            var maskformat =  this.format.replace("Y", "9999");
            maskformat =  maskformat.replace("m", "99");
            maskformat =  maskformat.replace("d", "99");
            this.maskFormat = maskformat;
        
        }
        
        return this.maskFormat;
        
    },
    
    keyEvents: function (t, key, e) {
        var inputField = Ext.get(this.id + '-inputEl');
        var data = this.parseValue(inputField);
        
        switch(key){
            case 38: // up
                e.stopEvent();
                
                var num = parseInt(data.value[data.cursorData.state],10);
                
                var minus;
                if(isNaN(num)){
                     minus = 1;
                     num = this.getMin(data.cursorData.state);
                } else {
                     num = num + 1;
                     if (num > this.getMax(data.cursorData.state, data.value)) {
                         num = this.getMax(data.cursorData.state, data.value);
                     }
                     if (num.toString().length > data.value[data.cursorData.state].length) {
                         num = this.getMax(data.cursorData.state, data.value);
                     }
                }
                minus = num.toString().length;
                
                var zeros = "";
                for (var i = 0; i < data.value[data.cursorData.state].length - minus; i = i + 1){
                    zeros = zeros + "0";
                }
                
                data.value[data.cursorData.state] = zeros + num.toString();
                
                if (this.getParser()) {
                    inputField.value = data.value.join(this.getParser());
                    t.setRawValue(data.value.join(this.getParser()));
                    this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                } else {
                    inputField.value = data.value[data.cursorData.state];
                    t.setRawValue(data.value[data.cursorData.state]);
                    this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                }
                
                break;
                
            case 40: // down 
            
                var num = parseInt(data.value[data.cursorData.state],10);
                
                var minus;
                if(isNaN(num)){
                     minus = 1;
                     num = this.getMin(data.cursorData.state);
                } else {
                     if (num > this.getMin(data.cursorData.state)) num = num - 1;
                }
                minus = num.toString().length;
                
                var zeros = "";
                for (var i = 0; i < data.value[data.cursorData.state].length - minus; i = i + 1){
                    zeros = zeros + "0";
                }
                
                data.value[data.cursorData.state] = zeros + num.toString();
                
                if (this.getParser()) {
                    inputField.value = data.value.join(this.getParser());
                    t.setRawValue(data.value.join(this.getParser()));
                    this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                } else {
                    inputField.value = data.value[data.cursorData.state];
                    t.setRawValue(data.value[data.cursorData.state]);
                    this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                }
                
                break;
                
            case 37: // left
                if (data.cursorData.state === 2) {
                    this.setSelection(inputField.dom, data.value[0].length + 2, data.value[0].length + 2)
                } else if (data.cursorData.state === 1) {
                    this.setSelection(inputField.dom, 0, 0)
                }
                break;
                
            case 39: // right
                if (data.cursorData.state === 0 && this.getParser()) {
                    this.setSelection(inputField.dom, data.cursorData.firstParser, data.cursorData.firstParser)
                } else if (data.cursorData.state === 1 && data.cursorData.lastParser > data.cursorData.firstParser) {
                    this.setSelection(inputField.dom, data.cursorData.lastParser, data.cursorData.lastParser)
                }
                break;
        }
    },
    
    parseValue: function (inputField) {
        var val = inputField.getValue();
        var data = {}
        data.cursorData = {};
        
        data.cursorData.selStart = this.getSelectionStart(inputField.dom);
        data.cursorData.selEnd = this.getSelectionEnd(inputField.dom);
        
        if (this.getParser()) {
            var p = this.getParser()
            data.cursorData.firstParser = val.indexOf(p);
            data.cursorData.lastParser = val.lastIndexOf(p);
            
            if (data.cursorData.lastParser > data.cursorData.firstParser) {
                if (data.cursorData.selStart <= data.cursorData.firstParser) {
                    data.cursorData.state = 0;
                } else if (data.cursorData.selStart > data.cursorData.lastParser) {
                    data.cursorData.state = 2;
                } else {
                    data.cursorData.state = 1;
                }
            } else {
                if (data.cursorData.selStart <= data.cursorData.firstParser) {
                    data.cursorData.state = 0;
                } else {
                    data.cursorData.state = 1;
                }
            }
            
            data.value = val.split(p)
            data.cursorData.state
        } else {
            data.cursorData.firstParser = 0;
            data.cursorData.lastParser = 0;
            data.cursorData.state = 0;
            data.value = [val]
        }
        
        return data;
        
    },
    
    getParser: function () {
        
        var val = this.format;
        
        if (val.indexOf('.') > -1) {
            return '.';
        } else if (val.indexOf('-') > -1) {
            return '-';
        } else if (val.indexOf('/') > -1) {
            return '/';
        }
        return false;
    },
    
    getSelectionStart: function (f) {
        if (f.createTextRange) {
            var r = document.selection.createRange().duplicate()
            r.moveEnd('character', f.getValue().length)
            if (r.text === ''){
                return f.getValue().length
            }
            return f.getValue().lastIndexOf(r.text)
        } else {
            return f.selectionStart
        }
    },
    
    getSelectionEnd: function (f) {
        if (f.createTextRange) {
            var r = document.selection.createRange().duplicate()
            r.moveStart('character', -f.value.length)
            return r.text.length
        } else {
            return f.selectionEnd
        }
    },
    
    setSelection: function (f, a, b) {
        if (f.createTextRange) {
            var r = f.createTextRange();
            r.collapse(true);
            r.moveStart('character', a);
            r.moveEnd('character', b);
            r.select();
        } else {
            f.selectionStart = a;
            f.selectionEnd = b;
        }
    },
    
    getMin: function(cursorState) {
        var formatArray = this.format.split(this.getParser());
        var actualFormat = formatArray[cursorState];
        if (actualFormat === 'Y') {
            return this.minMaxDate.minYear;
        } else if(actualFormat === 'm') {
            return this.minMaxDate.minMonth;
        } else if(actualFormat === 'd') {
            return this.minMaxDate.minDay;
        } 
    },
    
    getMax: function(cursorState, val) {
        var formatArray = this.format.split(this.getParser());
        var actualFormat = formatArray[cursorState];
        if (actualFormat === 'Y') {
            return this.minMaxDate.maxYear;
        } else if(actualFormat === 'm') {
            return this.minMaxDate.maxMonth;
        } else if(actualFormat === 'd') {
            //return this.minMaxDate.maxDay; // todo
            return this.getMaxDayByMonth(formatArray, val);
        }
    },
    
    getMaxDayByMonth: function (formatArray, val) {
        var res = 1;
        for (var i = 0; i < formatArray.length; i = i + 1){
            var v = parseInt(val[i], 10);
            if (formatArray[i] === 'm' && !isNaN(v)) {
                res = v;
            }
        }
        return ((this.monthMaxDays[res] > this.minMaxDate.maxDay) ? this.minMaxDate.maxDay : this.monthMaxDays[res]);
        
    },
    
    getData: function () { // data jön valahonnan és beteszi magát a fieldekbe...
        var data = new Date();
        
        this.insertData(data);
    },
    
    insertData: function (data) {
        // stringgé tenni és beleilleszteni
        var dateString = Ext.Date.format(data, this.format);
        
        this.setRawValue(dateString);
        
    },
    
    // get/set
    
    getSettingsFields: function () {
        // build fields to give settings form
    },
    
    getFieldType: function () {
        return this.fieldType;
    },
    
    toggleDisable: function () {
        this.setDisabled(true);
    },
    
    getFormat: function() {
        return this.format;
    },
    
    setFormat: function(newFormat) {
        var v = this.getValue();
        var rv = Ext.get(this.id + '-inputEl').getValue();
        this.format = newFormat;
        
        if(this.plugins.length > 1){
            this.plugins.pop();
        }
        
        this.plugins.push(new NV.ext.ux.nv.tools.InputTextMask(this.getMaskFormat(), false));
        
        this.plugins[0].rawMask = this.plugins[this.plugins.length-1].rawMask;
        this.plugins[0].viewMask = this.plugins[this.plugins.length-1].viewMask;
        this.plugins[0].specialChars = this.plugins[this.plugins.length-1].specialChars;
        this.plugins[0].maskArray = this.plugins[this.plugins.length-1].maskArray;
        
        this.doComponentLayout();
        this.updateLayout();
        
        this.plugins.pop();
        
        this.setValue(v);
    },
    
    getDisablePickerOnDisabled: function() {
        return this.disablePickerOnDisabled;
    },
    
    setDisablePickerOnDisabled: function(d) {
        this.disablePickerOnDisabled = d;
        if (this.disableSel) {
            this.getPicker().setDisabled(d);
        }
    }
});



// @tag ext-ux
/**
 * maskolt, fel le , date time field használja
 */
Ext.require('NV.ext.ux.nv.tools.InputTextMask');

Ext.define('NV.ext.ux.nv.tools.TimeField' , { // path
    
    extend: 'Ext.form.field.Time',
    alias: 'widget.nvtimefield',
    fieldType: 'time',
    
    settings: false, // settings button
    
    interval: false,
        
    maskFormat: undefined,
    doMask: true, // TODO false - ne csináljon maszkolást
    
    mode: undefined, // 12/24
    
    minMaxSettings: {minH: 0, maxH: 23, minM: 0, maxM: 59, minS: 0, maxS: 59, minMS: 0, maxMS: 999},
            
    //format: 'h:i:s.u A', // 01:01:01.001 PM
    format: 'h:i', //
    // 12: 'h:i A', '03:15 PM'. 'h:i:s.u A' 24: 'H:i' 'H:i:s.u' instead.
    
    disableSel: false,
    
    initComponent: function()
    {
        Ext.apply(this, {
            // "Egyelőre known, de unresolved issue-nak tekintjük." Paka
                // time field, kiveszi az értéket 4.1.0-ben, ha az érték nem valid
                // 4.1.3-ban helyesen működik
            format: this.setFormatByMode(),
            growToLongestValue: true,
            grow: true,
            increment: 30, // min
            // picker ne ajánljon fel min/max intervall-nál kijjebb, nem kötelező TODO
            onDownArrow: Ext.emptyFn,
            validateOnBlur: false,
            plugins: [new NV.ext.ux.nv.tools.InputTextMask(this.getMaskFormat(), false)],
            enableKeyEvents: true,
            listeners: {
                focus: function (t, e, opts) {
                    this.setSelection(Ext.get(this.id + '-inputEl').dom, 0, 0);
                },
                specialkey: function (t, e, opts) {
                    var key = e.getKey();
                    if (!this.disableSel) {
                        this.keyEvents(t, key, e);
                    }
                },
                render: function () {
                    this.disableSel = this.isDisabled();
                    if (this.disableSel) {
                        this.setEditable(false);
                    }
                    this.disabledValue = this.getValue();
                },
                disable: function () {
                    this.setDisabled(false);
                    if (!this.disableSel) { 
                        this.disableSel = true;
                        
                        this.setFieldStyle('background: #f5f5f5');
                        //this.setEditable(false);
                        Ext.get(this.id + '-inputEl').dom.disabled = true;
                        this.editable = false;
                        
                        this.getPicker().getSelectionModel().setLocked(true);
                        this.getPicker().trackOver = false;
                                                
                        this.getPicker().addCls('disabled-combobox');
                        
                    } else { 
                    
                        this.disableSel = false;
                        
                        this.setFieldStyle('background: #ffffff');
                        //this.setEditable(true);
                        Ext.get(this.id + '-inputEl').dom.disabled = false;
                        this.editable = true;
                        
                        this.getPicker().getSelectionModel().setLocked(false);
                                                
                        this.getPicker().removeCls('disabled-combobox');
                    }
                }
            }
        });
        this.callParent();
    },
    
    setFormatByMode: function (m) { // TODO
        if (m) this.mode = m;
        if (this.mode !== undefined){
            var f = '';
            if (this.mode === 12){
                f = this.format.replace("H", "h");
                f = f + " A";
            } else {
                // format: 'H:i', //
                f = this.format.replace("h", "H");
                f = f.replace(" A", "");
            }
            this.format = f;
        }
        return this.format;
    },
    
    getMaskFormat: function () { // TODO
        
        // build mask format by format if undefined
        if (this.maskFormat === undefined) {
            
            var maskformat =  this.format.replace("i", "99");
            maskformat =  maskformat.replace("s", "99");
            maskformat =  maskformat.replace("H", "99");
            maskformat =  maskformat.replace("h", "99");
            maskformat =  maskformat.replace("u", "999");
            maskformat =  maskformat.replace("A", "LL");
        
            this.maskFormat = maskformat;
        }
        
        return this.maskFormat;
        
    },
    
    keyEvents: function (t, key, e) {
        var inputField = Ext.get(this.id + '-inputEl');
        var data = this.parseValue(inputField);
        
        switch(key){
            case 38: // up
                e.stopEvent();
                
                if (data.value[data.cursorData.state] === "AM") {
                    data.value[data.cursorData.state] = "PM";
                } else if (data.value[data.cursorData.state] === "PM") {
                    data.value[data.cursorData.state] = "AM";
                } else {
                
                    var num = parseInt(data.value[data.cursorData.state],10);
                    
                    var minus;
                    if(isNaN(num)){
                         minus = 1;
                         num = this.getMin(data.cursorData.state);
                    } else {
                         num = num + 1;
                         if (num > this.getMax(data.cursorData.state, data.value)) {
                             num = this.getMax(data.cursorData.state, data.value);
                         }
                         if (num.toString().length > data.value[data.cursorData.state].length) {
                             num = this.getMax(data.cursorData.state, data.value);
                         }
                    }
                    minus = num.toString().length;
                    
                    var zeros = "";
                    for (var i = 0; i < data.value[data.cursorData.state].length - minus; i = i + 1){
                        zeros = zeros + "0";
                    }
                    
                    data.value[data.cursorData.state] = zeros + num.toString();
                }
                
                if (this.getParser()) {
                    
                    var joined = '';
                    
                    for (var i = 0; i < this.getParser().length; i = i + 1) {
                        joined = joined + data.value[i] + this.getParser()[i]
                    }
                    
                    inputField.value = joined;
                    t.setRawValue(joined);
                                        
                } else {
                    inputField.value = data.value[data.cursorData.state];
                    t.setRawValue(data.value[data.cursorData.state]);
                }
                
                this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                
                break;
                
            case 40: // down 
                e.stopEvent();
            
                if (data.value[data.cursorData.state] === "AM") {
                    data.value[data.cursorData.state] = "PM";
                } else if (data.value[data.cursorData.state] === "PM") {
                    data.value[data.cursorData.state] = "AM";
                } else {
            
                    var num = parseInt(data.value[data.cursorData.state],10);
                    
                    var minus;
                    if(isNaN(num)){
                         minus = 1;
                         num = this.getMin(data.cursorData.state);
                    } else {
                         if (num > this.getMin(data.cursorData.state)) num = num - 1;
                    }
                    minus = num.toString().length;
                    
                    var zeros = "";
                    for (var i = 0; i < data.value[data.cursorData.state].length - minus; i = i + 1){
                        zeros = zeros + "0";
                    }
                    
                    data.value[data.cursorData.state] = zeros + num.toString();
                
                }
                
                if (this.getParser()) {
                    var joined = '';
                    
                    for (var i = 0; i < this.getParser().length; i = i + 1) {
                        joined = joined + data.value[i] + this.getParser()[i]
                    }
                                        
                    inputField.value = joined;
                    t.setRawValue(joined);
                } else {
                    inputField.value = data.value[data.cursorData.state];
                    t.setRawValue(data.value[data.cursorData.state]);
                }
                
                this.setSelection(inputField.dom, data.cursorData.selStart, data.cursorData.selStart)
                
                break;
                
            case 37: // left
                if (data.cursorData.state >= 2) {
                    this.setSelection(inputField.dom, data.cursorData.parser[data.cursorData.state-2]+2, data.cursorData.parser[data.cursorData.state-2]+2)
                } else if (data.cursorData.state === 1) {
                    this.setSelection(inputField.dom, 0, 0)
                }
                break;
                
            case 39: // right
                if (data.cursorData.state < data.cursorData.parser.length && this.getParser()) {
                    this.setSelection(inputField.dom, data.cursorData.parser[data.cursorData.state], data.cursorData.parser[data.cursorData.state])
                }
                break;
        }
    },
    
    parseValue: function (inputField) {
        
        var val = inputField.getValue();
        
        var valueToParse = val.replace(" ", ":");
        valueToParse = valueToParse.replace(".", ":");
        
        var data = {}
        data.cursorData = {};
        
        data.cursorData.selStart = this.getSelectionStart(inputField.dom);
        data.cursorData.selEnd = this.getSelectionEnd(inputField.dom);
        
        
        if (this.getParser()) {
            var p = ":", x = 0;
            data.cursorData.parser = [];
            
            
            var v = valueToParse.split('');
            
            for (var i = 0; i < v.length; i = i + 1) {
                if(v[i] === ":"){
                    data.cursorData.parser[x] = i;
                    x = x + 1;
                }
            }
            
            var found = false, state = 0;;
            for (i = 0; i < data.cursorData.parser.length; i = i + 1) { // ?????
                if(data.cursorData.selStart <= data.cursorData.parser[0]){
                    state = 0;
                    found = true;
                } else if (data.cursorData.selStart > data.cursorData.parser[data.cursorData.parser.length - 1]) {
                    state = i + 1;
                    found = true;
                } else if (data.cursorData.selStart <= data.cursorData.parser[i] && data.cursorData.selStart > data.cursorData.parser[i-1] && !found){
                    state = i;
                    found = true;
                }
            }
            
            data.cursorData.state = state;
            
            data.value = valueToParse.split(p);
        } else {
            data.cursorData.state = 0;
            data.value = [val]
        }
        
        return data;
        
    },
    
    getParser: function () { // ARRAY!!!
        
        var val = this.format;
        var p = [];        
        
        var v = val.split("");
        for (var i = 0; i < v.length; i = i + 1) {
            if (v[i] === ':' || v[i] === '.' || v[i] === ' ') {
                p.push(v[i]);
            }
        }
        
        if (p.length > 0){
            p.push('');
        } else {
            return false;
        }
        
        return p;
    },
    
    getSelectionStart: function (f) {
        if (f.createTextRange) {
            var r = document.selection.createRange().duplicate()
            r.moveEnd('character', f.getValue().length)
            if (r.text === ''){
                return f.getValue().length
            }
            return f.getValue().lastIndexOf(r.text)
        } else {
            return f.selectionStart
        }
    },
    
    getSelectionEnd: function (f) {
        if (f.createTextRange) {
            var r = document.selection.createRange().duplicate()
            r.moveStart('character', -f.value.length)
            return r.text.length
        } else {
            return f.selectionEnd
        }
    },
    
    setSelection: function (f, a, b) {
        if (f.createTextRange) {
            var r = f.createTextRange();
            r.collapse(true);
            r.moveStart('character', a);
            r.moveEnd('character', b);
            r.select();
        } else {
            f.selectionStart = a;
            f.selectionEnd = b;
        }
    },
    
    getMin: function(cursorState) {
        var formatToParse = this.format.replace(" ", ":");
        formatToParse = formatToParse.replace(".", ":");
        var formatArray = formatToParse.split(":");
        var actualFormat = formatArray[cursorState];
        if (actualFormat === 'H') {
            return this.minMaxSettings.minH;
        } else if( actualFormat === 'h') {
            return this.minMaxSettings.minH < 1 ? 1 : this.minMaxSettings.minH;
        } else if (actualFormat === 'i') {
            return this.minMaxSettings.minM;
        } else if( actualFormat === 's') {
            return this.minMaxSettings.minS;
        } else if( actualFormat === 'u') {
            return this.minMaxSettings.minMS;
        } else if( actualFormat === 'A') {
            return "AM";
        }
    },
    
    getMax: function(cursorState, val) {
        var formatToParse = this.format.replace(" ", ":");
        formatToParse = formatToParse.replace(".", ":");
        var formatArray = formatToParse.split(":");
        var actualFormat = formatArray[cursorState];
        if (actualFormat === 'H') {
            return this.minMaxSettings.maxH;
        } else if( actualFormat === 'h') {
            return this.minMaxSettings.maxH > 12 ? 12 : this.minMaxSettings.minH;
        } else if (actualFormat === 'i') {
            return this.minMaxSettings.maxM;
        } else if( actualFormat === 's') {
            return this.minMaxSettings.maxS;
        } else if( actualFormat === 'u') {
            return this.minMaxSettings.maxMS;
        } else if( actualFormat === 'A') {
            return "PM";
        }
    },
    
    getData: function () { // data jön valahonnan és beteszi magát a fieldekbe...
        var data = new Date();
        
        this.insertData(data);
    },
    
    insertData: function (data) {
        // stringgé tenni és beleilleszteni
        var timeString = Ext.Date.format(data, this.format);
        console.log(this.format)
        
        this.setRawValue(timeString);
        
    },
    
    // get/set
    
    getSettingsFields: function () {
        // build fields to give settings form
    },
    
    getFieldType: function () {
        return this.fieldType;
    },
    
    toggleDisable: function () {
        this.setDisabled(true);
    },
    
    getFormat: function() {
        return this.format;
    },
    
    setFormat: function(newFormat) { // frissíteni a pickert is
        var v = this.getValue();
        var rv = Ext.get(this.id + '-inputEl').getValue();
        this.format = newFormat;
        
        if(this.plugins.length > 1){
            this.plugins.pop();
        }
        
        this.plugins.push(new NV.ext.ux.nv.tools.InputTextMask(this.getMaskFormat(), false));
        
        this.plugins[0].rawMask = this.plugins[this.plugins.length-1].rawMask;
        this.plugins[0].viewMask = this.plugins[this.plugins.length-1].viewMask;
        this.plugins[0].specialChars = this.plugins[this.plugins.length-1].specialChars;
        this.plugins[0].maskArray = this.plugins[this.plugins.length-1].maskArray;
        
        this.getPicker().format = newFormat;
        //this.getPicker().getStore().loadData(this.setStoreDisp(this.getPicker().getStore()));
        this.getPicker().store=this.setStoreDisp(this.getPicker().getStore());
        
        this.doComponentLayout();
        this.getPicker().doComponentLayout();
        this.getPicker().updateLayout();
        this.getPicker().updateList();
        this.updateLayout();
        
        this.plugins.pop();
        
        this.setValue(v);
    },
    
    getMode: function() {
        return this.mode;
    },
    
    setMode: function(newMode) {
        var v = this.getValue();
        var rv = Ext.get(this.id + '-inputEl').getValue();
        this.mode = newMode;
        this.setFormatByMode(newMode);
        
        if(this.plugins.length > 1){
            this.plugins.pop();
        }
        
        this.plugins.push(new NV.ext.ux.nv.tools.InputTextMask(this.getMaskFormat(), false));
                
        this.plugins[0].rawMask = this.plugins[this.plugins.length-1].rawMask;
        this.plugins[0].viewMask = this.plugins[this.plugins.length-1].viewMask;
        this.plugins[0].specialChars = this.plugins[this.plugins.length-1].specialChars;
        this.plugins[0].maskArray = this.plugins[this.plugins.length-1].maskArray;
        
        this.getPicker().format = this.format;
        //this.getPicker().getStore().loadData(this.setStoreDisp(this.getPicker().getStore()));
        this.getPicker().store=this.setStoreDisp(this.getPicker().getStore());
        
        this.doComponentLayout();
        this.getPicker().doComponentLayout();
        this.getPicker().updateLayout();
        this.getPicker().updateList();
        this.updateLayout();
        
        this.plugins.pop();
        
        this.setValue(v);
    },
    
    setStoreDisp: function (store) {
        for(var i = 0; i < store.data.items.length; i = i + 1) {
            store.data.items[i].data.disp = Ext.Date.format(store.data.items[i].data.date, this.format).toString()
            store.data.items[i].raw.disp = Ext.Date.format(store.data.items[i].raw.date, this.format).toString()
        }
        return store;
    }
    
});

// @tag ext-ux
/**
 * felhasználja a timeField-et és a DateField-et
 */
Ext.require('NV.ext.ux.nv.tools.TimeField');
Ext.require('NV.ext.ux.nv.form.DateField');

Ext.define('NV.ext.ux.nv.form.DateTimeField', { // path

	extend : 'Ext.form.field.Trigger',
	alias : 'widget.datetimefield',

	fieldType : 'datetime',

	config : {
		dateTimeFormat : 'Y.m.d H:i:s',
		enableKeyEvents : true,
		millisecs : false,
		seconds : false,
		minutes : false,
		hours : false,
		saveDelay: 500,
		triggerCls : 'x-form-date-trigger',
		enableDynamic:true
	
	},

	constructor : function(config) {
		this.plugins = [];

		this.initConfig(config);
		this.minWidth = 80;
		if (this.dateTimeFormat.match(/h/i)) {
			this.hours = true;
			this.minWidth = 110;
		}
		if (this.dateTimeFormat.match(/i/i)) {
			this.minutes = true;
			this.minWidth = 120;
		}
		if (this.dateTimeFormat.match(/s/i)) {
			this.seconds = true;
			this.minWidth = 130;
		}
		if (this.dateTimeFormat.match("ms")) {
			this.milisecs = true;
			this.minWidth = 140;
		}
		this.listeners = {
			keyup : function(me, e) {
				this.setActiveError();
				if (e.getKey() == 13) {
					me.setValue(Ext.get(me.getInputId()).dom.value);
					
				}
			},
			blur: function(comp, e, eOpts){
				comp.setValue(Ext.get(comp.getInputId()).dom.value);
			},
			scope : this
		};

		this.callParent([this]);
		
		this.addListener('afterrender', function(panel, evt, eOpts) {
			Ext.get(this.getInputId()).addListener('click', function(elem) {
				elem.currentTarget.selectionStart = 0;
				// elem.currentTarget.selectionEnd=this.maskFormat.length;
			}, this);
		}, this);
	},

	getValue : function() {
		return this.timeValue;
	},

	/**
	 * 1) Dátum objektum jön: a mező értéke egy timestamp, kiírva a dátum
	 * megformázott verziója kerül 2) String objektum: a) dinamikus kifejezés:
	 * mező értéke ez a kifejezés, ez si kerül kiírásra b) valahogy formázott
	 * dátum: Dátum objektummá alakítjuk és újra meghívjuk a setValue-t 3)
	 * Number jön : dátummá konvertáljuk majd meghívjuk a setValue-t
	 * 
	 * @param value
	 */
	setValue : function(value) {
		if(value==this.timeValue){return;}
		if(value==undefined || value==""){
			this.timeValue = "";
			return;
			}
		if (value instanceof Date) {// dátum
			this.timeValue = value.getTime();
			this.callParent([ Ext.Date.format(value, this.dateTimeFormat) ]);
			this.fireEvent("dateValueChanged",this,value);
		} else if (isNaN(value)) {// string
			value = this.switchExpression(value);
			if (value.match('[T]{1}')) { // T12345678912 timestamp
				this.setValue(new Date(value.substring(1, value.length)));
			} else if (value.match('now') || value.match('min') || value.match('hour') || value.match('yesterday') || value.match('today') || value.match('week') || value.match('month') || value.match('year')){				
				this.timeValue = value;
				this.callParent([ value ]);
				this.fireEvent("dateValueChanged",this,value);
			
				
			} else {
				try {
					if (value.match('[0-9]{4}') || parseInt(value.match('[0-9]{4}')) > 2000) {
						var myDate = this.createDateFromNumbers(value);
						if (myDate) {
							this.setValue(myDate);
						} else {
							this.setActiveError("Wrong value!");
						}
					} else if(!isNaN(value)) { // 2000-nél kissebb számoknál alapból úgy gondoljuk hogy timestamp-et kaptunk
						try {
							this.setValue(new Date(parseInt(value)));
						} catch (e) {
							var myDate = this.createDateFromNumbers(value);
							if (myDate) {
								this.setValue(myDate);
							} else {
								this.callParent([ value ]);
								this.setActiveError("Wrong value!");
							}
						}
					}else{//nem szám és nem is passzol máshova
						this.callParent([ value ]);
						this.setActiveError("Wrong value!");
					}

				} catch (e) {
					this.callParent([ value ]);
					this.setActiveError("Wrong value!");
				}
			}
		} else { // number
			try {
				if (parseInt(value.toString().match('[0-9]{4}')) > 2000) {
					var myDate = this.createDateFromNumbers(value);
					if (myDate) {
						this.setValue(myDate);
					} else {
						this.callParent([ value ]);
						this.setActiveError("Wrong value!");
					}
				} else { // 2000-nél kissebb számoknál alapból úgy gondoljuk
							// hogy timestamp-et kaptunk
					try {
						this.setValue(new Date(parseInt(value)));
					} catch (e) {
						var myDate = this.createDateFromNumbers(value);
						if (myDate) {
							this.setValue(myDate);
						} else {
							this.callParent([ value ]);
							this.setActiveError("Wrong value!");
						}
					}
				}

			} catch (e) {
				this.callParent([ value ]);
				this.setActiveError("Wrong value!");
			}
		}
	},

	/**
	 * Create a date object from 201312211019 //not timestamp, this is a date!!
	 */
	createDateFromNumbers : function(value) {
		var myDate = new Date();
		var year, month, day, hour, minute, sec, millisec;
		if (value.match('[0-9]{4}')) {// 4 számjeggyel kezdődik, az lesz az év
			year = value.match('[1-3]{1}[0-9]{3}')[0];
			value = value.substring(4, value.length);

			if (value.match('[0-1]{1}[0-9]{1}')) { // van esetleg írásjel, vagy
													// nincs, de jön 2 számjegy
				month = value.match('[0-1]{1}[0-9]{1}')[0];
				value = value.substring(value.search(month) + 2, value.length);

				if (value.match('[0-3]{1}[0-9]{1}')) { // van esetleg írásjel,
														// vagy nincs, de jön 2
														// számjegy
					day = value.match('[0-3]{1}[0-9]{1}')[0];
					value = value.substring(value.search(day) + 2, value.length);

					if (value.match('[0-5]{1}[0-9]{1}')) { // van esetleg
															// írásjel, vagy
															// nincs, de jön 2
															// számjegy
						hour = value.match('[0-5]{1}[0-9]{1}')[0];
						value = value.substring(value.search(hour) + 2, value.length);

						if (value.match('[0-5]{1}[0-9]{1}')) { // van esetleg
																// írásjel, vagy
																// nincs, de jön
																// 2 számjegy
							minute = value.match('[0-5]{1}[0-9]{1}')[0];
							value = value.substring(value.search(minute) + 2, value.length);

							if (value.match('[0-5]{1}[0-9]{1}')) { // van
																	// esetleg
																	// írásjel,
																	// vagy
																	// nincs, de
																	// jön 2
																	// számjegy
								sec = value.match('[0-5]{1}[0-9]{1}')[0];
								value = value.substring(value.search(sec) + 2, value.length);

								if (value.match('[0-9]+')) { // van esetleg
																// írásjel, vagy
																// nincs, de jön
																// 2 számjegy
									millisec = value;
								}
							}
						}
					}
				}
			}
		}
		if (year && month && day) {
			myDate.setFullYear(year, parseInt(month) - 1, day);
			if (this.hours) {
				hour = hour ? hour : 0;
				myDate.setHours(hour);
			}
			if (this.minutes) {
				minute = minute ? minute : 0;
				myDate.setMinutes(minute);
			}
			if (this.seconds) {
				sec = sec ? sec : 0;
				myDate.setSeconds(sec);
			}
			if (this.millisecs) {
				millisec = millisec ? millisec : 0;
				myDate.setMilliseconds(millisec);
			}
			return myDate;
		} else {
			return;
		}
	},

	onTriggerClick : function(e) {
		this.fireEvent('blur', this );
		this.showDatePicker(e);

	},

	showDatePicker : function(event) {
		var picker = Ext.create('NV.ext.ux.nv.picker.DateTimePicker', {
			modal:true,
			floating : true,
			hidden : false,
			focusOnShow : true,
			showToday:false,
			dateTimeFormat : this.dateTimeFormat,
			showDynamic:this.enableDynamic,
			keyNavConfig : {
				esc : function() {
					this.hide();
				}
			},
			
			dateTimeField: this
		});
		if(this.getValue() == undefined || this.getValue() ==""){
			picker.setInitialValue(new Date());
		}
		else if(!isNaN(this.getValue())){
			picker.setInitialValue(new Date(this.getValue()));
		}else{
			picker.setInitialValue(this.getValue(), true);
		}
		var x = event.getX();
		var y = event.getY();
		if(210+event.getX()>=Ext.getBody().getWidth()){
			x = event.getX()-210;
		}
		if(300+event.getY()>=Ext.getBody().getHeight()){
			y = event.getY()-300;
		}
		
		x=x<0?0:x;
		y=y<0?0:y;
		
		picker.showAt(x,y);
		this.fireEvent("datePickerShow",this);
	},
	
	/**
	 * pl: 
	 * now-20sec
	 * yesterday-1week
	 * now-56day+3hour-2min
	 * @returns
	 */
	getForceLongValue: function(){
		if(!this.value){
			return;
		}
		var value = Ext.clone(this.value); 
		
		if (value.match('now') || value.match('min') || value.match('hour') || value.match('yesterday') || value.match('today') || value.match('week') || value.match('month') || value.match('year')){
			var firstDate;
			
			var now = new Date();
			if(value.match('now')){
				firstDate = now;
			}
			
			var minBegin = new Date();
			minBegin.setMilliseconds(0);
			minBegin.setSeconds(0);
			if(value.match('min_begin')){
				firstDate = minBegin;
			}
			
			var hourBegin = Ext.clone(minBegin);
			hourBegin.setMinutes(0);
			if(value.match('hour_begin')){
				firstDate = hourBegin;
			}
			
			var today = Ext.clone(hourBegin);
			today.setHours(0);
			if(value.match('today')){
				firstDate = today;
			}
			
			
			var yesterday = Ext.clone(today);
			yesterday.setDate(today.getDate()-1);
			if(value.match('yesterday')){
				firstDate = yesterday;
			}
			
			
			var weekBegin = Ext.clone(today);
			var dayOfWeek = weekBegin.getDay();
			if(dayOfWeek==0){
				dayOfWeek=7;
			}
			dayOfWeek--;
			weekBegin.setDate(weekBegin.getDate()-dayOfWeek);
			if(value.match('week_begin')){
				firstDate = weekBegin;
			}
			
			var monthBegin = Ext.clone(today);
			monthBegin.setDate(1);
			if(value.match('month_begin')){
				firstDate = monthBegin;
			}
			
			var yearBegin = Ext.clone(monthBegin);
			yearBegin.setMonth(1);
			if(value.match('year_begin')){
				firstDate = yearBegin;
			}
			
			if(!firstDate){
				this.setActiveError("Date parse failed!");
			}
			/*
			 * év és hónap nem állandó, a dátumból kell egyenesen kivonni
			 */
			if(value.match("[+-][0-9]+month")){
				var matches = value.match("[+-][0-9]+month");
				for(var i = 0; i < matches.length; i++){
					var val = matches[i];
					var multiplicator = val.match('[0-9]')[i];
					if(val.substring(0,1)=="+"){//+
						firstDate.setMonth(firstDate.getMonth() + multiplicator);
					}else{	//-
						firstDate.setMonth(firstDate.getMonth() - multiplicator);
					}
					value = value.replace(val,""); 
				}
				
			}
			
			if(value.match("[+-][0-9]+year")){
				var matches = value.match("[+-][0-9]+year");
				for(var i = 0; i < matches.length; i++){
					var val = matches[i];
					var multiplicator = val.match('[0-9]')[i];
					if(val.substring(0,1)=="+"){//+
						firstDate.setFullYear(firstDate.getFullYear() + multiplicator);
					}else{	//-
						firstDate.setFullYear(firstDate.getFullYear() - multiplicator);
					}
					value = value.replace(val,""); 
				}
			}
			
			value = value.replace(/now/g, now.getTime());
			value = value.replace(/min_begin/g, minBegin.getTime());
			value = value.replace(/hour_begin/g, hourBegin.getTime());
			value = value.replace(/today/g, today.getTime());
			value = value.replace(/yesterday/g, yesterday.getTime());
			value = value.replace(/week_begin/g, weekBegin.getTime());
			value = value.replace(/month_begin/g, monthBegin.getTime());
			value = value.replace(/year_begin/g, yearBegin.getTime());
			
			//kereshetünk ezekre a szavakra mert az öszetettebbek már kiestek
			value = value.replace(/sec/g,"*1000");
			value = value.replace(/min/g,"*"+1000*60);
			value = value.replace(/hour/g,"*"+1000*60*60);
			value = value.replace(/day/g,"*"+1000*60*60*24);
			value = value.replace(/week/g,"*"+1000*60*60*24*7);
			
	//		now-20sec
	//		123456789-20*1000
			
			value = eval(value);

			return value;
		}else 
			return this.getValue();
	},
	
	switchExpression: function(value){
		value = value.replace("PrevYearStart","year_begin-1year");
		value = value.replace("YearStart","year_begin");
		value = value.replace("PrevMonthStart","month_begin-1month");
		value = value.replace("MonthStart","month_begin");
		value = value.replace("PrevWeekStart","week_begin-1week");
		value = value.replace("WeekStart","week_begin");
		value = value.replace("TodayStart","today");
		value = value.replace("YesterdayStart","yesterday");
		value = value.replace("PrevHourStart","hour_begin-1hour");
		value = value.replace("HourStart","hour_begin");
		value = value.replace("PrevMinStart","min_begin-1min");
		value = value.replace("MinStart ","min_begin");
		
		value = value.replace("PrevYearEnd","year_begin");
		value = value.replace("YearEnd","year_begin+1year");
		value = value.replace("PrevMonthEnd","month_begin");
		value = value.replace("MonthEnd","month_begin-1month");
		value = value.replace("PrevWeekEnd","week_begin");
		value = value.replace("WeekEnd","week_begin+1week");
		value = value.replace("TodayEnd","today+1day");
		value = value.replace("YesterdayEnd","today");
		value = value.replace("PrevHourEnd","hour_begin");
		value = value.replace("HourEnd","hour_begin+1hour");
		value = value.replace("PrevMinEnd","min_begin");
		value = value.replace("MinEnd ","min_begin+1min");
		
		return value;
	}
});

// @tag ext-ux
Ext.require('NV.ext.ux.nv.tools.TimeField');
Ext.require('NV.ext.ux.nv.form.DateField');
Ext.require('NV.ext.ux.nv.form.DateTimeField');

Ext.define('NV.ext.ux.nv.form.DateTimeIntervalField', { // path
    
    //extend: 'Ext.panel.Panel',
    extend: 'Ext.form.FieldContainer',
    config : {
		dateTimeFormat : 'Y.m.d H:i:s',
		// maskFormat:'9999.99.99 99:99',
		fieldPosition:'vertical'
	},
	
	constructor:function(config){
		this.initConfig(config);
		this.afterField = Ext.create('NV.ext.ux.nv.form.DateTimeField',{
			dateTimeFormat: this.dateTimeFormat,
			value: config.value?config.value.after:'',
			label:""
		});
		
		this.beforeField = Ext.create('NV.ext.ux.nv.form.DateTimeField',{
			dateTimeFormat: this.dateTimeFormat,
			value: config.value?config.value.before:'',
			label:""
		});
		
		var layout = this.fieldPosition=='vertical'?'vbox':'hbox';
		this.callParent([Ext.apply(this, {
			flex:0,
			layout:{
				type:layout,
				align:"stretch"
			},
			items:[this.afterField, this.beforeField],
			fieldDefaults: {
                labelAlign: 'left',
                labelWidth: 90,
                anchor: '100%'
            }
		})]);
	},
	
	getValue: function(){
		return {
			after: this.afterField.getValue(),
			before: this.beforeField.getValue()
		};
	},
	
	getForceLongValue: function(){
		return {
			after: this.afterField.getForceLongValue(),
			before: this.beforeField.getForceLongValue()
		};
	},
	
	/**
	 * set the values
	 * @param value: {after:"date1", before:"date2"}
	 */
	setValue: function(value){
		this.afterField.setValue(value.after);
		this.beforeField.setValue(value.before);
	},
	
	disable: function(){
		this.afterField.disable();
		this.beforeField.disable();
	},
	
	enable: function(){
		this.afterField.enable();
		this.beforeField.enable();
	},
	
	setReadOnly: function(val){
		this.afterField.setReadOnly(val);
		this.beforeField.setReadOnly(val);
	},
	
	reset: function(){
		this.beforeField.reset();
		this.afterField.reset();
	}
});

// @tag ext-ux
Ext.define('NV.ext.ux.nv.tools.InputTextMask', { // TODO licensz
   constructor: function(mask, clearWhenInvalid) {
      if(clearWhenInvalid === undefined)
         this.clearWhenInvalid = false;
      else
         this.clearWhenInvalid = clearWhenInvalid;
      this.rawMask = mask;
      this.viewMask = '';
      this.maskArray = new Array();
      var mai = 0;
      var regexp = '';
      for(var i=0; i<mask.length; i++){
         if(regexp){
            if(regexp == 'X'){
               regexp = '';
            }
            if(mask.charAt(i) == 'X'){
               this.maskArray[mai] = regexp;
               mai++;
               regexp = '';
            } else {
               regexp += mask.charAt(i);
            }
         } else if(mask.charAt(i) == 'X'){
            regexp += 'X';
            this.viewMask += '_';
            //this.viewMask += String.fromCharCode(160);
         } else if(mask.charAt(i) == '9' || mask.charAt(i) == 'L' || mask.charAt(i) == 'l' || mask.charAt(i) == 'A') {
            this.viewMask += '_';
            //this.viewMask += String.fromCharCode(160);
            this.maskArray[mai] = mask.charAt(i);
            mai++;
         } else {
            this.viewMask += mask.charAt(i);
            this.maskArray[mai] = RegExp.escape(mask.charAt(i));
            mai++;
         }
      }

      this.specialChars = this.viewMask.replace(/(L|l|9|A|_|X)/g,'');
      return this;
   },

   init: function(field) {
      this.field = field;

      if (field.rendered){
         this.assignEl();
      } else {
         field.on('render', this.assignEl, this);
      }

      field.on('blur',this.removeValueWhenInvalid, this);
      field.on('focus',this.processMaskFocus, this);
   },

   assignEl: function() {
      this.inputTextElement = this.field.inputEl.dom;
      this.field.inputEl.on('keypress', this.processKeyPress, this);
      this.field.inputEl.on('keydown', this.processKeyDown, this);
      if(Ext.isSafari || Ext.isIE){
         this.field.inputEl.on('paste',this.startTask,this);
         this.field.inputEl.on('cut',this.startTask,this);
      }
      if(Ext.isGecko || Ext.isOpera){
         this.field.inputEl.on('mousedown',this.setPreviousValue,this);
      }
      if(Ext.isGecko){
        this.field.inputEl.on('input',this.onInput,this);
      }
      if(Ext.isOpera){
        this.field.inputEl.on('input',this.onInputOpera,this);
      }
   },
   onInput: function(){
      this.startTask(false);
   },
   onInputOpera: function(){
      if(!this.prevValueOpera){
         this.startTask(false);
      }else{
         this.manageBackspaceAndDeleteOpera();
      }
   },

   manageBackspaceAndDeleteOpera: function(){
      this.inputTextElement.value=this.prevValueOpera.cursorPos.previousValue;
      this.manageTheText(this.prevValueOpera.keycode,this.prevValueOpera.cursorPos);
      this.prevValueOpera=null;
   },

   setPreviousValue: function(event){
      this.oldCursorPos=this.getCursorPosition();
   },

   getValidatedKey: function(keycode, cursorPosition) {
      var maskKey = this.maskArray[cursorPosition.start];
      if(maskKey == '9'){
         return keycode.pressedKey.match(/[0-9]/);
      } else if(maskKey == 'L'){
         return (keycode.pressedKey.match(/[A-Za-z]/))? keycode.pressedKey.toUpperCase(): null;
      } else if(maskKey == 'l'){
         return (keycode.pressedKey.match(/[A-Za-z]/))? keycode.pressedKey.toLowerCase(): null;
      } else if(maskKey == 'A'){
         return keycode.pressedKey.match(/[A-Za-z0-9]/);
      } else if(maskKey){
         return (keycode.pressedKey.match(new RegExp(maskKey)));
      }
      return(null);
   },

   removeValueWhenInvalid: function() {
      /*if(this.clearWhenInvalid && this.inputTextElement.value.indexOf('_') > -1){
         this.inputTextElement.value = '';
      }*/
   },

   managePaste: function() {
      if(this.oldCursorPos==null){
        return;
      }
      var valuePasted=this.inputTextElement.value.substring(this.oldCursorPos.start,this.inputTextElement.value.length-(this.oldCursorPos.previousValue.length-this.oldCursorPos.end));
      if(this.oldCursorPos.start<this.oldCursorPos.end){
         this.oldCursorPos.previousValue =
            this.oldCursorPos.previousValue.substring(0,this.oldCursorPos.start)+
            this.viewMask.substring(this.oldCursorPos.start,this.oldCursorPos.end)+
            this.oldCursorPos.previousValue.substring(this.oldCursorPos.end,this.oldCursorPos.previousValue.length);
         valuePasted=valuePasted.substr(0,this.oldCursorPos.end-this.oldCursorPos.start);
      }
      this.inputTextElement.value=this.oldCursorPos.previousValue;
      keycode = {
         unicode: '',
         isShiftPressed: false,
         isTab: false,
         isBackspace: false,
         isLeftOrRightArrow: false,
         isDelete: false,
         pressedKey: ''
      }
      var charOk=false;
      for(var i=0;i<valuePasted.length;i++){
         keycode.pressedKey=valuePasted.substr(i,1);
         keycode.unicode=valuePasted.charCodeAt(i);
         this.oldCursorPos=this.skipMaskCharacters(keycode,this.oldCursorPos);
         if(this.oldCursorPos===false){
            break;
         }
         if(this.injectValue(keycode,this.oldCursorPos)){
            charOk=true;
            this.moveCursorToPosition(keycode, this.oldCursorPos);
            this.oldCursorPos.previousValue=this.inputTextElement.value;
            this.oldCursorPos.start=this.oldCursorPos.start+1;
         }
      }
      if(!charOk && this.oldCursorPos!==false){
         this.moveCursorToPosition(null, this.oldCursorPos);
      }
      this.oldCursorPos=null;
   },

   processKeyDown: function(e){
      this.processMaskFormatting(e,'keydown');
   },

   processKeyPress: function(e){
      this.processMaskFormatting(e,'keypress');
   },

   startTask: function(setOldCursor){
      if(this.task==undefined){
         this.task=new Ext.util.DelayedTask(this.managePaste,this);
     }
      if(setOldCursor!== false){
         this.oldCursorPos=this.getCursorPosition();
     }
     this.task.delay(0);
   },

   skipMaskCharacters: function(keycode, cursorPos){
      if(cursorPos.start!=cursorPos.end && (keycode.isDelete || keycode.isBackspace))
         return(cursorPos);
      while(this.specialChars.match(RegExp.escape(this.viewMask.charAt(((keycode.isBackspace)? cursorPos.start-1: cursorPos.start))))){
         if(keycode.isBackspace) {
            cursorPos.dec();
         } else {
            cursorPos.inc();
         }
         if(cursorPos.start >= cursorPos.previousValue.length || cursorPos.start < 0){
            return false;
         }
      }
      return(cursorPos);
   },

   isManagedByKeyDown: function(keycode){
      if(keycode.isDelete || keycode.isBackspace){
         return(true);
      }
      return(false);
   },

   processMaskFormatting: function(e, type) {
      this.oldCursorPos=null;
      var cursorPos = this.getCursorPosition();
      var keycode = this.getKeyCode(e, type);
      if(keycode.unicode==0){//?? sometimes on Safari
         return;
      }
      if((keycode.unicode==67 || keycode.unicode==99) && e.ctrlKey){//Ctrl+c, let's the browser manage it!
         return;
      }
      if((keycode.unicode==88 || keycode.unicode==120) && e.ctrlKey){//Ctrl+x, manage paste
         this.startTask();
         return;
      }
      if((keycode.unicode==86 || keycode.unicode==118) && e.ctrlKey){//Ctrl+v, manage paste....
         this.startTask();
         return;
      }
      if((keycode.isBackspace || keycode.isDelete) && Ext.isOpera){
        this.prevValueOpera={cursorPos: cursorPos, keycode: keycode};
        return;
      }
      if(type=='keydown' && !this.isManagedByKeyDown(keycode)){
         return true;
      }
      if(type=='keypress' && this.isManagedByKeyDown(keycode)){
         return true;
      }
      if(this.handleEventBubble(e, keycode, type)){
         return true;
      }
      return(this.manageTheText(keycode, cursorPos));
   },

   manageTheText: function(keycode, cursorPos){
      if(this.inputTextElement.value.length === 0){
         this.inputTextElement.value = this.viewMask;
      }
      cursorPos=this.skipMaskCharacters(keycode, cursorPos);
      if(cursorPos===false){
         return false;
      }
      if(this.injectValue(keycode, cursorPos)){
         this.moveCursorToPosition(keycode, cursorPos);
      }
      return(false);
   },

   processMaskFocus: function(){
      if(this.inputTextElement.value.length == 0){
         var cursorPos = this.getCursorPosition();
         this.inputTextElement.value = this.viewMask;
         this.moveCursorToPosition(null, cursorPos);
      }
   },

   isManagedByBrowser: function(keyEvent, keycode, type){
      if(((type=='keypress' && keyEvent.charCode===0) ||
         type=='keydown') && (keycode.unicode==Ext.EventObject.TAB ||
         keycode.unicode==Ext.EventObject.RETURN ||
         keycode.unicode==Ext.EventObject.ENTER ||
         keycode.unicode==Ext.EventObject.SHIFT ||
         keycode.unicode==Ext.EventObject.CONTROL ||
         keycode.unicode==Ext.EventObject.ESC ||
         keycode.unicode==Ext.EventObject.PAGEUP ||
         keycode.unicode==Ext.EventObject.PAGEDOWN ||
         keycode.unicode==Ext.EventObject.END ||
         keycode.unicode==Ext.EventObject.HOME ||
         keycode.unicode==Ext.EventObject.LEFT ||
         keycode.unicode==Ext.EventObject.UP ||
         keycode.unicode==Ext.EventObject.RIGHT ||
         keycode.unicode==Ext.EventObject.DOWN)){
            return(true);
      }
      return(false);
   },

   handleEventBubble: function(keyEvent, keycode, type) {
      try {
         if(keycode && this.isManagedByBrowser(keyEvent, keycode, type)){
            return true;
         }
         keyEvent.stopEvent();
         return false;
      } catch(e) {
         alert(e.message);
      }
   },

   getCursorPosition: function() {
      var s, e, r;
      if(this.inputTextElement.createTextRange){
         r = document.selection.createRange().duplicate();
         r.moveEnd('character', this.inputTextElement.value.length);
         if(r.text === ''){
            s = this.inputTextElement.value.length;
         } else {
            s = this.inputTextElement.value.lastIndexOf(r.text);
         }
         r = document.selection.createRange().duplicate();
         r.moveStart('character', -this.inputTextElement.value.length);
         e = r.text.length;
      } else {
         s = this.inputTextElement.selectionStart;
         e = this.inputTextElement.selectionEnd;
      }
      return this.CursorPosition(s, e, r, this.inputTextElement.value);
   },

   moveCursorToPosition: function(keycode, cursorPosition) {
      var p = (!keycode || (keycode && keycode.isBackspace ))? cursorPosition.start: cursorPosition.start + 1;
      if(this.inputTextElement.createTextRange){
         cursorPosition.range.move('character', p);
         cursorPosition.range.select();
      } else {
         this.inputTextElement.selectionStart = p;
         this.inputTextElement.selectionEnd = p;
      }
   },

   injectValue: function(keycode, cursorPosition) {
      if (!keycode.isDelete && keycode.unicode == cursorPosition.previousValue.charCodeAt(cursorPosition.start))
         return true;
      var key;
      if(!keycode.isDelete && !keycode.isBackspace){
         key=this.getValidatedKey(keycode, cursorPosition);
      } else {
         if(cursorPosition.start == cursorPosition.end){
            key='_';
            if(keycode.isBackspace){
               cursorPosition.dec();
            }
         } else {
            key=this.viewMask.substring(cursorPosition.start,cursorPosition.end);
         }
      }
      if(key){
         this.inputTextElement.value = cursorPosition.previousValue.substring(0,cursorPosition.start)
            + key +
            cursorPosition.previousValue.substring(cursorPosition.start + key.length,cursorPosition.previousValue.length);
         return true;
      }
      return false;
   },

   getKeyCode: function(onKeyDownEvent, type) {
      var keycode = {};
      keycode.unicode = onKeyDownEvent.getKey();
      keycode.isShiftPressed = onKeyDownEvent.shiftKey;

      keycode.isDelete = ((onKeyDownEvent.getKey() == Ext.EventObject.DELETE && type=='keydown') || ( type=='keypress' && onKeyDownEvent.charCode===0 && onKeyDownEvent.keyCode == Ext.EventObject.DELETE))? true: false;
      keycode.isTab = (onKeyDownEvent.getKey() == Ext.EventObject.TAB)? true: false;
      keycode.isBackspace = (onKeyDownEvent.getKey() == Ext.EventObject.BACKSPACE)? true: false;
      keycode.isLeftOrRightArrow = (onKeyDownEvent.getKey() == Ext.EventObject.LEFT || onKeyDownEvent.getKey() == Ext.EventObject.RIGHT)? true: false;
      keycode.pressedKey = String.fromCharCode(keycode.unicode);
      return(keycode);
   },

   CursorPosition: function(start, end, range, previousValue) {
      var cursorPosition = {};
      cursorPosition.start = isNaN(start)? 0: start;
      cursorPosition.end = isNaN(end)? 0: end;
      cursorPosition.range = range;
      cursorPosition.previousValue = previousValue;
      cursorPosition.inc = function(){cursorPosition.start++;cursorPosition.end++;};
      cursorPosition.dec = function(){cursorPosition.start--;cursorPosition.end--;};
      return(cursorPosition);
   }
});

Ext.applyIf(RegExp, {
   escape: function(str) {
      return new String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
   }
});

// @tag ext-ux
Ext.require('NV.ext.ux.nv.tools.InputTextMask');

Ext.define('NV.ext.ux.nv.form.TimeStringField' , { // path
    
    extend: 'NV.ext.ux.nv.tools.TimeField',
    alias: 'widget.nvtimefield2',
     initComponent: function()
    {
        Ext.apply(this);
        this.callParent();
    },
    
    getValue: function () {
        return this.getRawValue(); // returns the string value of field
    },
    
    setValue: function (str) {
        if(typeof str !== 'string'){
            this.value = str;
            str1 = Ext.Date.format(str, this.format);
           
            this.setRawValue(str1); 
            return;
        }
        this.setRawValue(str); 
        
    },
    
    isEqual: function(v1, v2) {
        return v1 == v2;
    }
    
});

// @tag ext-ux
/**
 * ListFilterOneSelect is many checkbox, this ComboFilter make the same, but in combobox
 *
 * Example Usage:
 *
 *     var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             type: 'list',
 *             dataIndex: 'size',
 *             phpMode: true,
 *             // options will be used as data to implicitly creates an ArrayStore
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large']
 *         }]
 *     });
 *
 */
Ext.define('NV.ext.ux.nv.grid.filter.ComboFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.combo',
    uses: ['Ext.form.field.ComboBox'],
    
    pickerOpts : {},

    config:{
    	displayField:"label",
    	valueField:"key"
},
    
   
    init : function (config) {

        var pickerCfg, i, j, len, item, cfg, data = [], store, range;
        
        Ext.define('BaseList', {
		    extend:  'Ext.data.Model' ,
		    fields: [
		        {name: this.displayField, type: 'string'},
		        {name: this.valueField,  type: 'string'}
		    ]
		});
        
        this.store = Ext.create('Ext.data.Store', {
		    model: 'BaseList',
		    autoLoad: true,
		    proxy: {
		        type: 'ajax',
		        url: config.url,
		        reader: {
		            type: 'json',
		            root: 'list'
		        }
		    }
		});
        
        pickerCfg = Ext.apply(this.pickerOpts, {
            xtype: 'combo',
            editable: false,
            typeAhead: false,
            store: this.store,
            displayField: this.displayField,
            valueField: this.valueField,
            scope: this,
            listeners: {
                scope: this,
                select: function (combo) { this.onSelect(combo) }
            }
        });
        
        this.menu = Ext.create('Ext.menu.Menu', {
            plain: true,
            items: [
                Ext.apply(pickerCfg, {
                    margin: '2 2 2 2'
                })
            ]
        });
    },
    
    getValue : function () {
        return this.menu.items.items[0].getValue();
    },
    
    setValue : function (value) {
        this.menu.items.items[0].setValue(value);
        this.fireEvent('update', this);
    },

    isActivatable : function () {
        return this.getValue().length > 0;
    },
    
    validateRecord : function (record) {
        var value = this.getValue();
        return value == record.get(this.dataIndex);
    },
    
    getSerialArgs : function () {
        return {type: 'combo', value: this.getValue()};
    },
    
    onSelect: function (c) {
        var t = c.up().parentMenu.activeItem;
        this.getValue();
        this.fireEvent('update', this);
        t.setChecked(true);
    }

});

// @tag ext-ux
/**
 * Filter for date-time columns, one date time is: 2013-10-24 12:36
 * 
 * @aouthor csallaia
 */
Ext.define('NV.ext.ux.nv.grid.filter.DateTimeFieldFilter', {
	extend : 'NV.ext.ux.grid.filter.Filter',
	alias : 'gridfilter.datetimefield',
	uses : [ 'NV.ext.ux.nv.form.DateTimeField', 'Ext.menu.Menu', 'Ext.menu.CheckItem' ],

	afterText : 'After',
	beforeText : 'Before',
	onText : 'On',

	compareMap : {
		before : 'lt',
		after : 'gt',
		on : 'eq'
	},

	dateFormat:'Y.m.d h:i:s',
	
	menuItems : [ 'before', 'after', '-' ],

	menuItemCfgs : {
		selectOnFocus : true,
		width : 125
	},
	
	init : function(config) { // datetimefield
		this.fields = {};
		this.fieldOpts = {};
		var me = this, i, len, item, cfg;

		fieldCfg = Ext.apply(me.fieldOpts, {
			xtype : 'datetimefield',
			overflowX : 'visible',
			dateTimeFormat : me.dateFormat
		});

		for (i = 0, len = me.menuItems.length; i < len; i++) {
			item = me.menuItems[i];
			if (item !== '-') {
				cfg = {
					itemId : 'range-' + item,
					text : me[item + 'Text'],
					menu : Ext.create('Ext.menu.Menu', {
						plain : true,			
						items : [ Ext.apply(fieldCfg, {
							itemId : item,
							margin : '2 2 2 2',
							overflowX : 'visible'
						}) ]
					}),
					listeners : {
						scope : me,
						checkchange : me.onCheckChange,
						render : function(t) {
							
							var dtf = t.menu.items.items[0];
							dtf.on("dateValueChanged", me.onValueChanged, me);
							dtf.on("datePickerShow", me.disableMenuHide, me);
							dtf.on("datePickerHide", me.enableMenuHide, me);
						}
					}
				};
				item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
			}
			me.menu.add(item);			
		}
		
		this.callParent(Ext.apply(config, this));
	},

	disableMenuHide: function(){
		this.menu.addListener("beforehide",function(){
			return false;
		});
		this.menu.parentMenu.addListener("beforehide",function(){
			return false;
		});
		this.menu.items.items[0].addListener("beforehide",function(){
			return false;
		});
		this.menu.items.items[0].menu.addListener("beforehide",function(){
			return false;
		});
	},
	
	enableMenuHide: function(){
		this.menu.events.beforehide = undefined;
		this.menu.parentMenu.events.beforehide = undefined;
		this.menu.items.items[0].events.beforehide = undefined;
		this.menu.items.items[0].menu.events.beforehide = undefined;

	},
	
	onCheckChange : function(item, checked) {
		var me = this, picker = item.menu.items.items[0], itemId = picker.itemId, values = me.values;

		if (checked) {
			values[itemId] = picker.getValue();
		} else {
			delete values[itemId];
		}
		me.setActive(me.isActivatable());
		me.fireEvent('update', me);
	//	this.onMenuSelect(picker, values[itemId]);
	},

	onMenuSelect : function(picker, date) {
		var fields = this.fields, field = this.fields[picker.itemId];

		field.setChecked(true);

		if (field == fields.on) {
			fields.before.setChecked(false, true);
			fields.after.setChecked(false, true);
		} else {
	//		fields.on.setChecked(false, true);
	/*		if (field == fields.after && this.getFieldValue('before') < date) {
				fields.before.setChecked(false, true);
			} else if (field == fields.before && this.getFieldValue('after') > date) {
				fields.after.setChecked(false, true);
			}*/
		}
		this.fireEvent('update', this);

		picker.up('menu').hide();
	},

	validateRecord : function(record) {
		var pickerValue, val = record.get(this.dataIndex);

		if (!Ext.isDate(val)) {
			return false;
		}
		val = val.getTime();

		for (var key in this.fields) {
			if (this.fields[key].checked) {
				pickerValue = this.getFieldValue(key);
				if (key == 'before' && pickerValue <= val) {
					return false;
				}
				if (key == 'after' && pickerValue >= val) {
					return false;
				}
				if (key == 'on' && pickerValue != val) {
					return false;
				}
			}
		}
		return true;
	},

	onValueChanged : function(t, value) {

		this.selectDateEvent(t,value);
		this.menu.addListener("beforehide", function(item,eOpts){
		 //   e.stopEvent();
		});
	},

	setValue : function(value) {
		this.values = value;
		for(var i = 0; i < this.menuItems.length; i++){
			if(this.values[this.menuItems[i]]){
				this.fields[this.menuItems[i]].setChecked(true, true);
				this.fields[this.menuItems[i]].menu.items.items[0].setValue(value[this.menuItems[i]]);
			}
		}
	//	this.fireEvent('update', this);
	//  this.onMenuSelect(t.ownerCt, new Date());
		this.values = value;
		
	},

    selectDateEvent: function (t, value) {   
        if (value !== undefined) {
            this.values[t.itemId] = value;
            this.fireEvent('update', this);
            this.onMenuSelect(t, value);
        }
    },
	
	getFieldValue : function(item) {
		return this.values[item];
	},

	getSerialArgs : function() {
		var args = [];
		for ( var key in this.fields) {
			if (this.fields[key].checked) {
				var value = {
					type : 'datetime',
					comparison : this.compareMap[key],
					value : this.getFieldValue(key)
				};
				args.push(value);
			}
		}
		return args;
	},

	getValue : function() {
		var result = {};
		if(this.active){
			for (var key in this.fields) {
				if (this.fields[key].checked) {
					result[key] = this.getFieldValue(key);
				}
			}
		}
		
		return result;
	},
	isActivatable : function () {
		for (var key in this.fields) {
            if (this.fields[key].checked) {
                return true;
            }
        }
        return false;
    }

});

// @tag ext-ux
/**
 * Like ListFilter, but just one elem can be selected.
 * @author pbeata
 * 
 * Example Usage:
 *
 *     var filters = Ext.create('NV.ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             type: 'listoneselect',
 *             dataIndex: 'size',
 *             phpMode: true,
 *             // options will be used as data to implicitly creates an ArrayStore
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large']
 *         }]
 *     });
 *
 */
Ext.define('NV.ext.ux.nv.grid.filter.ListFilterOneSelect', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.listoneselect',

    /**
     * @cfg {Array} options
     * `data` to be used to implicitly create a data store
     * to back this list when the data source is **local**. If the
     * data for the list is remote, use the {@link #store}
     * config instead.
     *
     * Each item within the provided array may be in one of the
     * following formats:
     *
     *   - **Array** :
     *
     *         options: [
     *             [11, 'extra small'],
     *             [18, 'small'],
     *             [22, 'medium'],
     *             [35, 'large'],
     *             [44, 'extra large']
     *         ]
     *
     *   - **Object** :
     *
     *         labelField: 'name', // override default of 'text'
     *         options: [
     *             {id: 11, name:'extra small'},
     *             {id: 18, name:'small'},
     *             {id: 22, name:'medium'},
     *             {id: 35, name:'large'},
     *             {id: 44, name:'extra large'}
     *         ]
     * 
     *   - **String** :
     *
     *         options: ['extra small', 'small', 'medium', 'large', 'extra large']
     *
     */
    /**
     * @cfg {Boolean} phpMode
     * Adjust the format of this filter. Defaults to false.
     *
     * When GridFilters `@cfg encode = false` (default):
     *
     *     // phpMode == false (default):
     *     filter[0][data][type] list
     *     filter[0][data][value] value1
     *     filter[0][data][value] value2
     *     filter[0][field] prod
     *
     *     // phpMode == true:
     *     filter[0][data][type] list
     *     filter[0][data][value] value1, value2
     *     filter[0][field] prod
     *
     * When GridFilters `@cfg encode = true`:
     *
     *     // phpMode == false (default):
     *     filter : [{"type":"list","value":["small","medium"],"field":"size"}]
     *
     *     // phpMode == true:
     *     filter : [{"type":"list","value":"small,medium","field":"size"}]
     *
     */
    phpMode : false,
    /**
     * @cfg {Ext.data.Store} store
     * The {@link Ext.data.Store} this list should use as its data source
     * when the data source is **remote**. If the data for the list
     * is local, use the {@link #options} config instead.
     */

    /**
     * @private
     * Template method that is to initialize the filter.
     * @param {Object} config
     */
    init : function (config) {
        this.dt = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },

    /**
     * @private @override
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        var menu = Ext.create('NV.ext.ux.nv.grid.menu.ListMenuOneSelect', config);
        menu.on('checkchange', this.onCheckChange, this);
        return menu;
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getSelected();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.menu.setSelected(value);
        this.fireEvent('update', this);
    },

    /**
     * Template method that is to return true if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.getValue().length > 0;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'list', value: this.phpMode ? this.getValue().join(',') : this.getValue()};
    },

    /** @private */
    onCheckChange : function(){
        this.dt.delay(this.updateBuffer);
    },


    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var valuesArray = this.getValue();
        return Ext.Array.indexOf(valuesArray, record.get(this.dataIndex)) > -1;
    }
});

// @tag ext-ux
/**
 * Filter for date-time columns, one date time is: 2013-10-24 12:36
 * @aouthor csallaia
 */
Ext.define('NV.ext.ux.nv.grid.filter.TimeStringFieldFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.tsff',
    uses: ['NV.ext.ux.nv.form.TimeStringField', 'Ext.menu.Menu', 'Ext.menu.CheckItem'],
    
    afterText : 'After',
    beforeText : 'Before',
    onText : 'On',

    compareMap : {
        before: 'lt',
        after:  'gt',
        on:     'eq'
    },

    menuItems : ['before', 'after', '-', 'on'],

    menuItemCfgs : {
        selectOnFocus: true,
        width: 100
    },
    
    fields: {},

    format: 'H:i',
    
    fieldOpts : {},
    
    init : function (config) { // timestringfield
        var me = this, pickerCfg, i, len, item, cfg;
        
        fieldCfg = Ext.apply(me.fieldOpts, {
            xtype: 'nvtimefield2',
            overflowX: 'visible',
            width: 90,
            format:  me.format
        });
        
        fields = {};
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                cfg = {
                    itemId: 'range-' + item,
                    text: me[item + 'Text'],
                    menu: Ext.create('Ext.menu.Menu', {
                        plain: true,
                        
                        items: [
                            Ext.apply(fieldCfg, {
                                itemId: item,
                                minWidth: 80,
                                margin: '2 2 2 2',
                                overflowX: 'visible'
                            })
                        ]
                    }),
                    listeners: {
                        scope: me,
                        checkchange: me.onCheckChange,
                        render: function (t){
                            var tsf = t.menu.items.items[0];
                            tsf.on("specialkey", me.enterKeyEvent, me)
                            tsf.on("select", me.selectDateEvent, me)
                        }
                    }
                };
                item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
            }
            me.menu.add(item);
        }
        me.values = {};
    },
    
    onCheckChange : function (item, checked) {
        var me = this,
            picker = item.menu.items.items[0],
            itemId = picker.itemId,
            values = me.values;

        if (checked) {
            values[itemId] = picker.getValue();
        } else {
            delete values[itemId]
        }
        me.setActive(me.isActivatable());
        me.fireEvent('update', me);
        this.onMenuSelect(picker, values[itemId]);
    },
    
    onMenuSelect : function (picker, date) {
        var fields = this.fields,
            field = this.fields[picker.itemId];

        field.setChecked(true);
        
        // TODO string values to time to compare ?

        if (field == fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field == fields.after && this.getFieldValue('before') < date) {
                fields.before.setChecked(false, true);
            } else if (field == fields.before && this.getFieldValue('after') > date) {
                fields.after.setChecked(false, true);
            }
        }
        this.fireEvent('update', this);

        picker.up('menu').hide();
    },
    
    validateRecord : function (record) {
        var key,
            rv, pv,
            val = record.get(this.dataIndex);
        
        //console.log(val)
        val = this.timeStringToDate(val);

        if(!Ext.isDate(val)){
        	return false;
        }

        for (key in this.fields) {
            if (this.fields[key].checked) {
                
                pv = this.timeStringToDate(this.getFieldValue(key)).getTime(); // picker value
                
                rv = val.getTime(); // record value
                
                if (key == 'before' && rv >= pv) {
                    return false;
                }
                if (key == 'after' && rv <= pv) {
                    return false;
                }
                if (key == 'on' && rv != pv) {
                    return false;
                }
            }
        }
        return true;
    },
    
    timeStringToDate: function (str) {
                
        str = str.replace(".",":");
        var strArray = str.split(":");
        
        var h, i, s, u;
        
        if(this.format.charAt(0)=="H"){
            h = strArray[0];
        } else {
            h = 0;
        }
        
        if(this.format.charAt(2)=="i"){
            i = strArray[1];
        } else {
            i = 0;
        }
        
        if(this.format.charAt(4)=="s"){
            s = strArray[2];
        } else {
            s = 0;
        }
        
        if(this.format.charAt(6)=="u"){
            u = strArray[3];
        } else {
            u = 0;
        }
        
        var d = new Date(0,0,0,h,i,s,u);
        return d;
    },
    
    dateToString: function (d) {
                
        
        var str = "";
        
        var h, i, s, u;
        
        if(this.format.charAt(0)=="H"){
            h = d.getHours();
            if (h < 10){
                h = "0" + h;
            }
            str = str + h;
        }
        
        if(this.format.charAt(1)==":"){
            str = str + ":";
        }
        
        if(this.format.charAt(2)=="i"){
            i = d.getMinutes();
            if (i < 10){
                i = "0" + i;
            }
            str = str + i;
        }
        
        if(this.format.charAt(3)==":"){
            str = str + ":";
        }
        
        if(this.format.charAt(4)=="s"){
            s = d.getSeconds();
            if (s < 10){
                s = "0" + s;
            }
            str = str + s;
        }
        
        if(this.format.charAt(1)=="."){
            str = str + ".";
        }
        
        if(this.format.charAt(6)=="u"){
            u = d.getMilliseconds();
            if (u < 10){
                u = "00" + u;
            } else if (u > 9) {
                u = "0" + u;
            }
            str = str + u;
        }
        
        return str;
    },
    
    enterKeyEvent: function (t, e) {
                
        if(e.getKey() === e.ENTER){
            this.selectDateEvent(t);
        }
    },
    
    setValue: function(value){
    	this.values = value;
   	 	this.fireEvent('update', this);
        //this.onMenuSelect(t.ownerCt, new Date());
        this.values = value;
    },
    
    selectDateEvent: function (t) {
        var format = this.format; // string format
        if (t.getValue() !== undefined) {
//            var date = this.timeStringToDate(t.getValue());
//            this.values[t.itemId] = date;
//            this.fireEvent('update', this);
            
            var date = t.getValue();
            this.values[t.itemId] = date;
            this.fireEvent('update', this);
            this.onMenuSelect(t, date);
        }
       
        if(t.value=="now"){
        	this.values[t.itemId] = t.value;
        	 this.fireEvent('update', this);
        	 var now = new Date();
             this.onMenuSelect(t, this.dateToString(now)); // TODO date to string
             this.values[t.itemId] = t.value;
        }
        
    },
    
    getFieldValue : function(item){
        return this.values[item];
    },
    
    getSerialArgs : function () {
        // TODO ?
        var format = format;
        var args = [];
        for (var key in this.fields) {
            if(this.fields[key].checked){
                var value = {
                        type: 'time',
                        comparison: this.compareMap[key],
                        value: this.getFieldValue(key) // ?
                    };
            	args.push(value);
                if(this.getFieldValue(key)=="now"){
            	    value.value = "now";   
                }
            }
        }
        return args;
    },
    
    getValue : function () {
        // TODO ?
        var key, result = {};
        for (key in this.fields) {
            if (this.fields[key].checked) {
                result[key] = this.getFieldValue(key);
            }
        }
        return result;
    }
    
    
});

// @tag ext-ux
/**
 * Time field filter, time is: "12:35"
 * @author csallaia
 */
Ext.define('NV.ext.ux.nv.grid.filter.TimeStringFilter', {
    extend: 'NV.ext.ux.grid.filter.Filter',
    alias: 'gridfilter.timestring',
    uses: ['NV.ext.ux.nv.form.TimeStringField'],

    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',

    emptyText: '',
    selectOnFocus: true,
    width: 125,

    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) { // még nem pipálja ki, de keresem a megoldást
        Ext.applyIf(config, {
            enableKeyEvents: true,
            labelCls: 'ux-rangemenu-icon ' + this.iconCls,
            hideEmptyLabel: false,
            labelSeparator: '',
            labelWidth: 0,
            listeners: {
                scope: this,
                keyup: this.onInputKeyUp,
                el: {
                    click: function(e) {
                        e.stopPropagation();
                    }
                }
            }
        });

        this.inputItem = Ext.create('NV.ext.ux.nv.form.TimeStringField', config);
        this.inputItem.on('specialkey', function (f, e) {
             if (e.getKey() == e.ENTER) {
                 console.log(this)
                 this.onInputKeyUp(f, e)
             }
        }, this);
        this.inputItem.on('select', function () {
            console.log(this.getValue())
        }, this);
        this.menu.add(this.inputItem);
        this.menu.showSeparator = false;
        this.updateTask = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },

    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        console.log(this.inputItem.getValue())
        return this.inputItem.getValue();
    },

    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.inputItem.setValue(value);
        this.fireEvent('update', this);
    },

    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.inputItem.getValue().length > 0;
    },

    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'string', value: this.getValue()};
    },

    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex);

        if(typeof val != 'string') {
            return (this.getValue().length === 0);
        }

        return val.toLowerCase().indexOf(this.getValue().toLowerCase()) > -1;
    },

    /**
     * @private
     * Handler method called when there is a keyup event on this.inputItem
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN /*&& field.isValid()*/) {
            e.stopEvent();
            this.menu.hide();
            return;
        }
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

// @tag ext-ux
/**
 * This is a supporting class for {@link NV.ext.ux.grid.filter.ListOneSelectFilter}.
 * Although not listed as configuration options for this class, this class
 * also accepts all configuration options from {@link NV.ext.ux.grid.filter.ListFilter}.
 */
Ext.define('NV.ext.ux.nv.grid.menu.ListMenuOneSelect', {
    extend: 'Ext.menu.Menu',
    
    /**
     * @cfg {String} idField
     * Defaults to 'id'.
     */
    idField :  'id',

    /**
     * @cfg {String} labelField
     * Defaults to 'text'.
     */
    labelField :  'text',
    /**
     * @cfg {String} paramPrefix
     * Defaults to 'Loading...'.
     */
    loadingText : 'Loading...',
    /**
     * @cfg {Boolean} loadOnShow
     * Defaults to true.
     */
    loadOnShow : true,
    /**
     * @cfg {Boolean} single
     * Specify true to group all items in this list into a single-select
     * radio button group. Defaults to false.
     */
    single : false,

    plain: true,

    constructor : function (cfg) {
        var me = this,
            options,
            i,
            len,
            value;
            
        me.selected = [];
        me.addEvents(
            /**
             * @event checkchange
             * Fires when there is a change in checked items from this list
             * @param {Object} item Ext.menu.CheckItem
             * @param {Object} checked The checked value that was set
             */
            'checkchange'
        );

        me.callParent([cfg = cfg || {}]);

        if(!cfg.store && cfg.options) {
            options = [];
            for(i = 0, len = cfg.options.length; i < len; i++){
                value = cfg.options[i];
                switch(Ext.type(value)){
                    case 'array':  options.push(value); break;
                    case 'object': options.push([value[me.idField], value[me.labelField]]); break;
                    case 'string': options.push([value, value]); break;
                }
            }

            me.store = Ext.create('Ext.data.ArrayStore', {
                fields: [me.idField, me.labelField],
                data:   options,
                listeners: {
                    load: me.onLoad,
                    scope:  me
                }
            });
            me.loaded = true;
            me.autoStore = true;
        } else {
            me.add({
                text: me.loadingText,
                iconCls: 'loading-indicator'
            });
            me.store.on('load', me.onLoad, me);
        }
    },

    destroy : function () {
        var me = this,
            store = me.store;
            
        if (store) {
            if (me.autoStore) {
                store.destroyStore();
            } else {
                store.un('unload', me.onLoad, me);
            }
        }
        me.callParent();
    },

    /**
     * Lists will initially show a 'loading' item while the data is retrieved from the store.
     * In some cases the loaded data will result in a list that goes off the screen to the
     * right (as placement calculations were done with the loading item). This adapter will
     * allow show to be called with no arguments to show with the previous arguments and
     * thus recalculate the width and potentially hang the menu from the left.
     */
    show : function () {
        var me = this;
        if (me.loadOnShow && !me.loaded && !me.store.loading) {
            me.store.load();
        }
        me.callParent();
    },

    /** @private */
    onLoad : function (store, records) {
        var me = this,
            gid, itemValue, i, len,
            listeners = {
                checkchange: me.checkChange,
                scope: me
            };

        Ext.suspendLayouts();
        me.removeAll(true);
        gid = me.single ? Ext.id() : null;
        for (i = 0, len = records.length; i < len; i++) {
            itemValue = records[i].get(me.idField);
            me.add(Ext.create('Ext.menu.CheckItem', {
                text: records[i].get(me.labelField),
                group: gid,
                checked: Ext.Array.contains(me.selected, itemValue),
                hideOnClick: false,
                value: itemValue,
                listeners: listeners
            }));
        }

        me.loaded = true;
        Ext.resumeLayouts(true);
        me.fireEvent('load', me, records);
    },

    /**
     * Get the selected items.
     * @return {Array} selected
     */
    getSelected : function () {
        return this.selected;
    },

    /** @private */
    setSelected : function (value) {
        value = this.selected = [].concat(value);

        if (this.loaded) {
            this.items.each(function(item){
                item.setChecked(false, true);
          //      for (var i = 0, len = value.length; i < len; i++) {
                    if (item.value == value[0]) {
                        item.setChecked(true, true);
                    }
          //      }
            });
        }
    },

    /**
     * Handler for the 'checkchange' event from an check item in this menu
     * @param {Object} item Ext.menu.CheckItem
     * @param {Object} checked The checked value that was set
     */
    checkChange : function (item, checked) {
        var value = [];
        
        if(checked){
        	value.push(item.value);
        	 this.items.each(function(item2){
        		 if(item2 != item)
             	item2.setChecked(false,false);
             });
        	 
        }else{
        	 this.items.each(function(item){
             	if (item.checked) {
                     value.push(item.value);
                 }
             	if(value.length>1){
             		item.setChecked(false,false);
             	}
             });
        }

        this.selected = value;

        this.fireEvent('checkchange', item, checked);
    }
});

// @tag ext-ux
/*
This file is part of Ext JS 4.2

Copyright (c) 2011-2013 Sencha Inc

Contact:  http://www.sencha.com/contact

GNU General Public License Usage
This file may be used under the terms of the GNU General Public License version 3.0 as
published by the Free Software Foundation and appearing in the file LICENSE included in the
packaging of this file.

Please review the following information to ensure the GNU General Public License version 3.0
requirements will be met: http://www.gnu.org/copyleft/gpl.html.

If you are unsure which license is appropriate for your use, please contact the sales department
at http://www.sencha.com/contact.

Build date: 2013-03-11 22:33:40 (aed16176e68b5e8aa1433452b12805c0ad913836)
*/
// feature idea to enable Ajax loading and then the content
// cache would actually make sense. Should we dictate that they use
// data or support raw html as well?

/**
 * Plugin (ptype = 'rowexpander') that adds the ability to have a Column in a grid which enables
 * a second row body which expands/contracts.  The expand/contract behavior is configurable to react
 * on clicking of the column, double click of the row, and/or hitting enter while a row is selected.
 */
Ext.define('NV.ext.ux.nv.grid.plugin.PlusRowExpander', {
    extend: 'Ext.AbstractPlugin',
    lockableScope: 'normal',
    alias: 'plugin.plusrowexpander',

    getPlusDataUrl : "getdata",
    uniqueIdField: "id",
    parentIdField: "parentId",
    hasChildField: "hasSuppressed",
    
    rowBodyTpl: null,

    /**
     * @cfg {Boolean} expandOnEnter
     * <tt>true</tt> to toggle selected row(s) between expanded/collapsed when the enter
     * key is pressed (defaults to <tt>true</tt>).
     */
    expandOnEnter: true,

    /**
     * @cfg {Boolean} expandOnDblClick
     * <tt>true</tt> to toggle a row between expanded/collapsed when double clicked
     * (defaults to <tt>true</tt>).
     */
    expandOnDblClick: false,

    /**
     * @cfg {Boolean} selectRowOnExpand
     * <tt>true</tt> to select a row when clicking on the expander icon
     * (defaults to <tt>false</tt>).
     */
    selectRowOnExpand: false,

    rowBodyTrSelector: '.x-grid-rowbody-tr',
    rowBodyHiddenCls: 'x-grid-row-body-hidden',
    rowCollapsedCls: 'x-grid-row-collapsed',

    addCollapsedCls: {
        before: function(values, out) {
            var me = this.rowExpander;
            if (!me.recordsExpanded[values.record.internalId]) {
                values.itemClasses.push(me.rowCollapsedCls);
            }
        },
        priority: 500
    },

    /**
     * @event expandbody
     * **Fired through the grid's View**
     * @param {HTMLElement} rowNode The &lt;tr> element which owns the expanded row.
     * @param {Ext.data.Model} record The record providing the data.
     * @param {HTMLElement} expandRow The &lt;tr> element containing the expanded data.
     */
    /**
     * @event collapsebody
     * **Fired through the grid's View.**
     * @param {HTMLElement} rowNode The &lt;tr> element which owns the expanded row.
     * @param {Ext.data.Model} record The record providing the data.
     * @param {HTMLElement} expandRow The &lt;tr> element containing the expanded data.
     */

    setCmp: function(grid) {
        var me = this,
            
            features;

        me.callParent(arguments);

        me.recordsExpanded = {};
       

        features = [{
            ftype: 'rowbody',
            lockableScope: 'normal',
            recordsExpanded: me.recordsExpanded,
            rowBodyHiddenCls: me.rowBodyHiddenCls,
            rowCollapsedCls: me.rowCollapsedCls,
            setupRowData: me.getRowBodyFeatureData,
            getRowBodyContents: function(record) {
              //  return rowBodyTpl.applyTemplate(record.getData());
            }
        },{
            ftype: 'rowwrap',
            lockableScope: 'normal'
        }];
 
        if (grid.features) {
            grid.features = Ext.Array.push(features, grid.features);
        } else {
            grid.features = features;
        }
        // NOTE: features have to be added before init (before Table.initComponent)
    },

    init: function(grid) {
        var me = this,
            reconfigurable = grid,
            lockedView;

        me.callParent(arguments);
        me.grid = grid;
        me.view = grid.getView();
        // Columns have to be added in init (after columns has been used to create the headerCt).
        // Otherwise, shared column configs get corrupted, e.g., if put in the prototype.
        me.addExpander();
        
        // Bind to view for key and mouse events
        // Add row processor which adds collapsed class
        me.bindView(me.view);
        me.view.addRowTpl(me.addCollapsedCls).rowExpander = me;

        // If the owning grid is lockable, then disable row height syncing - we do it here.
        // Also ensure the collapsed class is applied to the locked side by adding a row processor.
        if (grid.ownerLockable) {
            // If our client grid is the normal side of a lockable grid, we listen to its lockable owner's beforereconfigure
            reconfigurable = grid.ownerLockable;
            reconfigurable.syncRowHeight = false;
            lockedView = reconfigurable.lockedGrid.getView();

            // Bind to locked view for key and mouse events
            // Add row processor which adds collapsed class
            me.bindView(lockedView);
            lockedView.addRowTpl(me.addCollapsedCls).rowExpander = me;

            // Refresh row heights of expended rows on the locked (non body containing) side upon lock & unlock.
            // The locked side's expanded rows will collapse back because there's no body there
            reconfigurable.mon(reconfigurable, 'columnschanged', me.refreshRowHeights, me);
            reconfigurable.mon(reconfigurable.store, 'datachanged', me.refreshRowHeights, me);
        }
        reconfigurable.on('beforereconfigure', me.beforeReconfigure, me);
    },
    
    beforeReconfigure: function(grid, store, columns, oldStore, oldColumns) {
        var expander = this.getHeaderConfig();
        expander.locked = true;
        columns.unshift(expander);
    },

    /**
     * @private
     * Inject the expander column into the correct grid.
     * 
     * If we are expanding the normal side of a lockable grid, poke the column into the locked side
     */
    addExpander: function() {
        var me = this,
            expanderGrid = me.grid,
            expanderHeader = me.getHeaderConfig();

        // If this is the normal side of a lockable grid, find the other side.
        if (expanderGrid.ownerLockable) {
            expanderGrid = expanderGrid.ownerLockable.lockedGrid;
            expanderGrid.width += expanderHeader.width;
        }
        expanderGrid.headerCt.insert(0, expanderHeader);
    },

    getRowBodyFeatureData: function(record, idx, rowValues) {
        var me = this
        me.self.prototype.setupRowData.apply(me, arguments);

        // If we are lockable, the expander column is moved into the locked side, so we don't have to span it
        if (!me.grid.ownerLockable) {
            rowValues.rowBodyColspan = rowValues.rowBodyColspan - 1;
        }
        rowValues.rowBody = me.getRowBodyContents(record);
        rowValues.rowBodyCls = me.recordsExpanded[record.internalId] ? '' : me.rowBodyHiddenCls;
    },

    bindView: function(view) {
        if (this.expandOnEnter) {
            view.on('itemkeydown', this.onKeyDown, this);
        }
        if (this.expandOnDblClick) {
            view.on('itemdblclick', this.onDblClick, this);
        }
    },

    onKeyDown: function(view, record, row, rowIdx, e) {
        if (e.getKey() == e.ENTER) {
            var ds   = view.store,
                sels = view.getSelectionModel().getSelection(),
                ln   = sels.length,
                i = 0;

            for (; i < ln; i++) {
                rowIdx = ds.indexOf(sels[i]);
                this.toggleRow(rowIdx, sels[i]);
            }
        }
    },

    onDblClick: function(view, record, row, rowIdx, e) {
        this.toggleRow(rowIdx, record);
    },

    toggleRow: function(rowIdx, record) {
        var me = this,
            view = me.view,
            rowNode = view.getNode(rowIdx),
            row = Ext.fly(rowNode, '_rowExpander'),
            nextBd = row.down(me.rowBodyTrSelector, true),
            isCollapsed = row.hasCls(me.rowCollapsedCls),
            addOrRemoveCls = isCollapsed ? 'removeCls' : 'addCls',
            rowHeight;

        if(isCollapsed){
        	var params = {};
            params[this.uniqueIdField] = record.get(this.uniqueIdField);
            
            Ext.Ajax.request({
            	url: this.getPlusDataUrl,
            	params: params,
            	method:'GET',
            	success: function(response){
            		 this.me.grid.store.insert(this.me.grid.store.indexOf(this.record)+1, Ext.decode(response.responseText).list);
            	},
            	failure: function(response){
            		
            	},
            	scope:{
            		me:me,
            		rowIdx: rowIdx,
            		record: record
            	}
            });
          
        }else{
        	var idsToRemove = [];
        	for(var i=0; i<me.grid.store.count(); i++){
        		if(me.grid.store.getAt(i).get("parentId") == record.get(this.uniqueIdField)){
        			idsToRemove.push(i);
        		}
        	} 
        	
        	for(var i=idsToRemove.length-1; i>=0; i--){
        		me.grid.store.removeAt(idsToRemove[i], 1);
        	}
        	
        }
        
        row[addOrRemoveCls](me.rowCollapsedCls);
        //       Ext.fly(nextBd)[addOrRemoveCls](me.rowBodyHiddenCls);
               me.recordsExpanded[record.internalId] = isCollapsed;
       
        // Suspend layouts because of possible TWO views having their height change
   /*     Ext.suspendLayouts();
        row[addOrRemoveCls](me.rowCollapsedCls);
        Ext.fly(nextBd)[addOrRemoveCls](me.rowBodyHiddenCls);
        me.recordsExpanded[record.internalId] = isCollapsed;
        view.refreshSize();
        view.fireEvent(isCollapsed ? 'expandbody' : 'collapsebody', row.dom, record, nextBd);

        // Sync the height and class of the row on the locked side
        if (me.grid.ownerLockable) {
            view = me.grid.ownerLockable.lockedGrid.view;
            rowHeight = row.getHeight();
            row = Ext.fly(view.getNode(rowIdx), '_rowExpander');
            row.setHeight(rowHeight);
            row[addOrRemoveCls](me.rowCollapsedCls);
            view.refreshSize();
        }
        // Coalesce laying out due to view size changes*/
 //       Ext.resumeLayouts(true);
    },

    // refreshRowHeights often gets called in the middle of some complex processing.
    // For example, it's called on the store's datachanged event, but it must execute
    // *after* other objects interested in datachanged have done their job.
    // Or it's called on column lock/unlock, but that could be just the start of a cross-container
    // drag/drop of column headers which then moves the column into its final place.
    // So this throws execution forwards until the idle event.
    refreshRowHeights: function() {
        Ext.globalEvents.on({
            idle: this.doRefreshRowHeights,
            scope: this,
            single: true
        });
    },

    doRefreshRowHeights: function() {
        var me = this,
            recordsExpanded = me.recordsExpanded,
            key, record,
            lockedView = me.grid.ownerLockable.lockedGrid.view,
            normalView = me.grid.ownerLockable.normalGrid.view,
            normalRow,
            lockedRow,
            lockedHeight,
            normalHeight;

        for (key in recordsExpanded) {
            if (recordsExpanded.hasOwnProperty(key)) {
                record = this.view.store.data.get(key);
                lockedRow = lockedView.getNode(record, false);
                normalRow = normalView.getNode(record, false);
                lockedRow.style.height = normalRow.style.height = '';
                lockedHeight = lockedRow.offsetHeight;
                normalHeight = normalRow.offsetHeight;
                if (normalHeight > lockedHeight) {
                    lockedRow.style.height = normalHeight + 'px';
                } else if (lockedHeight > normalHeight) {
                    normalRow.style.height = lockedHeight + 'px';
                }
            }
        }
    },

    getHeaderConfig: function() {
        var me = this;

        return {
            width: 24,
            lockable: false,
            sortable: false,
            resizable: false,
            draggable: false,
            hideable: false,
            menuDisabled: true,
            tdCls: Ext.baseCSSPrefix + 'grid-cell-special',
            renderer: function(value, metadata, record) {
                // Only has to span 2 rows if it is not in a lockable grid.
                if (!me.grid.ownerLockable) {
                    metadata.tdAttr += ' rowspan="2"';
                }
                if(record.get(me.hasChildField)){
                	 return '<div class="' + Ext.baseCSSPrefix + 'grid-row-expander">&#160;</div>';
                }else if(record.get(me.parentIdField)){
                	 return '<div class="' + Ext.baseCSSPrefix + 'grid-plus-row-expanded">&#160;</div>';
                }else{
                	 return '<div></div>';
                }
               
            },
            processEvent: function(type, view, cell, rowIndex, cellIndex, e, record) {
                if (type == "mousedown" && e.getTarget('.x-grid-row-expander')) {
                    me.toggleRow(rowIndex, record);
                    return me.selectRowOnExpand;
                }
            }
        };
    }
});

// @tag ext-ux
Ext.define('NV.ext.ux.nv.picker.ColorPicker', {
	extend : 'Ext.container.Container',

	config:{
		value:undefined
	},
	
	constructor : function(config) {
		var picker = Ext.create('Ext.picker.Color', {
			listeners: {
		        select: function(picker, selColor) {
		        	this.value = selColor;
		            this.hide();
		        },
		        scope:this
		    }
		});
		
		var textbox = Ext.create('Ext.form.field.Text',{
			value : config.value,
			listeners:{
				specialkey: function(field, e){
                   
                    if (e.getKey() == e.ENTER) {
                    	this.value = field.getValue();
     		            this.hide();
                    }
                },
                scope:this
			}
		});
		this.callParent([ Ext.apply(config,{
			layout : {
				type : 'vbox',
				align : 'stretch'
			},
			floating : true,
			renderTo : Ext.getBody(),
			items: [picker, textbox]
		}) ]);
	}
});

// @tag ext-ux
Ext.define('NV.ext.ux.nv.picker.DateTimePicker',{
	extend:'Ext.picker.Date', 
	config:{
		dateTimeFormat:'Y m d',
		dateTimeField:undefined,
		valueType:"date",
		startDay:1,
		showTime:true,
		showDynamic:true
	},
	constructor: function(config){
		//config.showDynamic = this.showDynamic;
		if(config.dateTimeFormat.match(/h/i)){
			config.showTime = true;
			config.showHour = true;
		}else{
			config.showTime = false;
		}
			//if we have time, need to show the time fields
		config.renderTpl= [
		            '<tpl if="showDynamic">',
		            '<div class="nv-datepicker-header">',
			            '<table width="100%">',
		            		'<tr>',
		            			'<td align="left"><a onclick="{.:this.showCalendar}">Calendar</a></td>',
		            			'<td align="right"><a onclick="{.:this.showExpression}">Expression</a></td>',
		            		'</tr>',
		            	'</table>',
		            '</div>',       
		            '</tpl>',
		            '<div id="{id}-dynamic-innerEl">{%this.renderExpressionEditor(values, out)%}</div>',       
		            '<div id="{id}-innerEl" role="grid" >',
		                '<div role="presentation" class="{baseCls}-header">',
		                     // the href attribute is required for the :hover selector to work in IE6/7/quirks
		                    '<a id="{id}-prevEl" class="{baseCls}-prev {baseCls}-arrow" href="#" role="button" title="{prevText}" hidefocus="on" ></a>',
		                    '<div class="{baseCls}-month" id="{id}-middleBtnEl">{%this.renderMonthBtn(values, out)%}</div>',
		                     // the href attribute is required for the :hover selector to work in IE6/7/quirks
		                    '<a id="{id}-nextEl" class="{baseCls}-next {baseCls}-arrow" href="#" role="button" title="{nextText}" hidefocus="on" ></a>',
		                '</div>',
		                '<table id="{id}-eventEl" class="{baseCls}-inner" cellspacing="0" role="presentation">',
		                    '<thead role="presentation"><tr role="presentation">',
		                        '<tpl for="dayNames">',
		                            '<th role="columnheader" class="{parent.baseCls}-column-header" title="{.}">',
		                                '<div class="{parent.baseCls}-column-header-inner">{.:this.firstInitial}</div>',
		                            '</th>',
		                        '</tpl>',
		                    '</tr></thead>',
		                    '<tbody role="presentation"><tr role="presentation">',
		                        '<tpl for="days">',
		                            '{#:this.isEndOfWeek}',
		                            '<td role="gridcell" id="{[Ext.id()]}">',
		                                // the href attribute is required for the :hover selector to work in IE6/7/quirks
		                                '<a role="presentation" hidefocus="on" class="{parent.baseCls}-date" href="#"></a>',
		                            '</td>',
		                        '</tpl>',
		                    '</tr></tbody>',
		                '</table>',
		                '<tpl if="showTime">',
			                '<table width="100%" ><tr>',
			                	'<tpl if="showHour">',
				                    '<td width="50%"><div id="{id}-footerEl" role="presentation" >{%this.renderHourController(values, out)%}</div></td>',
				                '</tpl>',
				                '<tpl if="showMinute">',
				                    '<td>:</td>',
				                	'<td width="50%" class="minute"><div id="{id}-footerEl" role="presentation" >{%this.renderMinuteController(values, out)%}</div></td>',
				                '</tpl>',
				                '<tpl if="showSecond">',
				                	'<td>:</td>',
				                    '<td width="50%" class="second"><div id="{id}-footerEl" role="presentation" >{%this.renderSecondController(values, out)%}</div></td>',
				                '</tpl>',
			                '</tr></table>',
		                '</tpl>',
		            '</div>',
		            '<div class="{baseCls}-footer"><table width="100%">',
	            		'<tr>',
	            			'<td align="center">{%this.renderOkButton(values, out)%}&nbsp;{%this.renderCancelButton(values, out)%}</td>',
	            			
	            		'</tr>',
	            	'</table></div>',
		            {
		                firstInitial: function(value) {
		                    return Ext.picker.Date.prototype.getDayInitial(value);
		                },
		                isEndOfWeek: function(value) {
		                    // convert from 1 based index to 0 based
		                    // by decrementing value once.
		                    value--;
		                    var end = value % 7 === 0 && value !== 0;
		                    return end ? '</tr><tr role="row">' : '';
		                },
		                renderHourController: function(values, out) {
		                    Ext.DomHelper.generateMarkup(values.$comp.hourField.getRenderTree(), out);
		                },
		                renderMinuteController: function(values, out) {
		                    Ext.DomHelper.generateMarkup(values.$comp.minuteField.getRenderTree(), out);
		                },
		                renderSecondController: function(values, out) {
		                    Ext.DomHelper.generateMarkup(values.$comp.secondField.getRenderTree(), out);
		                },
		                renderMonthBtn: function(values, out) {
		                    Ext.DomHelper.generateMarkup(values.$comp.monthBtn.getRenderTree(), out);
		                },
		                renderOkButton: function(values, out){
		                	Ext.DomHelper.generateMarkup(values.$comp.okButton.getRenderTree(), out);
		                },
		                renderCancelButton: function(values, out){
		                	Ext.DomHelper.generateMarkup(values.$comp.cancelButton.getRenderTree(), out);
		                },
		                renderExpressionEditor: function(values, out){
		                	Ext.DomHelper.generateMarkup(values.$comp.expressionPanel.getRenderTree(), out);
		                },
		                showCalendar: function(values){
		                	return ""+
		                	"try{"+
		                	"	Ext.get('"+this.owner.id+"-dynamic-innerEl').dom.style.display='none';"+
		                    "	Ext.get('"+this.owner.id+"-innerEl').show();"+
		                	"}catch(e){}"+
		                	"Ext.getCmp('"+this.owner.id+"').valueType = 'date'";
		                	
		                },
		                showExpression: function(values){
		                	return ""+
		                	"try{"+
		                	"	Ext.get('"+this.owner.id+"-innerEl').dom.style.display='none';"+
		                    "	Ext.get('"+this.owner.id+"-dynamic-innerEl').show();"+
		                	"}catch(e){}"+
		                	"Ext.getCmp('"+this.owner.id+"').valueType = 'expression'";
		                }
		            }
		        ];
			
		
		
		config.listeners = {
				show:function(){
					if(this.valueType=='date'){
						this.hideExpressionPanel();
					}else{
						this.hideCalendarPanel();
					}
					
					this.el.shadow.hide();
				},
				hide:function(){
					this.dateTimeField.fireEvent("datePickerHide",this);
				},
				scope:this
		};
		this.callParent([config]);
		
		this.expressionField = Ext.create('Ext.form.field.TextArea',{
			fieldLabel:"" ,
			anchor: '100%',
			width:'100%',
			flex:1,
			emptyText: "e.g.: now-10sec"
		});
	},
	
	beforeRender: function(){
		this.callParent();
		
		this.okButton = Ext.create('Ext.button.Button',{
			text:"OK",
			handler:function(){
				this.saveValue();
			},
			scope:this
		});
		
		this.cancelButton = Ext.create('Ext.button.Button',{
			text:"Cancel",
			handler:function(){
				this.hide();
			},
			scope:this
		});
		
		if(this.showTime){			
			this.hourField = Ext.create('Ext.form.field.Number',{
		        name: 'hour',
		        fieldLabel: '',
		        padding:0,
	//	        height:30,
		        value: this.initialValue&&this.initialValue.getHours?this.initialValue.getHours():new Date().getHours(),
		        maxValue: 23,
		        minValue: 0,
		        width:55,
		        flex:1,
		        anchor: '100%',
		        listener: {
		        	change: function(field, newValue, oldValue, eOpts ){
		        		this.initialValue.setHours(newValue);
		        	},
		        	scope:this
		        }
			});
			
			if(this.dateTimeFormat.match(/i/i)){
				this.showMinute=true;
				this.minuteField = Ext.create('Ext.form.field.Number',{
			        name: 'minute',
			        fieldLabel: '',
			        padding:0,
		//	        height:30,
			        value: this.initialValue&&this.initialValue.getMinutes?this.initialValue.getMinutes():new Date().getMinutes(),
			        maxValue: 59,
			        minValue: 0,
			        width:55,
			        flex:1,
			        anchor: '100%',
			        listener: {
			        	change: function(field, newValue, oldValue, eOpts ){
			        		this.initialValue.setMinutes(newValue);
			        	},
			        	scope:this
			        }
				});
			}
			
			if(this.dateTimeFormat.match(/s/i)){
				this.showSecond = true;
				this.secondField = Ext.create('Ext.form.field.Number',{
			        name: 'second',
			        fieldLabel: '',
			        padding:0,
			        value: this.initialValue && this.initialValue.getSeconds?this.initialValue.getSeconds():new Date().getSeconds(),
			        maxValue: 59,
			        minValue: 0,
			        width:55,
			        flex:1,
			        anchor: '100%',
			        listener: {
			        	change: function(field, newValue, oldValue, eOpts ){
			        		this.initialValue.setSeconds(newValue);
			        	},
			        	scope:this
			        }
				});
			}
		}
		
		this.expressionPanel = Ext.create('Ext.panel.Panel',{
			header:false,
			items:[this.expressionField]
		});
		
		Ext.apply(this.renderData, {
			showTime: this.showTime,   
			showHour: this.showHour,  
			showMinute: this.showMinute,   
			showSecond: this.showSecond,
			showDynamic: this.showDynamic
        });
	},
	
	finishRenderChildren: function () {
        this.callParent();
        if (this.showTime) {
        	
        	if(this.hourField) this.hourField.finishRender();
        	if(this.minuteField) this.minuteField.finishRender();
        	if(this.secondField) this.secondField.finishRender();
        }
        this.okButton.finishRender();
        this.cancelButton.finishRender();
    	this.expressionPanel.finishRender();
    },
    
    hideExpressionPanel: function(){
    	try{
    		Ext.get(this.id+'-dynamic-innerEl').dom.style.display='none';
        	Ext.get(this.id+'-innerEl').show();
    	}catch(e){
    		
    	}
    	this.valueType = 'date'
    },
    
    hideCalendarPanel: function(){
    	try{
    		Ext.get(this.id+'-dynamic-innerEl').show();
        	Ext.get(this.id+'-innerEl').dom.style.display='none';
    	}catch(e){
    		
    	}
    	this.valueType = 'expression';
    },
    
    setInitialValue: function(value, isExpression){
    	this.initialValue = Ext.clone(value);
    	if(isExpression){
    		this.valueType = 'expression';
    	}else{
    		this.valueType = 'date';
    	}
    	this.setValue(value, isExpression);
    },
    setValue : function(value, isExpression){
    	
    	if(this.initialValue==undefined){
    		this.initialValue = new Date();
    	}
    	if(!isExpression){
    		this.hideExpressionPanel();
    		this.value = Ext.Date.clearTime(value, true);
            try{
                this.hourField.setValue(this.initialValue.getHours());
                this.minuteField.setValue(this.initialValue.getMinutes());
                this.secondField.setValue(this.initialValue.getSeconds());
            }catch(e){
            	
            }
            return this.update(this.value);
    	}else{//kifejezéssel van dolgunk
    		this.hideCalendarPanel();
    		this.expressionField.setValue(value);
   // 		this.value=value;
    	}
    	
    },
    
    saveValue : function(){
    	if(this.valueType=="date"){
    		try{
    			this.value.setHours(this.hourField.getValue());
    			
    		}catch(e){
    			this.value.setHours(0);
    			
    		}
    		try{
    			
    			this.value.setMinutes(this.minuteField.getValue());
    		}catch(e){
    			this.value.setMinutes(0);
    		}
    		try{
            	this.value.setSeconds(this.secondField.getValue());
    		}catch(e){
    			
            	this.value.setSeconds(0);
    		}
        	
        	this.dateTimeField.setValue(this.value);
    	}else{
    		this.dateTimeField.setValue(this.expressionField.getValue());
    	}
    	
    	this.hide();
    }
});

Ext.ClassManager.addNameAliasMappings({
  "NV.ext.ux.grid.filter.DateFilter": [
    "gridfilter.date"
  ],
  "BaseList": [],
  "NV.ext.ux.data.reader.DynamicReader": [
    "reader.dynamicReader"
  ],
  "NV.ext.ux.nv.tools.TimeField": [
    "widget.nvtimefield"
  ],
  "NV.ext.ux.grid.filter.Filter": [],
  "NV.ext.ux.nv.grid.filter.TimeStringFilter": [
    "gridfilter.timestring"
  ],
  "NV.ext.ux.nv.calendar.CalendarField": [
    "widget.calendar"
  ],
  "NV.ext.ux.form.MultiSelect": [
    "widget.multiselectfield",
    "widget.multiselect"
  ],
  "NV.ext.ux.nv.form.ColorField": [
    "widget.colorfield"
  ],
  "NV.ext.ux.form.ItemSelector": [
    "widget.itemselectorfield",
    "widget.itemselector"
  ],
  "NV.ext.ux.grid.filter.ListFilter": [
    "gridfilter.list"
  ],
  "NV.ext.ux.nv.form.DateField": [
    "widget.nvdatefield"
  ],
  "NV.ext.ux.grid.menu.ListMenu": [],
  "NV.ext.ux.grid.menu.RangeMenu": [],
  "NV.ext.ux.data.PagingMemoryProxy": [
    "proxy.pagingmemory"
  ],
  "NV.ext.ux.grid.FiltersFeature": [
    "feature.filters"
  ],
  "NV.ext.ux.grid.filter.NumericFilter": [
    "gridfilter.numeric"
  ],
  "NV.ext.ux.layout.Center": [
    "layout.ux.center"
  ],
  "NV.ext.ux.nv.grid.filter.TimeStringFieldFilter": [
    "gridfilter.tsff"
  ],
  "NV.ext.ux.grid.DynamicGrid": [
    "widget.dynamicGrid"
  ],
  "NV.ext.ux.grid.filter.StringFilter": [
    "gridfilter.string"
  ],
  "NV.ext.ux.nv.grid.plugin.PlusRowExpander": [
    "plugin.plusrowexpander"
  ],
  "NV.ext.ux.nv.picker.DateTimePicker": [],
  "NV.ext.ux.DataTip": [
    "plugin.datatip"
  ],
  "NV.ext.ux.nv.form.DateTimeField": [
    "widget.datetimefield"
  ],
  "NV.ext.ux.nv.grid.filter.ComboFilter": [
    "gridfilter.combo"
  ],
  "NV.ext.ux.grid.filter.DateTimeFilter": [
    "gridfilter.datetime"
  ],
  "NV.ext.ux.IFrame": [
    "widget.uxiframe"
  ],
  "NV.ext.ux.nv.GlobalErrorHandler": [
    "globalErrorHandler"
  ],
  "NV.ext.ux.nv.form.DateTimeIntervalField": [],
  "NV.ext.ux.nv.grid.menu.ListMenuOneSelect": [],
  "NV.ext.ux.grid.filter.BooleanFilter": [
    "gridfilter.boolean"
  ],
  "NV.ext.ux.nv.picker.ColorPicker": [],
  "NV.ext.ux.nv.grid.filter.DateTimeFieldFilter": [
    "gridfilter.datetimefield"
  ],
  "NV.ext.ux.nv.form.TimeStringField": [
    "widget.nvtimefield2"
  ],
  "NV.ext.ux.nv.grid.filter.ListFilterOneSelect": [
    "gridfilter.listoneselect"
  ],
  "NV.ext.ux.nv.tools.InputTextMask": []
});