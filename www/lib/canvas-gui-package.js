/**
 * @author Be?ta Pletscher
 * @docauthor Be?ta Pletscher
 */

/*
 * This file is the Entry Point for the implementation of this ExtJS package.
 * 
 * NOTE: Please DO NOT edit this file unless you know what you are exactly
 * doing.
 */

// BEGIN: Package definition
(function(){
	{
		var pkg =
		{
		  name : 'canvas-gui',
		  namespace : 'NV.canvas.gui',
		  path : 'canvas-gui',
		  date : new Date('2015','01','09','09','56','33'), // 2015/01/09 09:56:33
		  version : new Ext.Version('1.0.0.53'),
		  description : 'Canvas GUI Library'
		};
	
		// Register Package
	
		Ext.namespace( 'NV' );
		var packages = NV.$Packages || (NV.$Packages = {});
		packages[pkg.name] = pkg;
	
		Ext.Loader.setPath( pkg.namespace, 'lib/' + pkg.path );
	}
})();
// END: Package definition
// @tag canvas-gui
                                                          
Ext.define("NV.canvas.gui.actions.NodeIconChanger",{
	extend:  NV.dashboard.actionhandler.DashboardAction ,
	
	createContent: function(){
		this.scope.equipment.type = this.params.type;
		this.scope.equipment.draw();
	}
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.func.Functions',{
	singleton:true,
	getLighterColor: function(hexaColor){
		var numberString = "";
		if(hexaColor.hex){
			numberString = hexaColor.hex.substring(1);
		}else{
			numberString = hexaColor.substring(1);
		}
		
		var lighterColor = "#";
		for(var i = 0; i<numberString.length; i++){
			yourNumber = parseInt(numberString[i], 16);
			yourNumber+=2;
			if(yourNumber>=16){
				yourNumber-=2;
			}
			lighterColor += yourNumber.toString(16);
		}
		return {
			hex: lighterColor,
			opacity: 0.6
		}
	}
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.model.TopologyModel',{
    extend:  Ext.data.Model ,
    
    fields: [
             {name: 'totalRefresh',  type: 'boolean', defaultValue: false},
             {name: 'partialRefresh',  type: 'boolean', defaultValue: false},
             {name: 'nodeRefresh',  type: 'boolean', defaultValue: false},
             {name: 'statusRefresh',  type: 'boolean', defaultValue: false},
             
             {name: 'showStatus',  type: 'boolean', defaultValue: false},
            
             {name: 'totalRefreshIntervall',  type: 'number', defaultValue: 300},
             {name: 'partialRefreshIntervall',  type: 'number', defaultValue: 30},
             {name: 'nodeRefreshIntervall',  type: 'number', defaultValue: 30},
             {name: 'statusRefreshIntervall',  type: 'number', defaultValue: 30},

	    	{name: 'colorMap', defaultValue:
	    		{
	    		labelColor: {
	    			hex: "#323232",
	    			opacity: 1
	    		},
	    	    bgColor: {
	    	    	hex: "#FFFFFF",
	    	    	opacity: 0.6
	    	    },
	    	    origBgColor: {
	    	    	hex: "#FFFFFF",
	    	    	opacity: 0.5
	    	    },
	    	    bgColorHover: {
	    	    	hex: "#FF961E",
	    	    	opacity: 0.8
	    	    },
	    	    bgColorHoverLight: {
	    	    	hex: "#FFDC96",
	    	    	opacity: 0.7
	    	    },
	    	    bgColorActive: {
	    	    	hex: "#FF821E",
	    	    	opacity: 0.8
	    	    },
	    	    maskColor: {
	    	    	hex: "#FFFFFF",
	    	    	opacity: 0.75
	    	    }
	    	}},
	    	
            {name: 'url', type: 'string'},
            {name: 'extraDataUrl', type: 'string'},
            {name: 'saveUrl', type:'string'},
            {name: 'imageUrl', type:'string'},
            {name: 'actions', defaultValue:null},
            {name: 'rules', defaultValue: null},
            {name: 'iconWidth', type:'number', defaultValue:30},
            {name: 'iconHeight', type:'number', defaultValue:30},
            {name: 'navigatorVisible', defaultValue:false},
            {name: 'toolBarVisible', defaultValue:true},
            {name: 'statusConfig', defaultValue:null, useNull:true},
            {name: 'saveButtonVisible', defaultValue:false},
            {name: 'navigatorButtonVisible', defaultValue:false},
            {name: 'background', defaultvalue:{
            	image:undefined,
            	x:0,
            	y:0,
            	width:0,
            	height:0
            }},
            {name:'editable', type:'boolean', defaultValue:true},
            {name:'moveable', type:'boolean', defaultValue:true}
            
         ]
});

// @tag canvas-gui
/*
 * mouseEvents.js
 *
 * Copyright (C) 2010 NETvisor Ltd. All rights reserved.
 * http://www.netvisor.hu/
 */

//Get Mouse Position X for an Event
getMouseX= function(e) { 
	if(!e) e = window.event; //works on IE, but not NS 
	if(e){ 
		if(e.pageX || e.pageY){ //works on FF, Moz, Opera7 but not IE6 
			return e.pageX; 
		}
		else if(e.clientX || e.clientY){ //works on IE6, FF, Moz, Opera7 
			return e.clientX + document.body.scrollLeft; 
		} 
	} 
}

//Get Mouse Position Y for an Event
 getMouseY= function(e) { 
	if(!e) e = window.event; //works on IE, but not NS 
	if(e){ 
		if(e.pageX || e.pageY){ //works on FF, Moz, Opera7 but not IE6 
			return e.pageY; 
		}
		else if(e.clientX || e.clientY){ //works on IE6, FF, Moz, Opera7 
			return e.clientY + document.body.scrollTop; 
		} 
	} 
}

//Get Mouse Positions (X and Y) for an Event
 getMouseXY= function(e) { 
	var mousePosition = [];
	if(!e) e = window.event; //works on IE, but not NS 
	if(e){ 
		if(e.pageX || e.pageY){ //works on FF, Moz, Opera7 but not IE6 
			mousePosition[0] = e.pageX;
			mousePosition[1] = e.pageY;
			return mousePosition; 
		}
		else if(e.clientX || e.clientY){ //works on IE6, FF, Moz, Opera7 
			mousePosition[0] = e.clientX + document.body.scrollLeft;
			mousePosition[1] = e.clientY + document.body.scrollTop;
			return mousePosition;
		} 
	} 
}

//Get Mouse Relative Positions (X and Y) for an Event
 getMouseRelXY= function(e) { 
	var mousePosition = [];
	if(!e) e = window.event; //works on IE, but not NS 
	if(e){ 
		if(e.pageX || e.pageY){ //works on FF, Moz, Opera7 but not IE6 
			mousePosition[0] = e.pageX - document.body.scrollLeft;
			mousePosition[1] = e.pageY - document.body.scrollTop;
			return mousePosition; 
		}
		else if(e.clientX || e.clientY){ //works on IE6, FF, Moz, Opera7 
			mousePosition[0] = e.clientX;
			mousePosition[1] = e.clientY;
			return mousePosition;
		} 
	} 
}

//Get Mouse Button for an Event
 getMouseButton= function(e) {
	var button;
	if(e.which == null) //IE case
		button = (e.button < 2) ? "LEFT" :
			((e.button == 4) ? "MIDDLE" : "RIGHT");
	else //All others
		button = (e.which < 2) ? "LEFT" :
		    ((e.which == 2) ? "MIDDLE" : "RIGHT");
    return button;
}

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.FloatingStatusWindow', {
	extend:  Ext.window.Window ,
	config:{	    
	    paper: undefined,
	    canvasMargin: 10
	},
	
	constructor: function(config){
		Ext.apply(config, {
				width:200,
			    height:180,
			    title: "Status",
			    resizable:false,
			    closable:false,
			    cls: 'NavigatorWindow',
			    layout:'fit',
			    items:[
			           {
			        	   xtype:'container',
			        	   flex:1
			           }
			          ],
			    listeners : {
						
						scope:this
				}
		});
	
		this.initConfig(config);
		this.callParent([ config ]);
		
		
	}
	
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.Graph',{
	          
	                                        
	            
	config:{
		nodes: undefined,
	    connections: undefined,
	    paper: undefined,
	    zoomableSurface: undefined,
	    model: undefined,
	    actions:undefined,
	    rules: {},
	    portletContent: undefined,
	    statusConfig: undefined,
	    background: undefined,
	    editable: true
	},
	
	constructor: function(config){
		this.initConfig(config);
		this.paper = this.zoomableSurface.paper;
		this.zoomableSurface.graph = this;
		this.nodeMap = {};
		this.containerMap = {};
		this.connectionsMap = {};
		if(!this.paper){
			Ext.Msg.alert("Graph init error", "No paper defined!");
			return;
		}
	},
	
	/**
	 * refresh the existing graph, not every parameter
	 */
	refreshGraph: function(data){

		if(data.containers){
			for( var i = 0; i<data.containers.length; i++){
				if(this.containerMap[data.containers[i].id]){
					
					var updateData = Ext.apply(data.containers[i],{
						iconImage : data.containers[i].icon,
						minWidth: data.containers[i].width,
			        	minHeight: data.containers[i].height
					});
					delete updateData.icon;
					
					Ext.apply(this.containerMap[data.containers[i].id],updateData);
					Ext.apply(this.containerMap[data.containers[i].id].parameters, data.containers[i]);
					if(this.model.get('statusConfig')){
						this.containerMap[data.containers[i].id].statusChart = this.model.get('statusConfig');
					}
					this.containerMap[data.containers[i].id].redraw();
				}else{
					this.containerMap[data.containers[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Container',
							Ext.apply(data.containers[i],{
						        	paper: this.paper,
						        	graph: this,
						        	iconImage : data.containers[i].icon,
						        	parameters: Ext.clone(data.containers[i]),
						        	zoomableSurface: this.zoomableSurface,
						        	minWidth: data.containers[i].width,
						        	minHeight: data.containers[i].height,
							        statusChart: this.model.get('statusConfig'),
							        statusRefresh: this.model.get('autoStatusRefresh'),
									statusRefreshTime: this.model.get('statusRefreshIntervall')
								}));
							this.containerLayer.push(this.containerMap[data.containers[i].id].container);
							this.addActionsToContainer(this.containerMap[data.containers[i].id]);
				}
				
				
			}
		}
		if(data.nodes){
			for (var i = 0; i < data.nodes.length; i++) {
				
				if(data.nodes[i].containerId!=undefined && !this.containerMap[data.nodes[i].containerId]){
					Ext.Msg.alert("Warning","Missing container: "+data.nodes[i].containerId);
				}
				
				//exist node
				if(this.nodeMap[data.nodes[i].id]){
					
					Ext.apply(this.nodeMap[data.nodes[i].id].parameters, data.nodes[i]);
					
					if(data.nodes[i].label){
						data.nodes[i].label = data.nodes[i].name;
					}
					
					if(data.nodes[i].iconImage){
						data.nodes[i].iconImage = data.nodes[i].icon;
					}

					Ext.apply(this.nodeMap[data.nodes[i].id], data.nodes[i]);
					
					
					if(this.model.get('statusConfig')){
						this.nodeMap[data.nodes[i].id].statusChart = this.model.get('statusConfig');
					}				
					this.nodeMap[data.nodes[i].id].draw();
				}else{//new node
					this.nodeMap[data.nodes[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Node',Ext.apply(data.nodes[i],{
						label: data.nodes[i].name,
				        parameters: Ext.clone(data.nodes[i]),
				        paper: this.paper,
				        isMoveable: true,
				        defWidth: this.model.get("iconWidth"),
				        defHeight: this.model.get("iconHeight"),
				        topologyModel: this.model,
				        iconImage : data.nodes[i].icon,
				        zoomableSurface: this.zoomableSurface,
				        graph: this,
				        container: this.containerMap[data.nodes[i].containerId],
				        statusChart: this.model.get('statusConfig'),
				        statusRefresh: this.model.get('autoStatusRefresh'),
						statusRefreshTime: this.model.get('statusRefreshIntervall'),
						rules:this.rules.node
					}));
					this.addActionsToNode(this.nodeMap[data.nodes[i].id]);					
				}	
			}
		}
		if(data.nodes || data.containers){
			for(var i in this.containerMap){
				this.containerMap[i].redraw();
			}
		}
		
		if(data.connections){
			for( var i = 0; i<data.connections.length; i++){
				if(this.connectionsMap[data.connections[i].id]){
					Ext.apply(this.connectionsMap[data.connections[i].id],data.connections[i]);
					this.connectionsMap[data.connections[i].id].redraw();
				}
				else{
					this.connectionsMap[data.connections[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Connection',Ext.apply(data.connections[i],{
						anode: this.nodeMap[data.connections[i].AId],
						znode: this.nodeMap[data.connections[i].ZId],
						paper: this.paper,
						parameters: Ext.clone(data.connections[i]),
						 zoomableSurface: this.zoomableSurface
					}));
				}
			}
		}
	},
	
	loadGraph: function(data){
		
		this.clear();
		
		if(!data.nodes){
		//	Ext.Msg.alert("Load error","Empty graph");
		
			return;
		}
    	
		//add containers
		if(data.containers){
			this.containerLayer = this.paper.set();
			
			for( var i = 0; i<data.containers.length; i++){
				this.containerMap[data.containers[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Container',
				Ext.apply(data.containers[i],{
						editable:this.editable,
			        	paper: this.paper,
			        	graph: this,
			        	iconImage : data.containers[i].icon,
			        	parameters: Ext.clone(data.containers[i]),
			        	zoomableSurface: this.zoomableSurface,
			        	minWidth: data.containers[i].width,
			        	minHeight: data.containers[i].height,
				        statusChart: this.model.get('statusConfig'),
				        statusRefresh: this.model.get('autoStatusRefresh'),
						statusRefreshTime: this.model.get('statusRefreshIntervall')
					}));
				
				this.containerLayer.push(this.containerMap[data.containers[i].id].container);
				
			}
		}		
		//add nodes
		for (var i = 0; i < data.nodes.length; i++) {
			
			if(data.nodes[i].containerId!=undefined && !this.containerMap[data.nodes[i].containerId]){
				Ext.Msg.alert("Warning","Missing container: "+data.nodes[i].containerId);
			}
			
			this.nodeMap[data.nodes[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Node',Ext.apply(data.nodes[i],{
				label: data.nodes[i].name,
		        parameters: Ext.clone(data.nodes[i]),
		        paper: this.paper,
		        defWidth: this.model.get("iconWidth"),
		        defHeight: this.model.get("iconHeight"),
		        topologyModel: this.model,
		        iconImage : data.nodes[i].icon,
		        zoomableSurface: this.zoomableSurface,
		        graph: this,
		        container: this.containerMap[data.nodes[i].containerId],
		        statusChart: this.model.get('statusConfig'),
		        statusRefresh: this.model.get('autoStatusRefresh'),
				statusRefreshTime: this.model.get('statusRefreshIntervall'),
				rules:this.rules.node,
				editable:this.editable
			}));			
		}
	
		
		//add connections
		if(data.connections){
			var uniqueConnId = 0;
			for( var i = 0; i<data.connections.length; i++){
				if(!data.connections[i].id){
					data.connections[i].id=uniqueConnId++;
				}
				this.connectionsMap[data.connections[i].id] = Ext.create('NV.canvas.gui.raphael.shapes.Connection',Ext.apply(data.connections[i],{
					anode: this.nodeMap[data.connections[i].AId],
					znode: this.nodeMap[data.connections[i].ZId],
					paper: this.paper,
					parameters: Ext.clone(data.connections[i]),
					zoomableSurface: this.zoomableSurface,
					editable: this.editable
				}));
			}
		}
		
		//update connections
		for(var i in this.connectionsMap){
			this.connectionsMap[i].redraw();
		}
	
		
		//update containers
		for(var i in this.containerMap){
			this.containerMap[i].redraw(true);
		}
		
		for(var i  in this.containerMap){
			if(this.containerMap[i].containerId){
				if(!this.containerMap[this.containerMap[i].containerId]){
					Ext.Msg.alert("Warning","Missing container: "+this.containerMap[i].containerId);
				}else if(this.containerMap[this.containerMap[i].containerId]== this.containerMap[i]){
					Ext.Msg.alert("Warning","Recursive container reference: "+this.containerMap[i].containerId);
				}else{
					//*pl: abc container containerID-ja: 1, az abc benne van valamiben :)
					var actualContainer = this.containerMap[i];
					actualContainer.parentContainer =  this.containerMap[actualContainer.containerId];
					this.containerMap[actualContainer.containerId].containers.push(this.containerMap[i]);
				}
			}
		}
		
		//update containers
		for(var i in this.containerMap){
			this.containerMap[i].redraw();
		}
		
		
		//add actions to nodes
		if(this.actions && this.actions.node){
			for(var e in this.nodeMap){
				this.addActionsToNode(this.nodeMap[e]);
				this.nodeMap[e].draw();
			}
		}
		
		
		//add actions to containers
		if(this.actions && this.actions.container){
			for(var e in this.containerMap){
				this.addActionsToContainer(this.containerMap[e]);
				this.containerMap[e].redraw();
			}
		}
		this.zoomableSurface.setNodeMap(this.nodeMap);
		this.zoomableSurface.setConnectionsMap(this.connectionsMap);
		this.refreshNavigator();
		this.zoomableSurface.moveNavigatorToRight();		

		
	},
	
	addActionsToNode: function(node){
		if(!this.actions){
			return;
		}
		for(var i=0; i<this.actions.node.length; i++){		
			var	callback = function(evt, x, y){
				
				this.eventType = evt.type;
				if((evt.type=="mousedown"  || evt.type=="mouseover") && evt.button!=0){
					this.eventType = 'rightclick'; 
				}else if(evt.type=="mousedown"){//
					return;
				}		
			
				if(this.action.eventType==this.eventType || (this.action.eventType==undefined && this.eventType=='click')){
					
					var action = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
						action: this.action,
						context:"this.scope.equipment.parameters",
						scope: this,
						portletContentObject: this.portletContent,
						event:evt
					});
					action.doAction();
					if(this.portletContent){
						this.portletContent.model.endEdit();
					}
				}
				evt.stopPropagation();
			};

			if(this.actions.node[i].eventType==undefined || this.actions.node[i].eventType=='click'){
				node.addHandler('click',callback, {
					action: this.actions.node[i],
					equipment: node,
					portletContent: this.portletContent,
					eventType:"click"
				});
			}
			if(this.actions.node[i].eventType=='rightclick'){
			node.addHandler('rightclick',callback, {
					action: this.actions.node[i],
					equipment: node,
					portletContent: this.portletContent,
					eventType:"rightclick"
				});
			}
			if(this.actions.node[i].eventType=='dblclick'){
			node.addHandler('dblclick',callback, {
					action: this.actions.node[i],
					equipment: node,
					portletContent: this.portletContent,
					eventType:"dblclick"
				});
			}
			if(this.actions.node[i].eventType=='mouseover'){
				/*mouseover - tooltip combo esetén léte kell hozni a 
				 * tooltip-et az elemre, mert egyébként nem működik rendesen
				*/
				
				if(this.actions.node[i].command=='tooltip'){
					node.createTooltip(this.actions.node[i], this.portletContent)
				}else{
					node.addHandler('mouseover',callback, {
						action: this.actions.node[i],
						equipment: node,
						portletContent: this.portletContent,
						eventType:"mouseover"
					});
				}
				
			}
			if(this.actions.node[i].eventType=='mouseout'){
				node.addHandler('mouseout',callback, {
					action: this.actions.node[i],
					equipment: node,
					portletContent: this.portletContent,
					eventType:"mouseout"
				});
			}
			
		}
	},
	
	addActionsToContainer: function(container){
		for(var i=0; i<this.actions.container.length; i++){		
			var	callback = function(evt, x, y){
				
				this.eventType = evt.type;
				if((evt.type=="mousedown"  || evt.type=="mouseover") && evt.button!=0){
					this.eventType = 'rightclick'; 
				}else if(evt.type=="mousedown"){//
					return;
				}		
				if(this.action.eventType==this.eventType || (this.action.eventType==undefined && this.eventType=='click')){
					
					var action = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
						action: this.action,
						context:"this.scope.equipment.parameters",
						scope: this,
						portletContentObject: this.portletContent,
						event:evt
					});
					action.doAction();
					if(this.portletContent){
						this.portletContent.model.endEdit();
					}
				}									
			};
			if(this.actions.node[i].eventType==undefined || this.actions.container[i].eventType=='click'){
				container.addHandler('click',callback, {
						action: this.actions.container[i],
						equipment: container,
						portletContent: this.portletContent,
						eventType:"click"
					});
			}
			if(this.actions.container[i].eventType=='rightclick'){
				container.addHandler('rightclick',callback, {
						action: this.actions.container[i],
						equipment: container,
						portletContent: this.portletContent,
						eventType:"rightclick"
					});
			}
			if(this.actions.container[i].eventType=='dblclick'){
				container.addHandler('dblclick',callback, {
						action: this.actions.container[i],
						equipment: container,
						portletContent: this.portletContent,
						eventType:"dblclick"
					});
			}
			if(this.actions.container[i].eventType=='mouseover'){
				container.addHandler('mouseover',callback, {
					action: this.actions.container[i],
					equipment: container,
					portletContent: this.portletContent,
					eventType:"mouseover"
				});
			}
		}
	},
	
	zoomIn: function(ratio){
		for(var e in this.nodeMap){			
			this.nodeMap[e].zoomInGraph(ratio);
		}
		for(var e in this.connectionsMap){
			this.connectionsMap[e].zoomGraph();
		}
	},
	
	zoomOut: function(ratio){
		for(var e in this.nodeMap){			
			this.nodeMap[e].zoomOutGraph(ratio);
		}
		for(var e in this.connectionsMap){
			this.connectionsMap[e].zoomGraph();
		}
	},
	
	saveGraph: function(){
		var json = {
				containers:[],
				nodes:[],
				connections:[]
		};
		for(var i in this.containerMap){
			json.containers.push(this.containerMap[i].getConfig());
		}
		for(var i in this.nodeMap){
			json.nodes.push(this.nodeMap[i].getConfig());
		}
		for(var i in this.connectionsMap){
			json.connections.push(this.connectionsMap[i].getConfig());
		}
		return json;
	},
	
	refreshNavigator: function(){
		this.zoomableSurface.refreshNavigator(this.nodeMap, this.connectionsMap);
	},
	
	clear: function(){
		this.nodeMap = {};
		this.containerMap = {};
		this.connectionsMap = {};
		this.paper.clear();
		if(this.background.image){
			this.bgImage =this.paper.image(this.background.image, this.background.x, this.background.y, this.background.width, this.background.height);
			this.bgImage.toBack();
		}
	}
});

// @tag canvas-gui
/*
 * SurfaceNavigator.js
 *
 * Copyright (C) 2010 NETvisor Ltd. All rights reserved.
 * http://www.netvisor.hu/
 */

Ext.define('NV.canvas.gui.raphael.NavigatorWindow', {
	extend:  Ext.window.Window ,
	config:{	    
	    paper: undefined,
	    canvasMargin: 0,
	    nodeSize:1
	},
	
	constructor: function(config){
		Ext.apply(config, {
				width:200,
			    height:180,
			    title: "Mini map",
			    resizable:false,
			    closable:false,
			    cls: 'NavigatorWindow',
			    layout:'fit',
			    items:[
			           {
			        	   xtype:'container',
			        	   flex:1
			           }
			           ],
			    listeners : {
						afterrender: function(component){
							this.paper = Raphael(component.items.items[0].id, "100%","100%");			
							var me = this;
							try{
								this.paper.canvas.addEventListener('mousedown',function(e){
						        	var clickX = e.offsetX;
						        	var clickY = e.offsetY;
						        	//ahova kattintott az lesz a kijelölés közepe.
						        	//ki kell számolni a bal felső sarkot, az az új x,y, ahol a keretnek lennie kell --> ebből számolandó hogy a canvast mennyivel kell eltolni.

						        	me.visibleCanvasX = clickX - me.visibleCanvasWidth/2;
						        	me.visibleCanvasY = clickY - me.visibleCanvasHeight/2;					        	
						        	
						        	me.zoomableSurface.updateFromNavigatorWindow((me.visibleCanvasX * me.lastConf.ratio)*me.q,(me.visibleCanvasY * me.lastConf.ratio)*me.q);
								});
							}catch(e){
								//IE 9 hülye
							}
							
						},
						scope:this
				}
		});
	
		this.initConfig(config);
		this.callParent([ config ]);
		
		
	},

	setNodes: function(nodes){
		this.nodes = nodes;
	},
	
	setConnections: function(connections){
		this.connections = connections;
	},
	
	redrawNodes: function(){
		this.paper.clear();
		for(var i in this.nodes){			
			this.paper.circle(this.canvasMargin + this.nodes[i].x/this.q, this.canvasMargin + this.nodes[i].y/this.q, this.nodeSize);
		}
		for(var i in this.connections){	
			var pos = {
					x1: this.canvasMargin + this.connections[i].anode.x/this.q,
					y1: this.canvasMargin + this.connections[i].anode.y/this.q,
					x2: this.canvasMargin + this.connections[i].znode.x/this.q,
					y2: this.canvasMargin + this.connections[i].znode.y/this.q
			};
			this.paper.path("M"+pos.x1+" "+pos.y1+"L"+pos.x2+" "+pos.y2).attr({opacity:0.8});
		}
	},
	
	redrawVisibleCanvas: function(conf){
		if(this.visible){
			this.lastConf = conf;
			this.visibleCanvasX = (conf.shiftX)/this.q;
			this.visibleCanvasY = (conf.shiftY)/this.q;
			this.visibleCanvasWidth = (conf.width)/this.q*conf.ratio;
			this.visibleCanvasHeight = (conf.height)/this.q*conf.ratio;
			
			if(this.visibleCanvas){
				this.visibleCanvas.remove();
			}
			this.visibleCanvas = this.paper.rect(this.canvasMargin+this.visibleCanvasX, this.canvasMargin+this.visibleCanvasY,this.visibleCanvasWidth, this.visibleCanvasHeight);
			this.visibleCanvas.attr({
				fill:"#EEE",
				'fill-opacity': 0.4	
			});
			
			this.paper.setViewBox(conf.shiftX/this.q,  conf.shiftY/this.q, this.getWidth(), this.getHeight(), true);
		}
		
	},
	/**
	 * Update shiftX, shiftY, canvasSize, q.
	 * Need: nodes
	 */
	updatePositions: function(){
		var minX, maxX, minY, maxY;
		for(var i in this.nodes){
			if(minX==undefined || this.nodes[i].x<minX ){
				minX = this.nodes[i].x;
			}
			if(maxX==undefined || this.nodes[i].x+this.nodes[i].width>maxX ){
				maxX = this.nodes[i].x+this.nodes[i].width;
			}
			if(minY==undefined || this.nodes[i].y<minY ){
				minY = this.nodes[i].y;
			}
			if(maxY==undefined || this.nodes[i].y+this.nodes[i].height>maxY ){
				maxY = this.nodes[i].y+this.nodes[i].height;
			}
		}
		
		this.canvasSize = {
				width: maxX - minX,
				height: maxY - minY
		};
		this.shiftX = 0;
		this.shiftY = 0;
		if(minX<0){
			this.shiftX = Math.abs(minX);
		}
		if(minY<0){
			this.shiftY = Math.abs(minY);
		}
		
		this.q = this.canvasSize.width/(this.getWidth()-40);
		if(this.canvasSize.height/(this.getHeight()-60)>this.q){
			this.q = this.canvasSize.height/(this.getHeight()-60);
		}
	}
});

// @tag canvas-gui
                                     
Ext.define('NV.canvas.gui.raphael.Topology',{
	config:{
		model:undefined
	},
	
	constructor: function(model, portletContent){
		this.model = model;
		this.portletContent = portletContent;	
		
		if(this.model.get('statusConfig')){
			this.statusChart = this.model.get('statusConfig');
			this.status = this.model.get('status');
		}
		
		this.container = Ext.create('Ext.Component',{
			border:false,
			layout:'fit',
			flex:1,
			cls:"noSelectDiv",
			listeners: {
					render: function(component, eOpts){
						var paper = Raphael(component.getId(),"100%", "100%");
						this.zoomableSurface = Ext.create('NV.canvas.gui.raphael.ZoomableSurface', paper, component, this.model.get("moveable"));						
						if(this.model.get('navigatorVisible')){
							this.zoomableSurface.showNavigator();
						}else{
							this.zoomableSurface.hideNavigator();
						}			
						
						this.graph = Ext.create('NV.canvas.gui.raphael.Graph', {
								model: this.model,
								zoomableSurface: this.zoomableSurface,
								actions:this.model.get('actions'),
								portletContent: this.portletContent,
								rules: this.model.get('rules'),
								editable: this.model.get('editable'),
								background: this.model.get('background')
							}
						);
						
						
						if(this.model.get('url')!=undefined){
							this.loadGraph(this.model.get('url'));
						}else{
							this.drawGraph(this.model.get('json'));
						}
						
					},
					removed: function(){
				
					},
					resize: function(){
						this.graph.paper.width = this.container.getWidth();
						this.graph.paper.height = this.container.getHeight();
						this.zoomableSurface.updateViewport();
						this.zoomableSurface.moveNavigator(this.container.x + this.container.getWidth()-200, this.container.y);
						
					},
					destroy: function(){
						this.zoomableSurface.navigator.hide();
						this.stopRefreshers();
						this.graph.clear();
					},
					
					scope:this
				}
			});	
		
		
		this.zoomablePanel = this.createZoomablePanel();

	
	},
	
	createZoomablePanel : function(){
		return Ext.create('Ext.panel.Panel',{
			width:"100%",
			height:"100%",
			header:false,
			border:false,
			layout:{
				type: 'vbox',
				align:'stretch'	
			},
			listeners: {
				afterrender: function(panel){
					panel.add(this.container);
				},
				scope:this
			},
			items:[{
				xtype:'toolbar',
				flex:0,
				hidden: !this.model.get('toolBarVisible'),
				items:[{
					xtype: 'button',
					icon:'resource/canvas-gui/image/zoomIcons/Actions-zoom-in-icon.png',
					width:24,
					height:24,
					scope:this,
					handler:function(){
						this.zoomableSurface.zoomIn();
					}
				},
				{
					xtype: 'button',
					width:24,
					height:24,
					icon:'resource/canvas-gui/image/zoomIcons/Actions-zoom-out-icon.png',
					scope:this,
					handler:function(){
						this.zoomableSurface.zoomOut();
					}
				},
				{
					xtype: 'button',
					width:24,
					height:24,
					icon:'resource/canvas-gui/image/zoomIcons/Actions-zoom-fit-icon.png',
					scope:this,
					handler:function(){
						this.zoomableSurface.zoomFit();
					}
				},
				{
					xtype: 'button',
					width:24,
					height:24,
					hidden:!this.model.get('saveButtonVisible'),
					icon:'resource/canvas-gui/image/zoomIcons/save-icon.png',
					scope:this,
					handler: function(){
						this.saveGraph(true);
					}
				},
				
				'->',
		        {
		        	xtype: 'button',
		        	text: 'show/hide map',	
		        	hidden:!this.model.get('navigatorButtonVisible'),
		        	handler: function(){
		        		if(this.zoomableSurface.navigator.isVisible()){
		        			this.zoomableSurface.hideNavigator();
		        		}else{
		        			this.zoomableSurface.showNavigator();
		        		}
		        		
		        	},
		        	scope:this
		        }]
			}
			]
		});
	},
	
	getContainer : function(){
		return this.zoomablePanel;
	},
	
	drawGraph: function(json){
	// this.originalGraphDefinition = this.graph.saveGraph();
		this.graph.loadGraph(json);
		
	},
	
	clearGraph: function(){
		this.graph.clear();
	},
	
	loadGraph: function(url){
		//handle full refresh
		if(this.model.get('fullRefresh')){
			this.fullRefresh = Ext.create('NV.ajax.scheduler.RefreshJob', {
				fixParams : {command:""},
				url : url,
				batchedAjaxEnabled:false,
				callback : function(json){
		//			var json = Ext.decode(response.responseText);
					this.clearGraph();
					this.drawGraph(json);
		//			this.zoomableSurface.zoomFit();
				},
				scope : this,
				doOnFirstTime: true,
				refreshIntervall : this.model.get('fullRefreshIntervall')
			});
			this.fullRefresh.start();
		}else{
			Ext.Ajax.request({
				url: url,
				success: function(response){
					var json = NV.ext.ux.nv.GlobalErrorHandler.jsonResponseErrorHandler(response);
					if(!json){
						return;
					}
					this.drawGraph(json);
				//	if(this.model.get('editable') && this.model.get('moveable')){
						this.zoomableSurface.zoomFit();
				//	}
					
				},
				failure: function(response){
					NV.ext.ux.nv.GlobalErrorHandler.requestFailedErrorHandler(response);
				},
				scope:this
			});	
		}
		//handle partial refresh
		if(this.model.get('partialRefresh')){
			this.partialRefresh = Ext.create('NV.ajax.scheduler.RefreshJob', {
				fixParams : {command:""},
				url : this.model.get('extraDataUrl'),
				batchedAjaxEnabled:window.globalAjaxClient?true:false,
				callback : function(json){
					this.graph.refreshGraph(json);
				},
				scope : this,
				doOnFirstTime: true,
				refreshIntervall : this.model.get('partialRefreshIntervall')
			});
			this.partialRefresh.start();
		}
		
	},
	
	saveGraph: function(onlyChanged){
		this.graphDefinition = this.graph.saveGraph();
		Ext.Ajax.request({
			url: this.model.get('saveUrl'),
			jsonData : this.graphDefinition,
			method:'POST',
			success: function(response){
				Ext.Msg.alert('Status', 'Graph save success!');
			},
			failure: function(response){
				NV.ext.ux.nv.GlobalErrorHandler.requestFailedErrorHandler(response);
			},
			scope:this
		});
	},
	remove: function(){
		this.zoomablePanel.remove();
	}, 
	
	createBottomToolbar: function(){
		return;
	},
	
	stopRefreshers: function(){
		try{
			this.partialRefresh.stop();
		}catch(e){
			
		}
		
		try{
			this.fullRefresh.stop();
		}catch(e){
			
		}
		
	}
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.ZoomableSurface', {
	config:{
		
		    contentPadding: 50,
		    continousZoom: true,

		    ratio : 1,
		    zoomFactor: 1.10,
		    zoomCount : 1,
		    shiftX : 0.0,
			shiftY : 0.0,
			currentShiftX : 0.0,
			currentShiftY : 0.0,
		    
		    grabbing: false,
		    nodeGrabbed: false,
		    
		    selectingArea: false,

		    surfaceContainer: undefined,
		    surface: undefined,
		    containerGroup: undefined,

		    selectingStartPos: undefined,
		    selectingRectShape: undefined,

		    navigator: undefined,
		    graph: undefined,
		    
		    surfaceContainerWidth:0,
		    surfaceContainerHeight:0
	},

	getSurfaceSize: function(){
		return {
			width: this.surfaceContainer.getWidth(),
			height: this.surfaceContainer.getHeight()
		};
	},
	
	constructor: function(paper, component, moveable){
		this.initConfig();
		this.paper = paper;
		this.canvas = this.paper.canvas;
		//extjs componens, ami tartalmazza a canvast
		this.surfaceContainer = component;
		
		this.surfaceContainerWidth = this.surfaceContainer.getWidth();
		this.surfaceContainerHeight = this.surfaceContainer.getHeight();
		
    	var me = this;
    	this.initNavigator();

    	if(moveable && this.paper.canvas.addEventListener){
    		this.paper.canvas.addEventListener('mousedown',function(e){
        		
        		me.move = true;
        		document.body.style.cursor = 'move';
            	var mousePos = getMouseXY(e);
            	
            	me.startMoveX = mousePos[0];
            	me.startMoveY = mousePos[1];
            	me.currentShiftX = me.shiftX/me.ratio;
            	me.currentShiftY = me.shiftY/me.ratio;

            	e.preventDefault();
            	
        	});
        	
        	this.paper.canvas.addEventListener('mouseup',function(e){
        		me.move=false;
            	document.body.style.cursor = 'auto';
            	
            	me.navigator.redrawVisibleCanvas({
        			shiftX: me.shiftX,
        			shiftY: me.shiftY,
        			width: me.surfaceContainer.getWidth(),
        			height: me.surfaceContainer.getHeight(),
        			ratio: me.ratio
        		});
        	});
        	
        	this.paper.canvas.addEventListener('mousemove',function(e){
        		if(me.move){
        			me.shiftX = (me.currentShiftX + (me.startMoveX - e.pageX))*me.ratio;
        			me.shiftY = (me.currentShiftY + (me.startMoveY - e.pageY))*me.ratio;
        			me.paper.setViewBox(me.shiftX,  me.shiftY, me.width, me.height, true);
        		}
        	});
        	
        	this.surfaceContainer.el.on("mousewheel",function(event){
    			
    			var oldRatio = me.ratio;
    			
    			var originalMousePosition = {
    					x: event.browserEvent.layerX,
    					y: event.browserEvent.layerY
    			};
    			var newMousePosition = {};
    			
    			if (event.browserEvent.wheelDeltaY < 0 || event.browserEvent.detail > 0 )
    			{
    				me.ratio = oldRatio * me.zoomFactor;
    				me.zoomCount-=0.1;
    				me.graph.zoomOut(me.zoomFactor);
    				newMousePosition = {
    						x: originalMousePosition.x / me.zoomFactor,
    						y: originalMousePosition.y / me.zoomFactor
    				};
    			}
    			else if (event.browserEvent.wheelDeltaY > 0 || event.browserEvent.detail < 0 )
    			{
    				me.ratio = oldRatio / me.zoomFactor;
    				me.zoomCount+=0.1;
    				me.graph.zoomIn(me.zoomFactor);
    				newMousePosition = {
    						x: originalMousePosition.x * me.zoomFactor,
    						y: originalMousePosition.y * me.zoomFactor
    				};
    			}				

    			me.shiftX += ((newMousePosition.x - originalMousePosition.x))*me.ratio;
    			me.shiftY += ((newMousePosition.y - originalMousePosition.y))*me.ratio;
    			
    			me.updateViewport();
    			me.updateNavigator();
    			event.stopPropagation();
    			event.stopEvent();
    			event.browserEvent.stopPropagation();
    		});
    		
    	}
    	
    	

		this.surfaceContainer.addListener('resize',function(evt){
			this.surfaceContainerHeight = this.surfaceContainer.getHeight();
			this.surfaceContainerWidth = this.surfaceContainer.getWidth();
			this.updateNavigator();
			this.updateViewport();
		}, this);
	},
	
	
	
	updateStatusWindow: function(){
		this.navigator.update({
			shiftX: this.shiftX,
			shiftY: this.shiftY,
			width: this.surfaceContainer.getWidth(),
			height: this.surfaceContainer.getHeight(),
			ratio: this.ratio
		});
	},
	
	setNodeMap: function(nodes){
		this.navigator.nodes = nodes;
	},
	setConnectionsMap: function(connections){
		this.navigator.connections = connections;
	},
	initNavigator: function(){
		
		this.navigator = Ext.create('NV.canvas.gui.raphael.NavigatorWindow',{ 
			x : this.surfaceContainer.getX() + this.surfaceContainer.getWidth()-200, 
			y : this.surfaceContainer.getY(),
			zoomableSurface : this
		});
		this.navigator.show();
//		this.updateNavigator();
	},
	
	moveNavigator: function(x,y){
		this.navigator.setX(x);
		this.navigator.setY(y);
	},
	
	moveNavigatorToRight: function(){
		this.moveNavigator(this.surfaceContainer.getX() + this.surfaceContainer.getWidth()-200, this.surfaceContainer.getY());
		
	},
	/**
	 * zoomOrShift changed
	 */
	updateNavigator: function(){
		if(!this.navigatorHidden){
	//		this.navigator.updatePositions();
	//		this.navigator.redrawNodes();
			this.navigator.redrawVisibleCanvas({
				shiftX: this.shiftX,
				shiftY: this.shiftY,
				width: this.surfaceContainer.getWidth(),
				height: this.surfaceContainer.getHeight(),
				ratio: this.ratio
			});
		}
	},
	/**
	 * full refresh to navigator Window (nodes, connectins added)
	 * @param nodes
	 * @param connections
	 */
	refreshNavigator: function(nodes, connections){
		if(!this.navigatorHidden){
			this.navigator.updatePositions();
			this.navigator.redrawNodes();
			this.navigator.redrawVisibleCanvas({
				shiftX: this.shiftX,
				shiftY: this.shiftY,
				width: this.surfaceContainer.getWidth(),
				height: this.surfaceContainer.getHeight(),
				ratio: this.ratio
			});
		}
		
	},
	
	hideNavigator: function(){
		this.navigatorHidden = true;
		this.navigator.hide();
	},
	
	showNavigator: function(){
		this.navigatorHidden = false;
		this.navigator.show();
		this.moveNavigatorToRight();	
		this.updateNavigator();
	},
	
	
	grabbingAction: function(event){
		this.grabbing = false;
		this.grabbed = false;
    	document.body.style.cursor = 'auto';
    	this.paper.canvas.onmousemove = function(){};
    	this.paper.canvas.onmouseup = function(){};
    	
    	this.navigator.redrawVisibleCanvas({
			shiftX: this.shiftX,
			shiftY: this.shiftY,
			width: this.surfaceContainer.getWidth(),
			height: this.surfaceContainer.getHeight(),
			ratio: this.ratio
		});
	},
	
	updateViewport: function()
	{
		
		this.width = this.surfaceContainerWidth * this.ratio;
		this.height = this.surfaceContainerHeight * this.ratio;
		
		this.paper.setViewBox(this.shiftX,  this.shiftY, this.width, this.height, false);
	},
	
	updateFromNavigatorWindow: function(shiftX, shiftY){
		this.shiftX = shiftX;
		this.shiftY = shiftY;
		
		this.updateViewport();
		this.updateNavigator();
	},
	
	zoomIn: function(){
		this.ratio = this.ratio / this.zoomFactor;
		this.graph.zoomIn(this.zoomFactor);
		this.updateViewport();
		this.updateNavigator();
	},
	
	zoomOut: function(){
		this.ratio = this.ratio * this.zoomFactor;
		this.graph.zoomOut(this.zoomFactor);
		this.updateViewport();
		this.updateNavigator();
	},
	
	alignCenter: function(){
		
	},
	
	zoomFit: function(){
	
		/*
		 * find the minimum x, y
		 */
		this.ratio=1;
		this.shiftX = undefined;
		this.shiftY = undefined;
		
		var maxX = null; 
		var maxY = null; 
		
		if(this.graph.model.get("background").image){
			this.shiftX = this.graph.model.get("background").x;
			this.shiftY = this.graph.model.get("background").y;
			maxX = this.graph.model.get("background").x + this.graph.model.get("background").width;
			maxY = this.graph.model.get("background").y + this.graph.model.get("background").height;
		}else{
			var minXnode = undefined;
			var minYnode = undefined;
			
			for(var s in this.graph.nodeMap){

				if(this.shiftX==undefined || this.graph.nodeMap[s].x<this.shiftX){
					this.shiftX = this.graph.nodeMap[s].x;
					minXnode = this.graph.nodeMap[s];
				}
				
				if(this.shiftY==undefined || this.graph.nodeMap[s].y<this.shiftY){
					this.shiftY = this.graph.nodeMap[s].y;
					minYnode = this.graph.nodeMap[s];

				}	
			}
			
			/*
			 * x,y margin
			 */
			this.shiftX -= 20;
			this.shiftY -= 20;
			
			if(minXnode && minXnode.container){
				this.shiftX -= 10;
			}
			if(minYnode && minYnode.container){
				this.shiftY -= 40;
			}
			

			
			for(var s in this.graph.nodeMap){
				if(maxX==null || this.graph.nodeMap[s].x + this.graph.nodeMap[s].maxWidth > maxX){
					maxX = this.graph.nodeMap[s].x + this.graph.nodeMap[s].maxWidth;
				}
				
				if(maxY==null || this.graph.nodeMap[s].y+this.graph.nodeMap[s].height > maxY){
					maxY = this.graph.nodeMap[s].y+this.graph.nodeMap[s].height;
				}
			}
			maxX+=20;
			maxY+=20;	
		}
		
		while((maxX-this.shiftX)/this.ratio < this.surfaceContainer.getWidth() && (maxY-this.shiftY)/this.ratio < this.surfaceContainer.getHeight()){
			this.ratio/=this.zoomFactor;
			this.graph.zoomIn(this.zoomFactor);
		}

		while((maxX-this.shiftX)/this.ratio > (this.surfaceContainer.getWidth()) || (maxY-this.shiftY)/this.ratio > (this.surfaceContainer.getHeight())){
			this.ratio*=this.zoomFactor;
			this.graph.zoomOut(this.zoomFactor);
		}

		this.updateViewport();
		this.updateNavigator();
	}
	
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.shapes.Connection',{
	
	config:{
		anode:undefined,
		znode:undefined,
		direction: 0,//0 - no arrow, 1 a->z ,2 a<->z,	
		name: "",
		stroke: {
			 "style":"Solid",
             "width":1
		},
		hoverColor:{
			hex:"#FF1E1E",
			opacity:0.8
		},
		normalColor:{
			hex:"#124996",
			opacity:0.8
		},
		labelSize : 10,
		paper:undefined,
		arrowDistance : 2,
		arrowDistance2 : 2,
		lineSpacing : 4,
		hovered: false,
		arrowSize: 5,
		pos2:0,
		zoomableSurface: undefined,
		labelVisible: true,
		count: undefined,
		listenDirection: true,
		listenStroke:true,
		listenName:true,
		hoverOnMouse:false

	},
	
	constructor: function(config){
		this.initConfig(config);
		if(config.direction == 1){
			this.listenDirection = true;
			this.arrowDistance = 20;
			this.arrowDistance2 = 20;
		}
		if(!this.paper){
			Ext.Msg.alert("Connection init error", "No paper defined!");
			return;
		}
		if(!this.anode || !this.znode){
			Ext.Msg.alert("Connection init error", "No source or destination node found! ("+config.ZId+","+config.AId+")");
			return;
		}
		this.anode.connections.push(this);
		this.znode.connections.push(this);
		
		this.line = this.paper.path("M0,0");
		
		var num = 0;
		//a és z közti már létező élek száma
		num = Math.abs(this.anode.getConnectionsNumberTo(this.znode));
		var ls = this.lineSpacing - (Math.max(Math.min(num, 6) - 2, 0) / 4);
		this.first = -((num - 1) * ls) / 2;
		//var pos2 = 0;
		if (num > 1)
			this.pos2 = this.anode.getPosOfConnection(this.znode, this);
		this.shift = this.first + this.pos2 * ls;
//		this.redraw();
		
	},
	
	normalize : function(v) {
		v.l = Math.max(Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2)), 0.001);
		v.x /= v.l;
		v.y /= v.l;
		return v;
	},

	move: function(dx, dy){
		this.line.transform("t"+dx+","+dy);
		
		pos = {
				line : {
					x1 : this.anode.iconX + this.anode.width/2,
					y1 : this.anode.iconY + this.anode.height/2,
					x2 : this.znode.iconX + this.znode.width/2,
					y2 : this.znode.iconY + this.znode.height/2
				},
				showArrows:true
			};
		
		if(this.arrow1){
			this.arrow1.transform("t"+dx+","+dy+"r"+(90+this.angle));
	//		this.arrow1.transform((90+this.angle)+","+pos.line.x2+","+pos.line.y2);
		}
		if(this.arrow2){
			this.arrow2.transform("t"+dx+","+dy+"r"+(-90+this.angle));
	//		this.arrow2.transform("r"+(-90+this.angle)+","+pos.line.x1+","+pos.line.y1);
		}
	},
	
	redraw: function(storedAngle){
		var pos;
		if(this.arrowDistance>0){
			pos = this.getConnPos(this.anode, this.znode);
		}else{
			pos = {
					line : {
						x1 : this.anode.iconX + this.anode.width/2,
						y1 : this.anode.iconY + this.anode.height/2,
						x2 : this.znode.iconX + this.znode.width/2,
						y2 : this.znode.iconY + this.znode.height/2
					},
					showArrows:true
				};
		}
		
		this.line.attr({'path':"M"+pos.line.x1+" "+pos.line.y1+"L"+pos.line.x2+" "+pos.line.y2});
		
		if(this.listenName || (this.arrowDistance>0 && this.listenDirection)){
			var angle;
			if(storedAngle){
				angle = this.angle;
			}else{
				angle = Math.atan2(pos.line.x1-pos.line.x2,pos.line.y2-pos.line.y1);
				angle = (angle / (2 * Math.PI)) * 360;
				this.angle = angle;
			}

			if(this.listenName){
				this.drawLabel(pos, angle);
			}
			if(this.arrowDistance>0 && this.listenDirection){
				var size = this.arrowSize;
				if(this.direction>=1 && pos.showArrows){
					
					if(this.arrow1){
						this.arrow1.attr({"path": "M" + pos.line.x2 + " " + pos.line.y2 + " L" + (pos.line.x2 - size) + " " + (pos.line.y2 - size) + " L" + (pos.line.x2 - size) + " " + (pos.line.y2 + size) + " L" + pos.line.x2 + " " + pos.line.y2})
					}else{
						this.arrow1 = this.paper.path("M" + pos.line.x2 + " " + pos.line.y2 + " L" + (pos.line.x2 - size) + " " + (pos.line.y2 - size) + " L" + (pos.line.x2 - size) + " " + (pos.line.y2 + size) + " L" + pos.line.x2 + " " + pos.line.y2 );
					    this.arrow1.attr({
					    	"fill": this.normalColor.hex,
					    	"opacity": this.normalColor.opacity,
					    	'stroke': this.normalColor.hex,
							'stroke-opacity': this.normalColor.opacity
					    });
					}
					this.arrow1.transform("r"+(90+angle)+","+pos.line.x2+","+pos.line.y2);
				}
				if(this.direction>=2 && pos.showArrows){
				//	this.line.attr({'arrow-end':'classic-midium'});
					if(this.arrow2){
						this.arrow2.attr({'path':"M" + pos.line.x1 + " " + pos.line.y1 + " L" + (pos.line.x1 - size) + " " + (pos.line.y1 - size) + " L" + (pos.line.x1 - size) + " " + (pos.line.y1 + size) + " L" + pos.line.x1 + " " + pos.line.y1});
					}else{
						this.arrow2 = this.paper.path("M" + pos.line.x1 + " " + pos.line.y1 + " L" + (pos.line.x1 - size) + " " + (pos.line.y1 - size) + " L" + (pos.line.x1 - size) + " " + (pos.line.y1 + size) + " L" + pos.line.x1 + " " + pos.line.y1 );
					    this.arrow2.attr({
					    	"fill": this.normalColor.hex,
					    	"opacity": this.normalColor.opacity,
					    	'stroke': this.normalColor.hex,
							'stroke-opacity': this.normalColor.opacity
					    });
					   
					}
					
					this.arrow2.transform("r"+(-90+angle)+","+pos.line.x1+","+pos.line.y1);    
				}
			}
		}
		

		if(this.listenStroke){
			
			if(this.stroke.style=="dashed"){
				this.line.attr({'stroke-dasharray':"--"});
			}
			if(this.stroke.style=="dotted"){
				this.line.attr({'stroke-dasharray':"."});
			}
			
			this.decorateLine();
		}
		
		
		
		this.hover(this.hovered);
		this.toFront();
		this.anode.toFront();
		this.znode.toFront();

	},
	
	drawLabel: function(pos, angle){
		if(this.label){
			this.label.remove();
		}
		var labelText = this.name;
		
		
		if(labelText!=undefined && labelText!="" && pos.showArrows && this.labelVisible){
			
			if(pos.showArrows){
				this.label = this.paper.text((pos.line.x1+pos.line.x2)/2, (pos.line.y1+pos.line.y2)/2-7, labelText).attr({'font-size':this.labelSize, "font-weight":"bold"});
				if(angle>0){
					this.label.transform("r"+(angle-90)+","+(pos.line.x1+pos.line.x2)/2+","+(pos.line.y1+pos.line.y2)/2);
				}else{
					this.label.transform("r"+(90+angle)+","+(pos.line.x1+pos.line.x2)/2+","+(pos.line.y1+pos.line.y2)/2);				
				}
			}
			
		}
	},
	
	decorateLine: function(){
		var width = this.stroke.width;
		this.line.attr({
			'stroke-width':width,
			'stroke':this.normalColor.hex,
			'stroke-opacity':this.normalColor.opacity
		});
	},
	
	hover: function(hover){
		if(this.hoverOnMouse){
			this.hovered = hover;
			if(hover){
				this.line.attr({
					'stroke':this.hoverColor.hex,
					'stroke-opacity':this.hoverColor.opacity
				});
				
				if(this.arrow1){
					this.arrow1.attr({
				    	"fill": this.hoverColor.hex,
				    	"opacity": this.hoverColor.opacity,
				    	'stroke': this.hoverColor.hex,
						'stroke-opacity': this.hoverColor.opacity
				    });
				}
				if(this.arrow2){
					this.arrow2.attr({
				    	"fill": this.hoverColor.hex,
				    	"opacity": this.hoverColor.opacity,
				    	'stroke': this.hoverColor.hex,
						'stroke-opacity': this.hoverColor.opacity
				    });
				}
				
			}else{
				this.line.attr({
					'stroke':this.normalColor.hex,
					'stroke-opacity':this.normalColor.opacity
				});
				if(this.arrow1){
					this.arrow1.attr({
				    	"fill": this.normalColor.hex,
				    	"opacity": this.normalColor.opacity,
				    	'stroke': this.normalColor.hex,
						'stroke-opacity': this.normalColor.opacity
				    });
				}
				if(this.arrow2){
					this.arrow2.attr({
				    	"fill": this.normalColor.hex,
				    	"opacity": this.normalColor.opacity,
				    	'stroke': this.normalColor.hex,
						'stroke-opacity': this.normalColor.opacity
				    });
				}
			}
			
			this.anode.hoverByOther(hover);
			this.znode.hoverByOther(hover);
		}
	},
	
	getConnPos : function(anode, znode) {
		
			
		var pos = {
				ax: anode.iconX + anode.width/2,
				ay: anode.iconY + anode.height/2,
				zx: znode.iconX + znode.width/2,
				zy: znode.iconY + znode.height/2
			};

		
		var n = this.normalize({
			x : pos.zy - pos.ay,
			y : pos.ax - pos.zx
		});


		// general case	
		var ret = {
				line : {
					x1 : pos.ax + (n.x * this.shift),
					y1 : pos.ay + (n.y * this.shift),
					x2 : pos.zx + (n.x * this.shift),
					y2 : pos.zy + (n.y * this.shift)
				}
			};

			var a = this.normalize({
				x : ret.line.x2 - ret.line.x1,
				y : ret.line.y2 - ret.line.y1
			});


			var dist = Math.max((this.arrowDistance) * Math.sqrt(Math.pow(a.x, 2) * 2 + Math.pow(a.y, 2)), 1); 
//			dist += this.pos2 * (5);

			var dist2 = Math.max((this.arrowDistance2) * Math.sqrt(Math.pow(a.x, 2) * 2 + Math.pow(a.y, 2)), 1); 
	//		dist2 += this.pos2 * (5);

			ret.arrowFrom = {
				x : ret.line.x1 + (a.x * dist2),
				y : ret.line.y1 + (a.y * dist2)
			};

			ret.arrowTo = {
				x : ret.line.x2 + (-a.x * dist2),
				y : ret.line.y2 + (-a.y * dist2)
			};

			if (ret.line.y1 + 40 < ret.line.y2) {
				ret.arrowFrom = {
					x : ret.line.x1 + (a.x * dist),
					y : ret.line.y1 + (a.y * dist)
				};

				ret.line.x1 = ret.line.x1 + (a.x * dist);
				ret.line.y1 = ret.line.y1 + (a.y * dist);

				ret.line.x2 = ret.line.x2 + (-a.x * dist2);
				ret.line.y2 = ret.line.y2 + (-a.y * dist2);

			} else if (ret.line.y1 - 40 > ret.line.y2) {
				ret.arrowTo = {
					x : ret.line.x2 + (-a.x * dist),
					y : ret.line.y2 + (-a.y * dist)
				};

				ret.line.x2 = ret.line.x2 + (-a.x * dist);
				ret.line.y2 = ret.line.y2 + (-a.y * dist);

				ret.line.x1 = ret.line.x1 + (a.x * dist2);
				ret.line.y1 = ret.line.y1 + (a.y * dist2);

			} else {
				ret.line.x1 = ret.line.x1 + (a.x * dist2);
				ret.line.y1 = ret.line.y1 + (a.y * dist2);

				ret.line.x2 = ret.line.x2 + (-a.x * dist2);
				ret.line.y2 = ret.line.y2 + (-a.y * dist2);

			}

			ret.showArrows = n.l > dist * 2.1;

			return ret;
	},
	
	getConfig: function(){
		return {
			AId:this.anode.id,
			ZId: this.znode.id,
			direction: this.direction,
			name: this.name
		}
	},
	
	toFront : function(){
		if(this.arrow1){
			this.arrow1.toFront();
		}
		if(this.arrow2){
			this.arrow2.toFront();
		}
		if(this.label){
			this.label.toFront();
		}
		this.line.toFront();
	},
	
	zoomGraph : function(){
		if(this.zoomableSurface.ratio<=1){
			if(this.zoomableSurface.ratio<=1 && this.zoomableSurface.ratio>0.9){
				this.labelSize = 10;
			}else if(this.zoomableSurface.ratio<=0.9 && this.zoomableSurface.ratio>0.8){
				this.labelSize = 9;
			}else if(this.zoomableSurface.ratio<=0.8 && this.zoomableSurface.ratio>0.6){
				this.labelSize = 8;
			}else if(this.zoomableSurface.ratio<=0.6){
				this.labelSize = 7;
			}
		}
		
		
		if(this.zoomableSurface.ratio>1){
			if(this.labelVisible){
				this.labelVisible = false;
				this.redraw();
			}
		}else{
			if(!this.labelVisible){
				this.labelVisible = true;
				this.redraw();

			}
		}
	}
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.shapes.Container',{
	config: {
		color: "#BBEEAA",
		id:undefined,
		name:"",
		x:0,
		y:0,
		width:0,
		height:0,
		nodes: undefined,
		containers: undefined,
		graph: undefined,
		paper: undefined,
		opacity: 0.7,
		type: undefined,
		containerId: undefined,
		parentContainer: undefined,
		iconWidth: 30,
		iconHeight:30,
		iconImage: undefined,
		parameters: undefined,
		zoomableSurface: undefined,
		minWidth: 0,
		minHeight: 0,
		statusChart: undefined,
		status: undefined,
		statusRefresh: false,
		statusRefreshTime: undefined,
		letterColor: "#000000",
		editable: true
	},
	
	constructor:function(config){
		this.initConfig(config);
		this.nodes = [];
		this.containers = [];
		this.handlers = [];

		this.header = this.paper.rect(this.x, this.y-40,  this.width, 40);
		this.header.attr({
			'fill':this.color,
			'opacity':1,
			'stroke-opacity': 0.8
			});
		
		if(this.iconImage==undefined){
			if(this.graph.model.get('imageUrl')){
				this.iconImage = this.graph.model.get('imageUrl')+this.type+".png";
					
			}else{
				this.iconImage = "resource/canvas-gui/"+this.type+".png";
			}
		}

		this.icon = this.paper.image(this.iconImage, this.x+5, this.y-35, this.iconWidth, this.iconHeight);
		this.container = this.paper.rect(this.x, this.y-40, this.width, this.height+10); 

		if(this.name && this.name !=""){
			this.labelShape = this.paper.text(this.x+this.iconWidth+10, this.y-20, this.name);
			this.labelShape.attr({
	//			'font-family': "'Comic Sans MS', cursive, sans-serif",
				'font-size':"14",
				'fill':this.letterColor,
				'font-weight': "bold",
				'text-anchor':'start'
			});
		}
		if(this.editable){
			this.addMoveHandler();
		}
		
		
		if(this.statusRefresh){
			
			var params = {
					command : "/getStatus",
					arguments : {
						nodeId : this.id
					}
				};
			
			var job = Ext.create('NV.ajax.scheduler.RefreshJob', {
				fixParams : params,
				batchedAjaxEnabled:true,
				callback : function(json){
		//			var json = Ext.decode(response.responseText);
					this.scope.status = json;
					this.scope.drawStatusChart(json);
				},
				scope : this,
				doOnFirstTime: true,
				refreshIntervall : this.statusRefreshTime
			});
			job.start();
			
			
		}else{
			this.drawStatusChart();
		}
	},

	redraw: function(hideError){
		var nodes = this.nodes;

		if(nodes.length>0 || this.containers.length>0){
			this.resize();
			if(this.parentContainer){
				this.parentContainer.resize();
			}
			this.toFront();
		}else if(!hideError){
			Ext.Msg.alert("Warning","Empty container: "+this.id);
		}
		for(var i= 0; i<this.handlers.length; i++){
			this.applyEventHandler(this.handlers[i].event,this.handlers[i].fn, this.handlers[i].scope);
		}
		
	},
	
	drawStatusChart: function(){
		if(this.statusChart && this.status){
			this.statusIcons = [];
			for(var i=0; i<this.status.length; i++){
				var statusIconPath = "";
				if(this.graph.model.get('imageUrl')){
					statusIconPath = this.graph.model.get('imageUrl')+"status/";
						
				}else{
					statusIconPath = "resource/dashboard-layout/image/status/";
				}
				
				
				var img;
		
				var statusY = this.y-20;
				var statusX;
				var type = "icon";
				statusX = this.labelShape.getBBox().width+10+(10+this.statusChart.config.imageSize)*i+this.iconWidth;
				if(this.statusChart.field.icon && this.status[i][this.statusChart.field.icon]=="text"){
					type='text';
					img = this.paper.text(statusX, statusY, this.status[i][this.statusChart.field.value]);
					img.attr({"font-weight":"bold",'text-anchor':'start'});
				}else{
					if(this.statusChart.field.icon &&  this.status[i][this.statusChart.field.icon]){
						statusIconPath += this.status[i][this.statusChart.field.icon]+"/";
					}else if(this.statusChart.config.type){
						statusIconPath += this.statusChart.config.type+"/";
					}else{
						statusIconPath += "default/";
					}
					
					statusIconPath+=this.status[i][this.statusChart.field.value]+".png";
					img = this.paper.image(statusIconPath, statusX, statusY, this.statusChart.config.imageSize, this.statusChart.config.imageSize);					
				}
				
				img.mouseover(function(evt){
					Ext.create('Ext.tip.ToolTip',{
			            target: evt.currentTarget,
			            html: this.tooltip,
			            dismissDelay: 15000, // auto hide after 15 seconds
			            showDelay: 500
			        });
				}, {
					thisObject:this, 
					img: img,
					tooltip: this.status[i][0]
					});
				this.statusIcons.push({type:type,shape:img});
			}
		}
	},
	
	resize: function(){
		var nodes = this.nodes;
		var containers = this.containers;
			var minX, maxX, minY, maxY;
			for(var i in nodes){
				if(minX==undefined || nodes[i].minX<minX ){
					minX = nodes[i].minX-10;
				}
				if(maxX==undefined || nodes[i].minX+nodes[i].maxWidth>maxX ){
					maxX = nodes[i].minX+nodes[i].maxWidth+10;
				}
				if(minY==undefined || nodes[i].iconY<minY ){
					minY = nodes[i].iconY-10;
				}
				if(maxY==undefined || nodes[i].iconY+nodes[i].height>maxY ){
					maxY = nodes[i].iconY+nodes[i].height+10;
				}
			}
			for(var i in containers){
				if(minX==undefined || containers[i].container.attr('x')<minX ){
					minX = containers[i].container.attr('x')-10;
				}
				if(maxX==undefined || containers[i].container.attr('x')+containers[i].container.attr('width')>maxX ){
					maxX = containers[i].container.attr('x')+containers[i].container.attr('width')+10;
				}
				if(minY==undefined || containers[i].container.attr('y')-50<minY ){
					minY = containers[i].container.attr('y')-50-10;
				}
				if(maxY==undefined || containers[i].container.attr('y')+containers[i].container.attr('height')>maxY ){
					maxY = containers[i].container.attr('y')+containers[i].container.attr('height')+10;
				}
			}
			
			this.x = minX-10;
			this.y = minY;
			
			
			this.icon.attr({
				'x':this.x+5, 
				'y':this.y-35,
				'transform':""
			});

			if(this.name && this.name !=""){
				this.labelShape.attr({
					x: this.x+this.iconWidth+10,
					y: this.y-20,
					'transform':""
				});
			}
			
			if(this.statusIcons){
				for(var i = 0; i<this.statusIcons.length; i++){
					var img = this.statusIcons[i].shape;
					var statusY = this.y-20;
					var statusX = this.x+this.labelShape.getBBox().width+20+(10+this.statusChart.config.imageSize)*i+this.iconWidth;
					
					if(this.statusIcons[i].type=="icon"){
						statusY -=img.attr("height")/2;
					}
					
					img.attr({
						x: statusX,
						y: statusY,
						transform:""
					});
				}
			}
			
			this.width = maxX-minX+20;
			this.height = maxY-minY+40;
			
			
			try{
				if(this.name && this.name !="" && this.labelShape["0"].getComputedTextLength()+20+this.iconWidth>this.width){
					this.width = this.labelShape["0"].getComputedTextLength()+20+this.iconWidth;
				}
			}catch(e){
				this.width = this.width+20+this.iconWidth;
			}
			
			if(this.statusIcons){
				//compute the icons length 
				var iconLength = 0;
				for(var i = 0; i<this.statusIcons.length; i++){
					if(this.statusIcons[i].type=="text"){
						iconLength += this.statusIcons[i].shape[0].getComputedTextLength()+10;
					}else{
						iconLength += this.statusIcons[i].shape.attr("width")+10;
					}
					
				}
				
				if(this.name && this.name !="" && this.width+iconLength > this.width){
					this.width = this.width+iconLength;
				}
			}
			
			
			if(this.width < this.minWidth){
				this.width = this.minWidth;
			}
			
			if(this.height < this.minHeight){
				this.height = this.minHeight;
			}
			
			this.header.attr({
				'x':this.x,
				'y':this.y-40,
				'width': this.width,
				'height': 40,
				'fill':this.color,
				'opacity':this.opacity,
				'stroke-opacity': 1,
				'r':5,
				'transform':""
				});		
			this.container.attr({
				'x': this.x,
				'y': this.y-40,
				'width': this.width,
				'height': this.height+10,
				'fill':'FFFFFF',
				'opacity':this.opacity,
				'stroke-opacity': 1,
				'transform':"",
				'r':5
				});
			//fejléc pozicionálás:
			
	},
	
	zoomInGraph: function(ratio){
		this.resize();
	//	this.setPosition(this.x/ratio,this.y/ratio);
	},
	
	zoomOutGraph: function(){
		this.resize();
	},
	
	setPosition: function(x,y){
		this.x = x;
		this.y = y;
		this.header.attr({
			'x':this.x,
			'y':this.y-40
			});		
		this.container.attr({
			'x': this.x,
			'y': this.y-40
			});
		this.icon.attr({
			'x':this.x+5, 
			'y':this.y-35
		});
		if(this.name && this.name !=""){
			this.labelShape.attr({
				x: this.x+this.iconWidth+10,
				y: this.y-20
			});
		}
	},
	
	move: function(dx, dy){
		
		for(var i=0; i<this.nodes.length; i++){
			this.nodes[i].moveAlone(dx,dy);
		}
		for(var i=0; i<this.containers.length; i++){
			this.containers[i].move(dx,dy);
		}
		
		this.header.transform("t"+dx+","+dy);		
		this.container.transform("t"+dx+","+dy);		
		this.icon.transform("t"+dx+","+dy);		
		if(this.labelShape){
			this.labelShape.transform("t"+dx+","+dy);
		}
		
		if(this.statusIcons){
			for(var i = 0; i<this.statusIcons.length; i++){
				var img = this.statusIcons[i].shape;
				img.transform("t"+dx+","+dy);
			}
		}
		
	//	this.setPosition(this.x+this.ddx, this.y+this.ddy);
		if(this.parentContainer){
			this.parentContainer.resize(dx,dy);
		}
		this.toFront();
	},
	
	addMoveHandler: function(){
		this.header.drag(
				//move
			function(dx, dy, x,y,evt){
				if(this.selected){
				
					dx *= this.zoomableSurface.ratio;
					dy *= this.zoomableSurface.ratio;
					
					this.ddx = dx - this.ddx;
					this.ddy = dy - this.ddy;
					
					this.move(dx,dy);
					
					this.ddx = dx;
					this.ddy = dy;
					
					evt.stopPropagation();
				}
			},
			//start
			function(x,y,evt){
				this.selected = true;
				this.ddx = 0;
				this.ddy = 0;
				evt.stopPropagation();
				
				
			},
			//end
			function(evt){
				this.selected = false;
				if(this.ddx == 0 && this.ddy == 0){
					return;
				}
				for(var i=0; i<this.nodes.length; i++){
					this.nodes[i].x = this.nodes[i].iconX;
					this.nodes[i].y = this.nodes[i].iconY;
					this.nodes[i].draw();
				}
				this.redraw();
				this.graph.refreshNavigator();
				if(this.parentContainer){
					this.parentContainer.redraw();
				}
				
				evt.stopPropagation();
				
			},
			this, this, this
		);
		if(this.icon){
			this.icon.drag(function(dx, dy, x,y,evt){
				if(this.selected){
				
					dx *= this.zoomableSurface.ratio;
					dy *= this.zoomableSurface.ratio;
					
					this.ddx = dx - this.ddx;
					this.ddy = dy - this.ddy;
					
					this.move(dx,dy);
					
					this.ddx = dx;
					this.ddy = dy;
					
					evt.stopPropagation();
				}
			},
			//start
			function(x,y,evt){
				this.selected = true;
				this.ddx = 0;
				this.ddy = 0;
				evt.stopPropagation();
				
				
			},
			function(evt){
				this.selected = false;
				if(this.ddx == 0 && this.ddy == 0){
					return;
				}
				for(var i=0; i<this.nodes.length; i++){
					this.nodes[i].x = this.nodes[i].iconX;
					this.nodes[i].y = this.nodes[i].iconY;
					this.nodes[i].draw();
				}
				this.redraw();
				this.graph.refreshNavigator();
				if(this.parentContainer){
					this.parentContainer.redraw();
				}
				
				evt.stopPropagation();
				
			},
			this, this, this);
		}
	},
	
	addHandler: function(event, fn, scope){
		this.handlers.push({event:event, fn: fn, scope:scope});
	},
	
	applyEventHandler: function(event, fn, scope){
		if(event=='mouseover'){
			this.icon.mouseover(fn, scope);
			this.header.mouseover(fn, scope);
			
		}
		if(event=='mouseout'){
			this.icon.mouseout(fn, scope);
			this.header.mouseout(fn, scope);
			
		}
		if(event=='click'){
			this.icon.click(fn, scope);
			this.header.click(fn, scope);
			
		}
		if(event=='rightclick'){
			this.icon.mousedown(fn, scope);
			this.header.mousedown(fn, scope);
			
		}
		if(event=='mousedown'){
			this.icon.mousedown(fn, scope);
			this.header.mousedown(fn, scope);
			
		}
		if(event=='dblclick'){
			this.icon.dblclick(fn, scope);
			this.header.dblclick(fn, scope);
		}
	},
	
	getConfig: function(){
		var ret = {
			id: this.id,
			type: this.type,
			name: this.name,
			color: this.color
		};
		if(this.containerId){
			ret.containerId = this.containerId;
		}
		return ret;
	},
	
	toFront: function(){
		
		this.container.toFront();
		
		for(var i=0; i<this.containers.length; i++){
			this.containers[i].toFront();
		}
		
		this.header.toFront();
		this.icon.toFront();
		if(this.name && this.name !=""){
			this.labelShape.toFront();
		}
		
		for(var i=0; i<this.nodes.length; i++){
			for(var j=0; j<this.nodes[i].connections.length; j++){
				this.nodes[i].connections[j].toFront();
			}
		}
		
		if(this.statusIcons){
			for(var i = 0; i<this.statusIcons.length; i++){
				var img = this.statusIcons[i].shape;
				img.toFront();
			}
		}
		
		for(var i=0; i < this.nodes.length; i++){
			this.nodes[i].toFront();
		}	
		

	}
});

// @tag canvas-gui
Ext.define('NV.canvas.gui.raphael.shapes.Node',{
	config:{
		id : 0, 
		label: undefined, 
		type: undefined, 
		x : 0, 
		y : 0,
		width: 20,
		height: 20,
		paper: undefined,
		topologyModel: undefined,
		zoomableSurface: undefined,
		graph: undefined,
		connections: undefined,
		container:undefined,
		parameters:undefined,
		iconImage: undefined,
		statusChart: undefined,
		status: undefined,
		statusRefresh: false,
		statusRefreshTime: undefined,
		nodeRefresh: false,
		nodeRefreshTime: 30,
		rules: [],
		propertiesCmd:"?cmd=getProperties",
		propertiesUrl:"test/json/",
		zoomOnOver : false,
		handlers: undefined,
		labelVisible: true,
		iconVisible:true,
		editable:true,
		labelFontSize:10,
		
		bgColor:undefined
	},
	
	constructor:function(config){
		if(config.width==undefined){
			config.width = config.defWidth;
			this.defWidth = true;
		}
		if(config.height==undefined){
			config.height = config.defHeight;
			this.defHeight = true;
		}
		
		
		this.initConfig(config);
		
		this.iconX = this.x;
		this.iconY = this.y;
		
		this.hoverColor = Ext.clone(this.topologyModel.get('colorMap').bgColorHover);
		this.lightHoverColor = NV.canvas.gui.func.Functions.getLighterColor(this.hoverColor);
		if(!this.bgColor){
			this.bgColor = Ext.clone(this.topologyModel.get('colorMap').bgColor);	
		}
		
		this.connections = [];
		this.handlers = [];
		if(!this.paper){
			Ext.Msg.alert("Node init error", "No paper defined!");
			return;
		}
		if(this.container){
			this.container.nodes.push(this);
		}
		this.originalHeight = this.height;
		this.originalWidth = this.width;
		
		this.initHandlers();
		this.initRefreshJobs();
		
	},
	
	initHandlers: function(){
		this.addHandler("mouseover", function(evt){
			this.hover(true);
			evt.stopPropagation();
		}, this);
		
		this.addHandler("mouseout", function(evt){
			this.hover(false);
			evt.stopPropagation();
		}, this);
		if(this.zoomOnOver){
			this.addHandler('mousedown', function(evt){
				if(evt.button==0){
					if(this.zoomed){
	//					this.zoomOutNode();
					}
				}				
			}, this);
		}
	},
	
	draw: function(){
		if(this.selected){
			this.waitingForRedraw = true;
			return;
		}
		if(this.zoomed){
			this.x -=20;
			this.y -=20;
		}
		this.set = this.paper.set();
		if(this.rules){
			for(var i=0; i<this.rules.length; i++){
				//condition kiértékelés
				cond = this.rules[i].condition;			
				cond = cond.replace(/\${/g, 'this.parameters["').replace(/}/g,'"]');
				cond = eval(cond);
			
				if(cond){
					if(this.rules[i].bgColor){
						this.bgColor.hex = this.rules[i].bgColor;
					}
					if(this.rules[i].hoverColor){
						this.hoverColor.hex = this.rules[i].hoverColor;
						this.lightHoverColor = NV.canvas.gui.func.Functions.getLighterColor(this.hoverColor);
					}
					if(this.rules[i].background){
						this.bgColor = this.rules[i].background;
					}
					if(this.rules[i].hover){
						this.hoverColor = this.rules[i].hover;
					}
				}
			}
		}
		try{
			this.icon.remove();
		}catch(e){
			
		}
		
		try{
			this.iconBG.remove();
		}catch(e){
			
		}
		
		if(this.iconVisible){
			var iconPath = "";
			if(this.iconImage==undefined){
				if(this.topologyModel.get('imageUrl')){
					iconPath = this.topologyModel.get('imageUrl')+this.type+".png";			
				}else{
					iconPath = "resource/canvas-gui/image/"+this.type+".png";
				}
			}else{
				iconPath = this.iconImage;
			}
			this.icon = this.paper.image(iconPath, this.x, this.y, this.width, this.height);
			this.iconBG = this.paper.rect(this.x, this.y, this.width, this.height);
			this.set.push(this.iconBG);
			this.icon.toFront();
		}

		try{
			this.labelShape.remove();
		}catch(e){
			
		}
		
		try{
			this.labelBG.remove();
		}catch(e){
			
		}
		if(this.labelVisible){
			
			this.labelShape = this.paper.text(this.x+this.width/2, this.y+this.height+10, this.label);
			this.labelShape.attr({"font-size":this.labelFontSize});
			this.labelShape["0"].style.cursor = 'default';
			if(this.zoomed){
				this.labelShape.attr({"font-size":16});
			}
			try{
				this.labelWidth = this.labelShape["0"].getComputedTextLength();
			}catch(e){
				this.labelWidth = this.width;
			}
			
			
			this.labelBG = this.paper.rect(this.labelShape.attr('x')-this.labelWidth/2, this.labelShape.attr('y')-this.labelShape.node.clientHeight/2, this.labelWidth, this.labelShape.node.clientHeight);
			
			if(this.width<this.labelWidth){
				this.maxWidth = this.labelWidth;
				this.minX = this.x-(this.labelWidth-this.width)/2;
			}else{
				this.maxWidth = this.width;
				this.minX = this.x;
			}
			this.set.push(this.labelBG);
			this.labelShape.toFront();
			if(this.editable){
				this.addSelectionHandler(this.labelShape);
			}

		}else{
			this.maxWidth = this.width;
			this.minX = this.x;
		}

		this.set.attr("stroke", "");
		this.setBG(this.bgColor);	
		
		this.drawStatusChart();
		if(this.zoomed){
			this.x +=20;
			this.y +=20;
		}
		
		for(var i= 0; i<this.handlers.length; i++){
			this.applyEventHandler(this.handlers[i].event,this.handlers[i].fn, this.handlers[i].scope);
		}
		if(this.editable && this.iconVisible){
			this.addSelectionHandler(this.icon);
		}else if(this.editable && this.labelVisible){
			this.addSelectionHandler(this.labelShape);
		}
		if(this.tooltipAction){
			this.tooltipAction.scope.target = this.icon.node;
			this.tooltipAction.doAction();
		}
		
	},
	
	zoomNode: function(width, height){
		
		this.width = width;
		this.height = height;
		this.draw();
	},
	
	zoomInNode: function(){
		if(!this.zoomed){
//			if(this.zoomOutTask){
//				this.zoomOutTask.cancel();
//			}
			
			this.zoomed = true;
			this.originalHeight = this.height;
			this.originalWidth = this.width;
			this.zoomNode(60,60);
			
			/*var task = new Ext.util.DelayedTask(function(){
				this.zoomOutNode();
			}, this);
			task.delay(2000);*/
		}
	},
	
	zoomOutNode: function(){		
		if(this.zoomed && !this.selected){
			this.zoomed = false;
			this.zoomNode(this.originalWidth,this.originalHeight);
		}

	},
	
	initRefreshJobs: function(){
		if(this.statusRefresh){
			var params = {
					command : "/getStatus",
					arguments : {
						nodeId : this.id
					}
				};
			
			var job = Ext.create('NV.ajax.scheduler.RefreshJob', {
				fixParams : params,
				url:"",
				batchedAjaxEnabled:window.globalAjaxClient?true:false,
				callback : function(json){
					this.scope.status = json;
					this.scope.drawStatusChart();
				},
				scope : this,
				doOnFirstTime: true,
				refreshIntervall : this.statusRefreshTime
			});
			job.start();
			
			
		}
		
		if(this.nodeRefresh){
			this.draw();
			var params = {
					command : this.propertiesCmd,
					arguments : {
						nodeId : this.id
					}
				};
			
			var job = Ext.create('NV.ajax.scheduler.RefreshJob', {
				url:this.propertiesUrl,
				fixParams : params,
				batchedAjaxEnabled:window.globalAjaxClient?true:false,
				callback : function(json){
		
					Ext.apply(this.scope,json);
					this.scope.draw();
				},
				scope : this,
				doOnFirstTime: true,
				refreshIntervall : this.nodeRefreshTime
			});
			job.start();
		}
		else{
			this.draw();
		}
	},
	
	drawStatusChart: function(){
		if(this.statusChart && this.status){
		
			if(this.statusIcons){
				for(var i = 0; i<this.statusIcons.length; i++){
					this.statusIcons[i].remove();
				}
			}
			
			this.statusIcons = [];
			
			if (this.zoomed){
				this.originalStatusSize = this.statusChart.config.imageSize;
				this.statusChart.config.imageSize = 40;
			}
			
			for(var i=0; i<this.status.length; i++){
				var statusIconPath = "";
				if(this.topologyModel.get('imageUrl')){
					statusIconPath = this.topologyModel.get('imageUrl')+"status/";
						
				}else{
					statusIconPath = "resource/dashboard-layout/image/status/";
				}
				
				
				var img;
				if(this.statusChart.field.icon && this.status[i][this.statusChart.field.icon]=="text"){
					if(i==0){
						img = this.paper.text(this.x-this.statusChart.config.imageSize/2, this.y-this.statusChart.config.imageSize/2+5, this.status[i][this.statusChart.field.value]);
					}
					else if(i==1){
						img = this.paper.text( this.x-this.statusChart.config.imageSize/2+this.width, this.y-this.statusChart.config.imageSize/2+5, this.status[i][this.statusChart.field.value]);
					}
					else if(i==2){
						img = this.paper.text( this.x-this.statusChart.config.imageSize/2+this.width, this.y+this.height-this.statusChart.config.imageSize/2+5, this.status[i][this.statusChart.field.value]);
					}
					else if(i==3){
						img = this.paper.text(this.x-this.statusChart.config.imageSize/2, this.y+this.height-this.statusChart.config.imageSize/2+5, this.status[i][this.statusChart.field.value]);
					}
					img.attr({"font-weight":"bold"});
					if(this.zoomed){
						img.attr({"font-size":16});
					}
				}else{
					if(this.statusChart.field.icon &&  this.status[i][this.statusChart.field.icon]){
						statusIconPath += this.status[i][this.statusChart.field.icon]+"/";
					}else if(this.statusChart.config.type){
						statusIconPath += this.statusChart.config.type+"/";
					}else{
						statusIconPath += "default/";
					}
					
					statusIconPath+=this.status[i][this.statusChart.field.value]+".png";

					if(i==0){
						img = this.paper.image(statusIconPath, this.x-this.statusChart.config.imageSize/2, this.y-this.statusChart.config.imageSize/2, this.statusChart.config.imageSize, this.statusChart.config.imageSize);
					}
					else if(i==1){
						img = this.paper.image(statusIconPath, this.x-this.statusChart.config.imageSize/2+this.width, this.y-this.statusChart.config.imageSize/2, this.statusChart.config.imageSize, this.statusChart.config.imageSize);
					}
					else if(i==2){
						img = this.paper.image(statusIconPath, this.x-this.statusChart.config.imageSize/2+this.width, this.y+this.height-this.statusChart.config.imageSize/2, this.statusChart.config.imageSize, this.statusChart.config.imageSize);
					}
					else if(i==3){
						img = this.paper.image(statusIconPath, this.x-this.statusChart.config.imageSize/2, this.y+this.height-this.statusChart.config.imageSize/2, this.statusChart.config.imageSize, this.statusChart.config.imageSize);
					}
					
				}
				
				img.mouseover(function(evt){
					Ext.create('Ext.tip.ToolTip',{
			            target: evt.currentTarget,
			            html: this.tooltip,
			            dismissDelay: 15000, // auto hide after 15 seconds
			            showDelay: 500
			        });
				}, {
					thisObject:this, 
					img: img,
					tooltip: this.status[i][0]
					});
				this.statusIcons.push(img);
			}
			
			if (this.zoomed){
				this.statusChart.config.imageSize = this.originalStatusSize;
			}
		}
	},
	
	createTooltip: function(action, portletContent){
		this.tooltipAction = Ext.create('NV.dashboard.actionhandler.ActionHandler',{
			action: action,
			context:"this.scope.equipment.parameters",
			scope: {
				equipment: this,
				portletContent: portletContent,
				eventType:"mouseover",
				target:this.icon.node
			},
			portletContentObject: portletContent
		});
	},
	
	applyEventHandler: function(event, fn, scope){
		if(event=='rightclick'){
			event='mousedown';
		}
		if(this.iconVisible){
			this.icon[event](fn, scope);
			this.iconBG[event](fn, scope);
		}
		if(this.labelVisible){
			this.labelShape[event](fn, scope);
			this.labelBG[event](fn, scope);
		}
	},
	
	addHandler: function(event, fn, scope){
		this.handlers.push({event:event, fn: fn, scope:scope});
	},
	
	addSelectionHandler: function(element){
		element.drag(
				//move
			function(dx, dy, x,y,evt){
				if(this.selected){
					dx *= this.zoomableSurface.ratio;
					dy *= this.zoomableSurface.ratio;
					
					this.ddx = dx - this.ddx;
					this.ddy = dy - this.ddy;
					this.toFront();
					this.move(dx,dy);
					
					this.ddx = dx;
					this.ddy = dy;
					
					evt.stopPropagation();
				}
			},
			//start
			function(x,y,evt){
				if(this.zoomed){
					this.zoomOutNode();
				}
				this.selected = true;
				this.ddx = 0;
				this.ddy = 0;
				evt.stopPropagation();
				
				
			},
			//end
			function(evt){
				this.selected = false;
				if(this.ddx == 0 && this.ddy == 0){
					return;
				}

				this.x = this.iconX;
				this.y = this.iconY;
				
				this.graph.refreshNavigator();
				if(this.container){
					this.container.redraw();
				}
				
				this.draw();
				if(this.waitingForRedraw){
					this.waitingForRedraw = false;
					
				}
				
				evt.stopPropagation();
				
			},
			this, this, this
		);
		
		
	},
	/**
	 * Node move (mouse drag)
	 * @param dx
	 * @param dy
	 */
	move: function(dx, dy){
		
		if(this.labelVisible){
			this.labelBG.transform("t"+dx+","+dy);
			this.labelShape.transform("t"+dx+","+dy);
		}
		if(this.iconVisible){
			this.iconBG.transform("t"+dx+","+dy);
			this.icon.transform("t"+dx+","+dy);
		}

		if(this.statusIcons){
			for(var i = 0; i<this.statusIcons.length; i++){
				var img = this.statusIcons[i];
				img.transform("t"+dx+","+dy);
			}
		}
		
		this.iconX = this.x+dx;
		this.iconY = this.y+dy;
		this.minX += dx;
		
		if(this.labelVisible && this.width < this.labelWidth){
			this.minX = this.iconX - (this.labelWidth - this.width)/2;
		}else{
			this.minX = this.iconX;
		}
		
		for(var i=0; i<this.connections.length; i++){
			this.connections[i].redraw();
		}
		
		if(this.container){
			this.container.redraw();
		}
	},
	
	/**
	 * container move
	 * @param dx
	 * @param dy
	 */
	moveAlone: function(dx, dy){
		if(this.labelVisible){
			this.labelBG.transform("t"+dx+","+dy);
			this.labelShape.transform("t"+dx+","+dy);
		}
		if(this.iconVisible){
			this.iconBG.transform("t"+dx+","+dy);
			this.icon.transform("t"+dx+","+dy);
		}
		
		if(this.statusIcons){
			for(var i = 0; i<this.statusIcons.length; i++){
				var img = this.statusIcons[i];
				img.transform("t"+dx+","+dy);
			}
		}
		
		
		this.iconX = this.x+dx;
		this.iconY = this.y+dy;		
		this.minX += dx;
		
		
		
		for(var i=0; i<this.connections.length; i++){
			if(this.connections[i].anode.container != this.container || this.connections[i].znode.container != this.container ){
				this.connections[i].redraw(false);
			}else{
				this.connections[i].move(dx,dy);
			}
		}
		
		
	//	this.toFront();
	},
	setPosition: function(x,y){
		this.iconX = x;
		this.iconY = y;
		
		if(this.iconVisible){
			this.icon.attr({
				x: x,
				y: y
			});
			this.iconBG.attr({
				x: x,
				y: y
			});
		}		
		if(this.labelVisible){
			this.labelShape.attr({
				x: x+this.width/2, 
				y: y+this.height+10
			});
			this.labelBG.attr({
				x: this.labelShape.attr('x')-this.labelWidth/2, 
				y: this.labelShape.attr('y')-this.labelShape.node.clientHeight/2
			});
			
			if(this.width<this.labelWidth){
				this.minX = x-(this.labelWidth-this.width)/2;
			}else{
				this.minX = x;
			}
		}else{
			this.minX = x;
		}
		

		if(this.statusIcons){
			for(var i = 0; i<this.statusIcons.length; i++){
				var img = this.statusIcons[i];
				if(i==0){
					img.attr({
						x: x-this.statusChart.config.imageSize/2,
						y: y-this.statusChart.config.imageSize/2
					});
				}
				else if(i==1){
					img.attr({
						x: x-this.statusChart.config.imageSize/2+this.width,
						y: y-this.statusChart.config.imageSize/2
					});			}
				else if(i==2){
					img.attr({
						x: x-this.statusChart.config.imageSize/2+this.width,
						y: y-this.statusChart.config.imageSize/2+this.height
					});
				}
				else if(i==3){
					img.attr({
						x: x-this.statusChart.config.imageSize/2,
						y: y-this.statusChart.config.imageSize/2+this.height
					});
				}
			}
		}
	
	},
	
	hoverByOther: function(hover){
		this.toFront();
		if(this.hoveredByOther!=hover){
			this.hoveredByOther=hover;
			if(hover){//eddig nem volt kijelölve, de most kell
				if(!this.hovered){
					this.setBG(this.lightHoverColor, true);	
				}
			}else{
				if(!this.hovered){
					this.setBG(this.bgColor, true);	
				}
			}
		}
	},
	
	hover: function(hover){
		this.toFront();
		if(this.hovered!=hover){
			this.hovered = hover;
			if(hover){
				if(this.zoomOnOver){
					this.zoomInNode();
				}
				this.setBG(this.hoverColor, false);	
				
			}else{
				if(this.zoomOnOver){
					this.zoomOutNode();
				}
				this.zoomOutNode();
				this.setBG(this.bgColor, true);	
			}
			
			for(var i=0; i<this.connections.length; i++){
				this.connections[i].hover(hover);
			}
		}
	},
	
	setBG: function(bgcolor, animate){
	/*	if(animate){
			this.set.animate({
				fill: bgcolor.hex,
				"fill-opacity": bgcolor.opacity
			}, 500);
		}else{*/
			this.set.attr({
				fill: bgcolor.hex,
				"fill-opacity": bgcolor.opacity
			});	
		//}
		
	},
	
	getConnectionsNumberTo: function(znode){
		var num = 0;
		for(var c in this.connections){
			if(this.connections[c].anode == znode || this.connections[c].znode == znode){
				num++;
			}
		}
		return num;
	},
	
	// get the position of a connection to an another node
	getPosOfConnection : function(node, conn) {
		var pos = 1;
		for ( var i = 0; i < this.connections.length; i++) {
			if (this.connections[i] == conn)
				return pos;
			if ((this.connections[i].anode == node) || (this.connections[i].znode == node))
				pos++;
		}
		return 0;
	},
	
	getConfig:function(){
		var ret = {
			id: this.id,
			name: this.label,
			type: this.type,
			x: this.x,
			y:this.y
		};
		if(!this.defWidth){
			ret.width = this.width;
		}
		if(!this.defHeight){
			ret.height = this.height;
		}
		if(this.containerId){
			ret.containerId = this.containerId;
		}
		ret = Ext.apply(this.parameters, ret);
		return ret;
	},
	
	toFront: function(){
		try{
			//ha van container, akkor a vonalak rajzolását ő végzi
			if(!this.container){
				for(var i=0; i<this.connections.length; i++){
		//			this.connections[i].toFront();
				}
			}
			
			if(this.iconVisible){
				
				this.iconBG.toFront();
				this.icon.toFront();
			}		
			if(this.labelVisible){
				this.labelBG.toFront();
				this.labelShape.toFront();
			}
			
			if(this.statusIcons){
				for(var i = 0; i<this.statusIcons.length; i++){
					var img = this.statusIcons[i];
					img.toFront();
				}
			}
		}catch(e){
			
		}
	},
	
	zoomOutGraph: function(zoomFactor){
		this.zoomGraph(this.x/zoomFactor, this.y/zoomFactor);		
	},
	
	zoomInGraph: function(zoomFactor){
		this.zoomGraph(this.x*zoomFactor, this.y*zoomFactor);
	},
	
	zoomGraph : function(newX, newY){
		if(this.initialConfig.labelVisible){
			if(this.zoomableSurface.ratio>1.5){
				if(this.labelVisible){
					this.labelVisible = false;
					this.draw();
				}
			}else{
				if(!this.labelVisible){
					this.labelVisible = true;
					this.draw();

				}
			}
		}
	}
});

Ext.ClassManager.addNameAliasMappings({
  "NV.canvas.gui.raphael.shapes.Connection": [],
  "NV.canvas.gui.func.Functions": [],
  "NV.canvas.gui.raphael.ZoomableSurface": [],
  "NV.canvas.gui.model.TopologyModel": [],
  "NV.canvas.gui.raphael.shapes.Node": [],
  "NV.canvas.gui.raphael.NavigatorWindow": [],
  "NV.canvas.gui.raphael.FloatingStatusWindow": [],
  "NV.canvas.gui.raphael.shapes.Container": [],
  "NV.canvas.gui.raphael.Graph": [],
  "NV.canvas.gui.raphael.Topology": [],
  "NV.canvas.gui.actions.NodeIconChanger": []
});
